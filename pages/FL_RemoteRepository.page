<apex:page sidebar="false" controller="FL_RemoteRepositoryController" action="{!checkAuthentication}" tabStyle="FL_Remote_Repository__tab" doctype="html-5.0">
    <apex:includeScript value="{!URLFOR($Resource.FL_FlosumJS, 'jszip-master/dist/jszip.js')}"/>
    <apex:includeScript value="{!URLFOR($Resource.FL_FlosumJS,'jszip-master/flosumsf/flosumsf1.6.0.js')}"/>
    <apex:includeScript value="{!URLFOR($Resource.FL_FlosumJS, 'jszip-master/angular/angular.min.js')}"/>
    <apex:includeScript value="{!$Resource.FL_X2JS}"/>
    <apex:includeScript value="{!URLFOR($Resource.FL_Zipp, 'res/ga.js')}"/>
    <apex:includeScript value="{!URLFOR($Resource.FL_Zipp, 'res/js/zip.js')}"/>

    <apex:stylesheet value="{!URLFOR($Resource.Merge, 'Merge/css/bootstrapSF.min.css')}" />
    <apex:stylesheet value="{!URLFOR($Resource.Merge, 'Merge/ngDialog/ngDialog.min.css')}" />
    <apex:stylesheet value="{!URLFOR($Resource.Merge, 'Merge/ngDialog/ngDialog-theme-default.css')}" />
    <apex:stylesheet value="{!URLFOR($Resource.Merge, 'Merge/ngDialog/ngDialog-theme-plain.min.css')}" />
    
    <apex:includeScript value="{!URLFOR($Resource.Merge, 'Merge/jquery-2.1.4.min.js')}"/>
    <apex:includeScript value="{!URLFOR($Resource.Merge, 'Merge/jquery-ui.js')}"/>
    <apex:includeScript value="{!URLFOR($Resource.Merge, 'Merge/ngDialog/ngDialog.min.js')}"/>
    <apex:includeScript value="{!URLFOR($Resource.Merge, 'Merge/diff.js')}"/>
    <apex:includeScript value="{!URLFOR($Resource.Merge, 'Merge/xml2json.js')}"/>
    <apex:includeScript value="{!URLFOR($Resource.Merge, 'Merge/angular-base64.min.js')}"/>
    <apex:includeScript value="{!URLFOR($Resource.Merge, 'Merge/deep-diff-0.3.3.min.js')}"/>
    <apex:includeScript value="{!URLFOR($Resource.Merge, 'Merge/diff_match_patch.js')}"/>
    <c:FL_Wait />
    <apex:includeScript value="{!URLFOR($Resource.FL_Moment, 'Moment/moment.js')}"/>
    <apex:includeScript value="{!URLFOR($Resource.FL_Moment, 'Moment/moment-timezone-with-data.js')}"/>
    <apex:pagemessages id="msg"/>
    <apex:form id="formId" rendered="{!isAuthSuccessful}">
        <apex:actionFunction name="redirectToLog" action="{!redirectToLog}" reRender="msg" onComplete="enableBoth();">
            <apex:param assignTo="{!IsSuccessDeployment}" value="" name="deploymentFlag"/>
            <apex:param assignTo="{!logRecordId}" value="" name="logId"/>
        </apex:actionFunction>  
        <div ng-app="remoteRepository">               
            <div ng-controller ="RepositoryController" id="angularControllerId">
                <div class="ng-cloak">
                    <script type="text/ng-template" id="templatePopUpMergeXML">
                        <div class="sf-inner-container" style="width: 95%;">
                            <div style="text-align: center; width: 95%;">
                                <button type="button" class="btn btn-warning" ng-click="PopUp.closeManualMerge()">Cancel</button>
                                <button type="button" style="background-color: #2A94D6;" class="btn btn-success" ng-click="PopUp.ManualMerge(PopUp.EtalonValue, PopUp.ItemId)">Apply Changes</button>
                            </div>
                            <div><merge-xml sourse="{{PopUp.base}}" target="{{PopUp.newfile}}" file="PopUp.EtalonValue" xml="true"/></div>
                            <div style="text-align: center; width: 95%;">
                                <button type="button" class="btn btn-warning" ng-click="PopUp.closeManualMerge()">Cancel</button>
                                <button type="button" style="background-color: #2A94D6;" class="btn btn-success" ng-click="PopUp.ManualMerge(PopUp.EtalonValue, PopUp.ItemId)">Apply Changes</button>
                            </div>
                            
                        </div>
                    </script>

                    <script type="text/ng-template" id="templatePopUpMergeText">
                        <div class="sf-inner-container" style="width: 95%;">
                            <div style="text-align: center; width: 95%;">
                                <button type="button" class="btn btn-warning" ng-click="PopUp.closeManualMerge()">Cancel</button>
                                <button type="button" style="background-color: #2A94D6;" class="btn btn-success" ng-click="PopUp.ManualMerge(PopUp.EtalonValue, PopUp.ItemId)">Apply Changes</button>
                            </div>
                            <div><mergeinfo sourse="{{PopUp.base}}" target="{{PopUp.newfile}}" file="PopUp.EtalonValue" /></div>
                            <div style="text-align: center; width: 95%;">
                                <button type="button" class="btn btn-warning" ng-click="PopUp.closeManualMerge()">Cancel</button>
                                <button type="button" style="background-color: #2A94D6;" class="btn btn-success" ng-click="PopUp.ManualMerge(PopUp.EtalonValue, PopUp.ItemId)">Apply Changes</button>
                            </div>
                            
                        </div>
                    </script>
                    
                    <script type="text/ng-template" id="templatePopUpMergeFileId">
                        <div class="sf-inner-container" style="width: 95%;">
                            {{PopUp.Info}}
                        </div>
                    </script>
                    <script type="text/ng-template" id="templatePopUpInfoId">
                        <div class="sf-inner-container" style="width: 95%;">
                            <div class="form-group">
                                <label for="TaskWeight">Component Type</label>
                                {{PopUp.Info.ComponentType}}
                            </div>
                            <div class="form-group">
                                <label for="TaskWeight">API Name: </label>
                                {{PopUp.Info.APIName}}
                            </div>
                            <div class="form-group">
                                <label for="TaskWeight">Label: </label>
                                {{PopUp.Info.Label}}
                            </div>
                                    
                            <div class="form-group">
                                <label for="TaskWeight">Last Component History Id In Branch: </label>
                                <a href="/{{PopUp.Info.LastComponentHistoryId}}" target="_blank">{{PopUp.Info.LastComponentHistoryId}}</a>
                            </div>
                            <div class="form-group">
                                <label for="TaskWeight">Last Component History in Branch CRC32: </label>
                                {{PopUp.Info.LastComponentHistoryCRC32}}
                            </div>
                            <div class="form-group">
                                <label for="TaskWeight">Last Component History Version in Branch: </label>
                                {{PopUp.Info.LastComponentHistoryVersion}}
                            </div>
                            <div class="form-group">
                                <label for="TaskWeight">Last Component History Attachment ID: </label>
                                <a href="/{{PopUp.Info.LastComponentHistoryATID}}" target="_blank">{{PopUp.Info.LastComponentHistoryATID}}</a>
                            </div>
                            <div class="form-group">
                                <label for="TaskWeight">Deployed: </label>
                                {{PopUp.Info.Deployed}}
                            </div>
                            <div class="form-group">
                                <label for="TaskWeight">Last Date Deployed Component History: </label>
                                {{PopUp.Info.DeployedComponentHistoryLastDate}}
                            </div>
                            <div class="form-group">
                                <label for="TaskWeight">Deployed Component History Id: </label>
                                <a href="/{{PopUp.Info.DeployedComponentHistoryId}}" target="_blank">{{PopUp.Info.DeployedComponentHistoryId}}</a>
                            </div>
                            <div class="form-group">
                                <label for="TaskWeight">Deployed Component History CRC32: </label>
                                {{PopUp.Info.DeployedComponentHistoryCRC32}}
                            </div>
                            <div class="form-group">
                                <label for="TaskWeight">Deployed Component History Version: </label>
                                {{PopUp.Info.DeployedComponentHistoryVersion}}
                            </div>
                            <div class="form-group">
                                <label for="TaskWeight">Deployed Component History Attachment ID: </label>
                                <a href="/{{PopUp.Info.DeployedComponentHistoryATID}}" target="_blank">{{PopUp.Info.DeployedComponentHistoryATID}}</a>
                            </div>
                            
                        </div>
                    </script>
                    <apex:pageBlock html-ng-show="showFirstPageBlock" >              
                        <apex:pageBlockbuttons location="top">
                            <apex:commandbutton action="{!startDownloadChanges}" value="{!$Label.FL_Download_Changes_from_Remote_Repository}" onClick="show();"  onComplete="getRemoteAccount('{!downloadChangesFrom}'); hide();" html-ng-disabled="disableDownloadOrgButton"/>
                            <apex:commandbutton value="Update Local Org with These Changes" onclick="setCompTypes(); return false;" reRender="msg" html-ng-disabled="disableUpdateOrgButton"/>  
                        </apex:pageBlockbuttons>
                        <apex:pageBlockSection columns="1" rendered="{!!previousSyncRecordFound}">
                            <apex:inputField value="{!lastModifiedFrom.Changed_On__c}" label="This org has never been synced with the Repository. Flosum will download the changes from the Remote Repository since" html-ng-disabled="disableDownloadOrgButton" id="changedCommittedAfterId"/>
                        </apex:pageBlockSection>
                        <apex:pageBlockSection columns="1" id="tableId">
                            <table ng-show="componentList.length > 0" class="list">
                                <thead>
                                    <tr class="headerRow">
                                        <th>No.</th>
                                        <th ng-repeat = "(key, value) in fieldSet">
                                            <a ng-click="refreshOrderBy(key)">{{ orderByColumn == key ? isReverse ? value+' ▼' : value+' ▲' : value }}</a>
                                        </th>
                                    </tr>
                                </thead>
                                <tbody>
                                    <tr ng-repeat = "meta in componentList | orderBy: orderByColumn :isReverse | limitTo: viewLimit" ng-if="$index >= metaOffSet" class="dataRow"
                                    onmouseover="if (window.hiOn){hiOn(this);} " onmouseout="if (window.hiOff){hiOff(this);} ">
                                        <td>{{ $index+1 }}</td>
                                        <td ng-repeat = "(key, value) in fieldSet">
                                            {{ meta[key == 'lastModifiedDate'? 'lastModifiedDate' : key] }}
                                        </td>
                                    </tr>
                                </tbody>
                            </table>                    
                        </apex:pageBlockSection>
                        <apex:outputPanel html-ng-show="componentList.length > 0" styleClass="pagination" layout="block" style="text-align: center;">
                            <apex:commandbutton html-ng-click="showFirst();" onClick="return false;" value="First" reRender="none" html-ng-disabled="isPrevious() || disableNextPrevious"/>
                            <apex:commandbutton html-ng-click="listPrevious();" onClick="return false;" value="Previous" reRender="none" html-ng-disabled="isPrevious() || disableNextPrevious" />
                            Total {{(componentList).length}} components, Page {{currentPageNo((componentList).length)}} of {{totalPageCount((componentList).length)}}
                            <apex:commandbutton html-ng-click="listNext((componentList).length);" onClick="return false;" value="Next" reRender="none" html-ng-disabled="isNext((componentList).length) || disableNextPrevious"/>
                            <apex:commandbutton html-ng-click="showLast((componentList).length);" onClick="return false;" value="Last" reRender="none" html-ng-disabled="isNext((componentList).length) || disableNextPrevious"/>
                        </apex:outputPanel>
                    </apex:pageBlock>
                    <apex:pageBlock title="Conflict Resolution" html-ng-show="showSecondPageBlock">
                        <apex:pageBlockSection columns="1">
                            <apex:pageBlockSectionItem >
                                <apex:outputLabel value="Sync Name"/>
                                <apex:inputText value="{!syncName}" id="syncNameId"/>
                            </apex:pageBlockSectionItem>
                        </apex:pageBlockSection>
                        <!-- <apex:pageBlock >
                            <p>Following components have been updated in the repository, but not updated in local org. The local org will be updated with the following components.</p> -->
                        <apex:pageBlock title="New Components">
                            <p>This section shows the new components in the Remote Repository, but not in the local org.</p>
                            <apex:pageBlockbuttons location="top">
                                <apex:commandbutton value="Download Changes from Repository" reRender="none" onclick="getRemoteCompContents(); return false;" html-ng-disabled="disableContinueUpdateButton"/>
                            </apex:pageBlockbuttons>
                            <apex:pageBlockSection columns="1" id="tableIdNew">
                                <table ng-show="componentList.length > 0" class="list">
                                    <thead>
                                        <tr class="headerRow">
                                            <th>No.</th>
                                            <th ng-repeat = "(key, value) in fieldSet">
                                                <a ng-click="refreshOrderBy(key)">{{ orderByColumn == key ? isReverse ? value+' ▼' : value+' ▲' : value }}</a>
                                            </th>
                                        </tr>
                                    </thead>
                                    <tbody>
                                        <tr ng-repeat = "meta in componentList | orderBy: orderByColumn :isReverse | limitTo: viewLimit" ng-if="$index >= metaOffSet" class="dataRow"
                                        onmouseover="if (window.hiOn){hiOn(this);} " onmouseout="if (window.hiOff){hiOff(this);} ">
                                            <td>{{ $index+1 }}</td>
                                            <td ng-repeat = "(key, value) in fieldSet">
                                                {{ meta[key == 'lastModifiedDate'? 'lastModifiedDate' : key] }}
                                            </td>
                                        </tr>
                                    </tbody>
                                </table>                    
                            </apex:pageBlockSection>
                            <apex:outputPanel html-ng-show="componentList.length > 0" styleClass="pagination" layout="block" style="text-align: center;">
                                <apex:commandbutton html-ng-click="showFirst();" onClick="return false;" value="First" reRender="none" html-ng-disabled="isPrevious() || disableNextPrevious || disableContinueUpdateButton"/>
                                <apex:commandbutton html-ng-click="listPrevious();" onClick="return false;" value="Previous" reRender="none" html-ng-disabled="isPrevious() || disableNextPrevious || disableContinueUpdateButton"/>
                                Total {{(componentList).length}} components, Page {{currentPageNo((componentList).length)}} of {{totalPageCount((componentList).length)}}
                                <apex:commandbutton html-ng-click="listNext((componentList).length);" onClick="return false;" value="Next" reRender="none" html-ng-disabled="isNext((componentList).length) || disableNextPrevious || disableContinueUpdateButton"/>
                                <apex:commandbutton html-ng-click="showLast((componentList).length);" onClick="return false;" value="Last" reRender="none" html-ng-disabled="isNext((componentList).length) || disableNextPrevious || disableContinueUpdateButton"/>
                            </apex:outputPanel>
                        </apex:pageBlock>

                        <!-- <apex:pageBlock >
                            <p>Following components have been updated in the repository and have been updated in local org. However there is no conflict between these components.</p>
                            <apex:pageBlockSection columns="1" id="tableIdNewNotConflict">
                                <table ng-show="GoodMergeItems.length > 0" class="list">
                                    <thead>
                                        <tr class="headerRow">
                                            <th>No.</th>
                                            <th class="description">Component Type&nbsp;</th>
                                            <th class="name">Component Name&nbsp;</th>
                                            <th class="Label">Label&nbsp;</th>
                                            <th class="Label">Deployed&nbsp;</th>
                                            <th class="Label">In Repository&nbsp;</th>
                                            <th class="Label">Is Last Version&nbsp;</th>
                                        </tr>
                                    </thead>
                                    <tbody>
                                        <tr ng-repeat="item in GoodMergeItems ">
                                            <td>{{ $index+1 }}</td>
                                            <td>{{item.ComponentType}}</td>
                                            <td>{{item.APIName}}</td>
                                            <td>{{item.Label}}</td>
                                            <td>
                                                <span ng-if="item.Deployed"><img src="/img/checkbox_checked.gif" alt="Checked" width="21" height="16" class="checkImg" title="Checked"/></span>
                                                <span ng-if="!item.Deployed"><img src="/img/checkbox_unchecked.gif" alt="Not Checked" width="21" height="16" class="checkImg"  title="Not Checked"/></span>
                                                
                                            </td>
                                            <td>
                                                <span ng-if="item.inBranch"><img src="/img/checkbox_checked.gif" alt="Checked" width="21" height="16" class="checkImg" title="Checked"/></span>
                                                <span ng-if="!item.inBranch"><img src="/img/checkbox_unchecked.gif" alt="Not Checked" width="21" height="16" class="checkImg"  title="Not Checked"/></span>
                                            </td>
                                            <td>
                                                <span ng-if="item.IsLastVersion"><img src="/img/checkbox_checked.gif" alt="Checked" width="21" height="16" class="checkImg" title="Checked"/></span>
                                                <span ng-if="!item.IsLastVersion"><img src="/img/checkbox_unchecked.gif" alt="Not Checked" width="21" height="16" class="checkImg"  title="Not Checked"/></span>
                                            </td>
                                        </tr>
                                    </tbody>
                                </table>                    
                            </apex:pageBlockSection>
                            <apex:outputPanel html-ng-show="GoodMergeItems.length > 0" styleClass="pagination" layout="block" style="text-align: center;">
                                <apex:commandbutton html-ng-click="notConflictShowFirst();" onClick="return false;" value="First" reRender="none" html-ng-disabled="notConflictIsPrevious() || notConflictDisableNextPrevious || disableContinueUpdateButton"/>
                                <apex:commandbutton html-ng-click="notConflictListPrevious();" onClick="return false;" value="Previous" reRender="none" html-ng-disabled="notConflictIsPrevious() || notConflictDisableNextPrevious || disableContinueUpdateButton"/>
                                Total {{(GoodMergeItems).length}} components, Page {{notConflictCurrentPageNo((GoodMergeItems).length)}} of {{totalPageCount((GoodMergeItems).length)}}
                                <apex:commandbutton html-ng-click="notConflictListNext((GoodMergeItems).length);" onClick="return false;" value="Next" reRender="none" html-ng-disabled="notConflictIsNext((GoodMergeItems).length) || notConflictDisableNextPrevious || disableContinueUpdateButton"/>
                                <apex:commandbutton html-ng-click="notConflictShowLast((GoodMergeItems).length);" onClick="return false;" value="Last" reRender="none" html-ng-disabled="notConflictIsNext((GoodMergeItems).length) || notConflictDisableNextPrevious || disableContinueUpdateButton"/>
                            </apex:outputPanel>
                        </apex:pageBlock> -->

                        <!-- <apex:pageBlock > -->
                            <!-- <p>Following components have been updated in the repository and have been updated in local org. There is a conflict in these components.</p> -->
                            <!-- <p>Following components have been updated in the repository and have been updated in local org.</p> -->
                        <apex:pageBlock title="Modified Components">
                            <p>This section shows the components which exist in both the local org and remote repository but have been modified in the local org.</p>
                            <apex:pageBlockSection columns="1" id="tableIdNewConflict">
                                <table ng-show="FirstStepItems.length > 0" class="list">
                                    <thead>
                                        <tr class="headerRow">
                                            <th>No.</th>
                                            <th class="name">Component Name&nbsp;</th>
                                            <th class="description">Component Type&nbsp;</th>
                                            <th class="Label">Label&nbsp;</th>
                                            <th class="Label">Deployed&nbsp;</th>
                                            <th class="Label">In Repository&nbsp;</th>
                                            <th class="Label">Is Last Version&nbsp;</th>
                                            <th class="Label" style="text-align: center;">Conflict&nbsp;</th>
                                        </tr>
                                    </thead>
                                    <tbody>
                                        <tr ng-repeat="item in FirstStepItems ">
                                            <td>{{ $index+1 }}</td>
                                            <td>{{item.APIName}}</td>
                                            <td>{{item.ComponentType}}</td>
                                            <td>{{item.Label}}</td>
                                            <td>
                                                <span ng-if="item.Deployed"><img src="/img/checkbox_checked.gif" alt="Checked" width="21" height="16" class="checkImg" title="Checked"/></span>
                                                <span ng-if="!item.Deployed"><img src="/img/checkbox_unchecked.gif" alt="Not Checked" width="21" height="16" class="checkImg"  title="Not Checked"/></span>
                                                
                                            </td>
                                            <td>
                                                <span ng-if="item.inBranch"><img src="/img/checkbox_checked.gif" alt="Checked" width="21" height="16" class="checkImg" title="Checked"/></span>
                                                <span ng-if="!item.inBranch"><img src="/img/checkbox_unchecked.gif" alt="Not Checked" width="21" height="16" class="checkImg"  title="Not Checked"/></span>
                                            </td>
                                            <td>
                                                <span ng-if="item.IsLastVersion"><img src="/img/checkbox_checked.gif" alt="Checked" width="21" height="16" class="checkImg" title="Checked"/></span>
                                                <span ng-if="!item.IsLastVersion"><img src="/img/checkbox_unchecked.gif" alt="Not Checked" width="21" height="16" class="checkImg"  title="Not Checked"/></span>
                                            </td>
                                            
                                            <!-- <td><button  style="" type="button"  ng-click="OpenPopUpInfo(item)" class="btn btn-success btn-xs">Info Item</button></td> -->
                                            
                                            <td style="text-align: center;">
                                                <!-- <span ng-show="item.IsLastVersion"><img width="20" height="20" src="{!URLFOR($Resource.Merge,'Merge/image/ok-xxl.png')}"/></span> -->
                                                <span ng-show="item.AutoMergeStart && !item.AutoMergeFinish"><img width="20" height="20" src="{!URLFOR($Resource.Merge,'Merge/image/animatedEllipse.gif')}"/></span>
                                                
                                                <span style="cursor: pointer;" ng-click="getMergeInfo(item)" ng-show="item.AutoMergeFinish && item.AutoMergeStatus && !item.IsManualMerge"><img width="80" height="20" src="{!URLFOR($Resource.Merge,'Merge/image/conflict.png')}"/></span>
                                                <span style="cursor: pointer;" ng-click="getMergeInfo(item)" ng-show="item.AutoMergeFinish && (!item.AutoMergeStatus || item.IsManualMerge)"><img width="20" height="20" src="{!URLFOR($Resource.Merge,'Merge/image/merge-128.png')}"/></span>
                                                
                                                <span ng-show=""></span>
                                            </td> 
                                        </tr>
                                    </tbody>
                                </table>                    
                            </apex:pageBlockSection>
                            <apex:outputPanel html-ng-show="FirstStepItems.length > 0" styleClass="pagination" layout="block" style="text-align: center;">
                                <apex:commandbutton html-ng-click="conflictShowFirst();" onClick="return false;" value="First" reRender="none" html-ng-disabled="conflictIsPrevious() || conflictDisableNextPrevious || disableContinueUpdateButton"/>
                                <apex:commandbutton html-ng-click="conflictListPrevious();" onClick="return false;" value="Previous" reRender="none" html-ng-disabled="conflictIsPrevious() || conflictDisableNextPrevious || disableContinueUpdateButton"/>
                                Total {{(FirstStepItems).length}} components, Page {{conflictCurrentPageNo((FirstStepItems).length)}} of {{totalPageCount((FirstStepItems).length)}}
                                <apex:commandbutton html-ng-click="conflictListNext((FirstStepItems).length);" onClick="return false;" value="Next" reRender="none" html-ng-disabled="conflictIsNext((FirstStepItems).length) || conflictDisableNextPrevious || disableContinueUpdateButton"/>
                                <apex:commandbutton html-ng-click="conflictShowLast((FirstStepItems).length);" onClick="return false;" value="Last" reRender="none" html-ng-disabled="conflictIsNext((FirstStepItems).length) || conflictDisableNextPrevious || disableContinueUpdateButton"/>
                            </apex:outputPanel>
                        </apex:pageBlock>
                    </apex:pageBlock>
                </div>      
            </div>
        </div>
    </apex:form>    
    <script>
        Visualforce.remoting.timeout = 120000; // Set timeout at page level
        zip.workerScriptsPath = "{!URLFOR($Resource.FL_Zipp,'res/js/workers')}/";
        var zipFileEntry, zipWriter, writer, creationMethod, URL = window.webkitURL || window.mozURL || window.URL;
        
        String.prototype.trunc = String.prototype.trunc ||
            function(n){
                return (this.length > n) ? this.substr(0,n-1)+'...' : this.substr(0);
            };
        Number.prototype.trunc = Number.prototype.trunc ||
            function(n){
                return this.toString();
            };

        var deployOnlyPackagePermission = {!IsDeployOnlyPackagePermission};
        var localUser = '{!localUser}';
        var allCompsMap = [];
        var filteredMetaItems = {};          //map of objects
        var checkAllRetrieved = 0;
        var filterId = '';
        var lastId ;
        var localOrgCompCrcMap = {};    // store compType#compName ----> crc of retrieved comp of local org
        var localOrgCompBase64Map = {};
        var localUpdateCompList = []; 
        var listOfcomIds = [];      // for deployment
        var listOfAttachmentIds = [];
        var selectMap = {};
        var attchIdCompTypeMap = {};
        var remoteChangesMap = {};
        
        //retrieval of local flosum org components
        var flosumsf = jsforce;
        var selfConn = createSelfConnection();
        var filterValue;
        var apiVersion = {!localApiVersion};
        var normalZip = new JSZip();
        fileMap= {};
        var CompTypeCompListMap = {};
        var firstLimit = 3000;
        var AsyncIdMap = {};
        var AsyncIdsIndex = 0;
        var AsyncIdsLi = [];
        
        var index;
        
        var currentRequestLi = [];
        var requestIndex = 0; 
        var requestMetaTypeLi = [];
        var currentRequestIndex = 0;
        var filteredMetaItems = {};
        var RemainingAsyncIdLi = [];
        
        var attachmentIndex = 0;
        var attachmentIdsListToDeploy = [];
        var patchDataMap = {};
        var patchItems = [];
        var deployCompMap = {};
        var packageXml = '';
        
        var UnknownErrorInDeploy = [];
        var successItemMap = {};
        var errorItemMap = {};
        var runAllTestMap = {};
        var specificLi = [];

        var createdSet = {};
        var updatedSet = {};
        var deletedSet = {};
        
        var successLog = '';
        var errorLog = '';
        var runTestLog = '';
        var successDeployment = false;
        var IsCheckOnly = false;
        var base64StrData = '';
        var deploymentLogId = '';
        
        var RunTesOption;
        
        var ValidName = {'ApexClass': [], 
                            'CustomObject': [], 
                            'ApexPage':[], 
                            'CustomTab': [],
                            'Layout': [],
                            'CustomApplication':[],
                            'ExternalDataSource':[],
                            'CustomPermission':[],
                            'CustomField':[],
                            'RecordType':[]
                        };
        
        var permissionMap = {};
        permissionMap['CustomObject'] = ['*'];
        permissionMap['ApexClass'] = ['*'];
        permissionMap['ApexPage'] = ['*'];
        permissionMap['Layout'] = ['*'];
        permissionMap['CustomTab'] = ['*'];
        permissionMap['CustomApplication'] = ['*'];
        permissionMap['ExternalDataSource'] = ['*'];
        permissionMap['CustomPermission'] = ['*'];
        
        var customObjectTranslationsInfoSet = ['CustomField','QuickAction','RecordType','SharingReason','ValidationRule','WebLink','WorkflowTask','Layout'];
        var translationsInfoSet = ['CustomApplication','CustomLabels','CustomPageWebLink','CustomTab','QuickAction','ReportType','Scontrol'];
        
        var folderMap = {};
        folderMap['DocumentFolder'] = 'Document';
        folderMap['DashboardFolder'] = 'Dashboard';
        folderMap['ReportFolder'] = 'Report';
        folderMap['EmailFolder'] = 'EmailTemplate';
        
        var parentMap = {};
        parentMap['Workflow'] = 'Workflow';
        parentMap['CustomObject'] = 'CustomObject';
        parentMap['CustomLabels'] = 'CustomLabels';
        parentMap['AssignmentRules'] = 'AssignmentRules';
        parentMap['AutoResponseRules'] = 'AutoResponseRules';
        parentMap['MatchingRules'] = 'MatchingRules';
        parentMap['ManagedTopics'] = 'ManagedTopics';
        parentMap['EscalationRules'] = 'EscalationRules';
        parentMap['Package-xml'] = 'Package-xml';
        
        var typeToFolderMap = {};
        typeToFolderMap['Document'] = 'DocumentFolder';
        typeToFolderMap['Dashboard'] = 'DashboardFolder';
        typeToFolderMap['Report'] = 'ReportFolder';
        typeToFolderMap['EmailTemplate'] = 'EmailFolder';
        
        var folderToTypeMap = {};
        folderToTypeMap['DocumentFolder'] = 'Document';
        folderToTypeMap['DashboardFolder'] = 'Dashboard';
        folderToTypeMap['ReportFolder'] = 'Report';
        folderToTypeMap['EmailFolder'] = 'EmailTemplate';
        
        var bundleTypes = {};
        bundleTypes['AuraDefinitionBundle'] = 'AuraDefinitionBundle';
        
        var orderedMetadataTypeLi = [ 'CustomLabel',
                                      'StaticResource',
                                      'Group',
                                      'Queue',
                                      'DocumentFolder',
                                      'DashboardFolder',
                                      'ReportFolder',
                                      'EmailFolder',
                                      'Document',
                                      'EmailTemplate',
                                      'CustomObject',
                                      'CustomField',
                                      'RecordType',
                                      'Picklist',
                                      'FieldSet',
                                      'ValidationRule',
                                      'ListView',
                                      'WebLink',
                                      'SharingReason',
                                      'BusinessProcess',
                                      'ActionOverride',
                                      'CompactLayout', 
                                      'ReportType',
                                      'ApexClass',
                                      'ApexComponent',
                                      'ApexPage',
                                      'ApexTrigger',
                                      'CustomTab',
                                      'Layout',
                                      'SearchLayouts',
                                      'HomePageLayout',
                                      'HomePageComponent',
                                      'CustomPageWebLink',
                                      'AssignmentRules',
                                      'AssignmentRule',
                                      'AutoResponseRules',
                                      'AutoResponseRule',
                                      'Workflow',
                                      'WorkflowAlert',
                                      'WorkflowFieldUpdate',
                                      'WorkflowOutboundMessage',
                                      'WorkflowTask',
                                      'ApprovalProcess',
                                      'RemoteSiteSetting',
                                      'CriteriaBasedSharingRule', 
                                      'BaseSharingRule',
                                      'AppMenu',
                                      'CustomApplication', 
                                      'CustomApplicationComponent',
                                      'PermissionSet',
                                      'Role',
                                      'Profile',
                                      'Dashboard',
                                      'Report',
                                      'SharingRules',
                                      'SharingOwnerRule',
                                      'SharingCriteriaRule',
                                      'MatchingRules',
                                      'MatchingRule',
                                      'EscalationRules',
                                      'EscalationRule',
                                      'FlexiPage'];
        
        var mmap = {};
        mmap['CustomLabel'] = true;
        mmap['CustomField'] = true;
        mmap['CompactLayout'] = true;
        mmap['WebLink'] = true;
        mmap['RecordType'] = true;
        mmap['ListView'] = true;
        mmap['FieldSet'] = true;
        mmap['AssignmentRule'] = true;
        mmap['AutoResponseRule'] = true;
        mmap['ValidationRule'] = true;
        mmap['WorkflowTask'] = true;
        mmap['WorkflowOutboundMessage'] = true;
        mmap['WorkflowFieldUpdate'] = true;
        mmap['WorkflowAlert'] = true;
        mmap['WorkflowRule'] = true;
        mmap['SharingOwnerRule'] = true;
        mmap['SharingCriteriaRule'] = true;
        mmap['BusinessProcess'] = true;
        mmap['SharingReason'] = true;
        mmap['EscalationRule'] = true;
        mmap['MatchingRule'] = true;
        
        var metadataTypeHeaderMap = {};
        metadataTypeHeaderMap['CustomLabel'] = '<?xml version="1.0" encoding="UTF-8"?><CustomLabels xmlns="http://soap.sforce.com/2006/04/metadata">';
        metadataTypeHeaderMap['CustomField'] = '<?xml version="1.0" encoding="UTF-8"?><CustomObject xmlns="http://soap.sforce.com/2006/04/metadata">';
        metadataTypeHeaderMap['CompactLayout'] = '<?xml version="1.0" encoding="UTF-8"?><CustomObject xmlns="http://soap.sforce.com/2006/04/metadata">';
        metadataTypeHeaderMap['WebLink'] = '<?xml version="1.0" encoding="UTF-8"?><CustomObject xmlns="http://soap.sforce.com/2006/04/metadata">';
        metadataTypeHeaderMap['RecordType'] = '<?xml version="1.0" encoding="UTF-8"?><CustomObject xmlns="http://soap.sforce.com/2006/04/metadata">';
        metadataTypeHeaderMap['ListView'] = '<?xml version="1.0" encoding="UTF-8"?><CustomObject xmlns="http://soap.sforce.com/2006/04/metadata">';
        metadataTypeHeaderMap['FieldSet'] = '<?xml version="1.0" encoding="UTF-8"?><CustomObject xmlns="http://soap.sforce.com/2006/04/metadata">';
        metadataTypeHeaderMap['BusinessProcess'] = '<?xml version="1.0" encoding="UTF-8"?><CustomObject xmlns="http://soap.sforce.com/2006/04/metadata">';
        metadataTypeHeaderMap['SharingReason'] = '<?xml version="1.0" encoding="UTF-8"?><CustomObject xmlns="http://soap.sforce.com/2006/04/metadata">';
        metadataTypeHeaderMap['ValidationRule'] = '<?xml version="1.0" encoding="UTF-8"?><CustomObject xmlns="http://soap.sforce.com/2006/04/metadata">';
        metadataTypeHeaderMap['AssignmentRule'] = '<?xml version="1.0" encoding="UTF-8"?><AssignmentRules xmlns="http://soap.sforce.com/2006/04/metadata">';
        metadataTypeHeaderMap['AutoResponseRule'] = '<?xml version="1.0" encoding="UTF-8"?><AutoResponseRules xmlns="http://soap.sforce.com/2006/04/metadata">';
        metadataTypeHeaderMap['WorkflowTask'] = '<?xml version="1.0" encoding="UTF-8"?><Workflow xmlns="http://soap.sforce.com/2006/04/metadata">';
        metadataTypeHeaderMap['WorkflowOutboundMessage'] = '<?xml version="1.0" encoding="UTF-8"?><Workflow xmlns="http://soap.sforce.com/2006/04/metadata">';
        metadataTypeHeaderMap['WorkflowFieldUpdate'] = '<?xml version="1.0" encoding="UTF-8"?><Workflow xmlns="http://soap.sforce.com/2006/04/metadata">';
        metadataTypeHeaderMap['WorkflowAlert'] = '<?xml version="1.0" encoding="UTF-8"?><Workflow xmlns="http://soap.sforce.com/2006/04/metadata">';
        metadataTypeHeaderMap['WorkflowRule'] = '<?xml version="1.0" encoding="UTF-8"?><Workflow xmlns="http://soap.sforce.com/2006/04/metadata">';
        metadataTypeHeaderMap['SharingOwnerRule'] = '<?xml version="1.0" encoding="UTF-8"?><SharingRules xmlns="http://soap.sforce.com/2006/04/metadata">';
        metadataTypeHeaderMap['SharingCriteriaRule'] = '<?xml version="1.0" encoding="UTF-8"?><SharingRules xmlns="http://soap.sforce.com/2006/04/metadata">';
        metadataTypeHeaderMap['EscalationRule'] = '<?xml version="1.0" encoding="UTF-8"?><EscalationRules xmlns="http://soap.sforce.com/2006/04/metadata">';
        metadataTypeHeaderMap['MatchingRule'] = '<?xml version="1.0" encoding="UTF-8"?><MatchingRules xmlns="http://soap.sforce.com/2006/04/metadata">';
        metadataTypeHeaderMap['ManagedTopic'] = '<?xml version="1.0" encoding="UTF-8"?><ManagedTopics xmlns="http://soap.sforce.com/2006/04/metadata">';
        
        var metadataTypeFooterMap = {};
        metadataTypeFooterMap['CustomLabel'] = '</CustomLabels>';
        metadataTypeFooterMap['CustomField'] = '</CustomObject>';
        metadataTypeFooterMap['CompactLayout'] = '</CustomObject>';
        metadataTypeFooterMap['WebLink'] = '</CustomObject>';
        metadataTypeFooterMap['RecordType'] = '</CustomObject>';
        metadataTypeFooterMap['ListView'] = '</CustomObject>';
        metadataTypeFooterMap['FieldSet'] = '</CustomObject>';
        metadataTypeFooterMap['BusinessProcess'] = '</CustomObject>';
        metadataTypeFooterMap['SharingReason'] = '</CustomObject>';
        metadataTypeFooterMap['ValidationRule'] = '</CustomObject>';
        metadataTypeFooterMap['AssignmentRule'] = '</AssignmentRules>';
        metadataTypeFooterMap['AutoResponseRule'] = '</AutoResponseRules>';
        metadataTypeFooterMap['WorkflowTask'] = '</Workflow>';
        metadataTypeFooterMap['WorkflowOutboundMessage'] = '</Workflow>';
        metadataTypeFooterMap['WorkflowFieldUpdate'] = '</Workflow>';
        metadataTypeFooterMap['WorkflowAlert'] = '</Workflow>';
        metadataTypeFooterMap['WorkflowRule'] = '</Workflow>';
        metadataTypeFooterMap['SharingOwnerRule'] = '</SharingRules>';
        metadataTypeFooterMap['SharingCriteriaRule'] = '</SharingRules>';
        metadataTypeFooterMap['EscalationRule'] = '</EscalationRules>';
        metadataTypeFooterMap['MatchingRule'] = '</MatchingRules>';
        metadataTypeFooterMap['ManagedTopic'] = '</ManagedTopics>';
        
        var metadataTypePreTagMap = {};
        metadataTypePreTagMap['CustomLabel'] = '<labels>';
        metadataTypePreTagMap['CustomField'] = '<fields>';
        metadataTypePreTagMap['CompactLayout'] = '<compactLayouts>';
        metadataTypePreTagMap['WebLink'] = '<webLinks>';
        metadataTypePreTagMap['RecordType'] = '<recordTypes>';
        metadataTypePreTagMap['ListView'] = '<listViews>';
        metadataTypePreTagMap['FieldSet'] = '<fieldSets>';
        metadataTypePreTagMap['BusinessProcess'] = '<businessProcesses>';
        metadataTypePreTagMap['SharingReason'] = '<sharingReasons>';
        metadataTypePreTagMap['ValidationRule'] = '<validationRules>';
        metadataTypePreTagMap['AssignmentRule'] = '<assignmentRule>';
        metadataTypePreTagMap['AutoResponseRule'] = '<autoResponseRule>';
        metadataTypePreTagMap['WorkflowTask'] = '<tasks>';
        metadataTypePreTagMap['WorkflowOutboundMessage'] = '<outboundMessages>';
        metadataTypePreTagMap['WorkflowFieldUpdate'] = '<fieldUpdates>';
        metadataTypePreTagMap['WorkflowAlert'] = '<alerts>';
        metadataTypePreTagMap['WorkflowRule'] = '<rules>';
        metadataTypePreTagMap['SharingOwnerRule'] = '<sharingOwnerRules>';
        metadataTypePreTagMap['SharingCriteriaRule'] = '<sharingCriteriaRules>';
        metadataTypePreTagMap['EscalationRule'] = '<escalationRule>';
        metadataTypePreTagMap['MatchingRule'] = '<matchingRules>';
        metadataTypePreTagMap['ManagedTopic'] = '<managedTopic>';
        
        var metadataTypePostTagMap = {};
        metadataTypePostTagMap['CustomLabel'] = '</labels>';
        metadataTypePostTagMap['CustomField'] = '</fields>';
        metadataTypePostTagMap['CompactLayout'] = '</compactLayouts>';
        metadataTypePostTagMap['WebLink'] = '</webLinks>';
        metadataTypePostTagMap['RecordType'] = '</recordTypes>';
        metadataTypePostTagMap['ListView'] = '</listViews>';
        metadataTypePostTagMap['FieldSet'] = '</fieldSets>';
        metadataTypePostTagMap['BusinessProcess'] = '</businessProcesses>';
        metadataTypePostTagMap['SharingReason'] = '</sharingReasons>';
        metadataTypePostTagMap['ValidationRule'] = '</validationRules>';
        metadataTypePostTagMap['AssignmentRule'] = '</assignmentRule>';
        metadataTypePostTagMap['AutoResponseRule'] = '</autoResponseRule>';
        metadataTypePostTagMap['WorkflowTask'] = '</tasks>';
        metadataTypePostTagMap['WorkflowOutboundMessage'] = '</outboundMessages>';
        metadataTypePostTagMap['WorkflowFieldUpdate'] = '</fieldUpdates>';
        metadataTypePostTagMap['WorkflowAlert'] = '</alerts>';
        metadataTypePostTagMap['WorkflowRule'] = '</rules>';
        metadataTypePostTagMap['SharingOwnerRule'] = '</sharingOwnerRules>';
        metadataTypePostTagMap['SharingCriteriaRule'] = '</sharingCriteriaRules>';
        metadataTypePostTagMap['EscalationRule'] = '</escalationRule>';
        metadataTypePostTagMap['MatchingRule'] = '</matchingRules>';
        metadataTypePostTagMap['ManagedTopic'] = '</managedTopic>';

        var updateVersion = [];
        var jsonComponentListConflict;
        var mergeFilesMap = {};

        var beforOpenMainTag = '';
        var openMainTag = '';
        var betweenMainTag = '';        
        var closeMainTag = '';
        //retrieve request for components of local flosum org
        
        function convertGMTToLocalTime(gmtTime)
        {
            try
            {
                var localZoneStr = '{!localZoneStr}';
                var localTime  = moment.utc(gmtTime);
                return localTime.tz(localZoneStr).format('YYYY-MM-DD HH:mm:ss');
            }
            catch(ex)
            {
                return gmtTime;
            }
        }
                
        function getRemoteAccount(modifiedFrom) 
        {
            console.log(modifiedFrom);
            if({!previousSyncRecordFound})
            {
                modifiedFrom = '';
            }
            if({!previousSyncRecordFound} || (modifiedFrom != undefined && modifiedFrom != ''))
            {
                filterId = '';
                remoteChangesMap = {};
                //repeatComps() call itself till all the records are retrieved, here records are retrieved
                //in chunks of 4000 */ 
                setDefaultMessageOnPage('Downloading Changes from Remote Repository...');
                allCompsMap =[]; 
                angular.element(document.getElementById('angularControllerId')).scope().disableDownload(); 
                repeatComps(modifiedFrom);
            }
            else
            {
                showErrorMessage('Please enter a valid datetime value.');
                angular.element(document.getElementById('angularControllerId')).scope().enableDownload();
            }
        }
        
        /* getRemoteAccount() retrieves all repository components from its flosum org, since last sync and 
           stores them in javascript global array allCompsMap  */  
        function repeatComps(modifiedFrom) 
        {
            Visualforce.remoting.Manager.invokeAction(
                '{!$RemoteAction.FL_RemoteRepositoryController.getComponents}',
                filterId,
                modifiedFrom,
                function(result, event)
                {
                    if(event.status) 
                    {
                       if(result.length > 0) 
                       {
                            for(var i = 0; i < result.length ; i++) 
                            {
                                var meta = result[i];
                                if(meta != undefined && meta.compType != undefined)
                                {
                                    var metaType = meta.compType;
                                    //meta.fileName = meta.fileName;
                                    meta.fullName = meta.compName;
                                    meta.type = metaType;
                                    meta.changedOnLocal = convertGMTToLocalTime(meta.changedOn);
                                    meta.committedOnLocal = convertGMTToLocalTime(meta.committedOn);
                                    if(remoteChangesMap[metaType+'#'+meta.fullName] == undefined)
                                    {
                                        allCompsMap.push(meta);
                                        var compList = [];
                                        if(filteredMetaItems[metaType] != undefined) 
                                        {
                                            compList = filteredMetaItems[metaType];
                                        }
                                        compList.push(meta);
                                        filteredMetaItems[metaType] = compList;
                                        remoteChangesMap[metaType+'#'+meta.fullName] = metaType+'#'+meta.fullName;
                                    }
                                }
                            }
                            var last = result.length -1;
                            filterId = result[last].compId+'';
                            repeatComps(modifiedFrom);
                       } 
                       else 
                       {
                            for (var property in filteredMetaItems) 
                            {
                                if(folderToTypeMap[property] == undefined)
                                {
                                    requestMetaTypeLi.push(property);
                                }
                            }
                            setDefaultMessageOnPage('');    
                            if(requestMetaTypeLi.length == 0)
                            {
                                if({!previousSyncRecordFound})
                                    showErrorMessage('No changes found in Remote Repository after last download.');
                                else
                                {
                                    var currentCommittedFromVal = $("[id$='changedCommittedAfterId']").val();
                                    showErrorMessage('No changes found in Remote Repository after '+currentCommittedFromVal+'.');
                                    angular.element(document.getElementById('angularControllerId')).scope().enableDownload();
                                }
                            }
                            else
                            {
                                setDefaultMessageOnPage('The following changes have been made to the Remote Repository.');
                            }
                            angular.element(document.getElementById('angularControllerId')).scope().reRenderRemoteChanges();
                            angular.element(document.getElementById('angularControllerId')).scope().enableUpdateOrg();
                       }                                                        
                    } 
                    else 
                    {
                       console.log(event.message);
                       //Also show message on page
                       showErrorMessage(event.message);
                       angular.element(document.getElementById('angularControllerId')).scope().enableDownload();
                    }
                }
             );
        }
        
        function getRemoteCompContents() 
        {
            setDefaultMessageOnPage('Please wait...');
            angular.element(document.getElementById('angularControllerId')).scope().disableContinueButton();
            bindWindow();
            patchDataMap = {};
            patchItems = [];
            console.log(deployCompMap);
            var tempDeployCompMap = JSON.parse(JSON.stringify(deployCompMap));

            angular.element(document.getElementById('angularControllerId')).scope().getMapMergeFiles();

            console.log(tempDeployCompMap);
            for(var index=0;index < orderedMetadataTypeLi.length; index++)
            {
                var metaType = orderedMetadataTypeLi[index];
                if(tempDeployCompMap[metaType] != undefined)
                {
                    var metaTypeitemDetail = {};
                    metaTypeitemDetail.metaType = metaType;
                    metaTypeitemDetail.items = [];
                    metaTypeitemDetail.items = tempDeployCompMap[metaType];
                    patchItems.push(metaTypeitemDetail);
                    delete tempDeployCompMap[metaType];
                }
            }
            for(var metaType in tempDeployCompMap)
            {
                var metaTypeitemDetail = {};
                metaTypeitemDetail.metaType = metaType;
                metaTypeitemDetail.items = [];
                metaTypeitemDetail.items = tempDeployCompMap[metaType];
                patchItems.push(metaTypeitemDetail);
                delete tempDeployCompMap[metaType];
            }
            if(patchItems.length > 0)
            {
                packageXml = packageXmlCreator(patchItems);
                createValidDATA();
                attachmentIndex = 0;
                getAttachmentsContent();
            }
            else
            {
                showErrorMessage('No new or modified components found in Remote Repository after last download.');
            }
        }
        
        function getAttachmentsContent()
        {
            if(attachmentIndex  < attachmentIdsListToDeploy.length)
            {
                Visualforce.remoting.Manager.invokeAction(
                       '{!$RemoteAction.FL_RemoteRepositoryController.getAttachmentContent}',
                       attachmentIdsListToDeploy[attachmentIndex],
                       JSON.stringify(mergeFilesMap),
                       handleContent);
            }
            else
            {
                console.log('Content Store Done.');
                //all attachment collected succesfully.
                fileListCreator();
            }
        }
        
        function handleContent(r,e)
        {
            if(e.status) 
            {
                if(attachmentIdsListToDeploy[attachmentIndex].length != r.length)
                {
                    showErrorMessage('The definition of some of Remote Repository components may have been deleted.');
                }
                else if(r.length > 0)
                {
                    var attReadIndex = 0;
                    var readFullAtt = function(){
                        if(attReadIndex < r.length)
                        {
                            var att = r[attReadIndex];
                            console.log(att);
                            var parentId = att.parentId;
                            var metaType = att.compType;
                            var base64str = att.base64;
                            // use a Data64URIReader to read the zip from a base64 string
                            zip.createReader(new zip.Data64URIReader(base64str), function(reader) {
                                var EntryIndex = 0;
                                // get all entries from the zip
                                reader.getEntries(function(entries) {
                                    if(entries.length)
                                    {
                                        var readSingleFile = function(){
                                                if (EntryIndex < entries.length) 
                                                {
                                                    var singleEntry = entries[EntryIndex];
                                                    var fileName = singleEntry.filename;
                                                    if(parentMap[metaType] != undefined || ((metaType == 'Profile' || metaType == 'PermissionSet') && deployOnlyPackagePermission))
                                                    {
                                                        entries[EntryIndex].getData(new zip.TextWriter(), function(text) {
                                                            if(fileName != undefined && fileName != 'package.xml')
                                                            {
                                                                if(metaType == 'Profile' || metaType == 'PermissionSet')
                                                                {
                                                                    text = validationProfileAndPermissionSet(text);
                                                                }
                                                                patchDataMap[metaType+'#'+fileName] = text;
                                                            }
                                                            EntryIndex++;
                                                            readSingleFile();
                                                        });
                                                    }
                                                    else if(mmap[metaType] == undefined)
                                                    {
                                                        entries[EntryIndex].getData(new zip.BlobWriter(), function(blobData) {
                                                            if(fileName != undefined && fileName != 'package.xml')
                                                            {
                                                                patchDataMap[metaType+'#'+fileName] = blobData;
                                                            }
                                                            EntryIndex++;
                                                            readSingleFile();
                                                        });
                                                    }
                                                    else
                                                    {
                                                        entries[EntryIndex].getData(new zip.TextWriter(), function(text) {
                                                            if(fileName != undefined && fileName != 'package.xml')
                                                            {
                                                                childSplitter(text,metaType,fileName);
                                                            }
                                                            EntryIndex++;
                                                            readSingleFile();
                                                        });
                                                    }
                                                }
                                                else
                                                {
                                                    // close the zip reader
                                                    reader.close(function() {
                                                      // onclose callback
                                                        attReadIndex++;
                                                        readFullAtt();
                                                    });
                                                }
                                            }
                                            readSingleFile();
                                    }
                                    else
                                    {
                                        console.log('!entries.length');
                                    }
                                });
                            }, function(error) {
                                  // onerror callback
                                  console.log('Error in reading file from attachments.');
                                  console.log(error);
                                  console.log(JSON.stringify(error));
                                    if(error.message != undefined)
                                    {
                                        showErrorMessage(error.message);
                                    }
                                    else
                                    {
                                        showErrorMessage(JSON.stringify(error));
                                    }
                            });
                        }
                        else
                        {
                            attachmentIndex++;
                            getAttachmentsContent();
                        }
                    }
                    readFullAtt();
                }
                else
                {
                    attachmentIndex++;
                    getAttachmentsContent();
                }
            } 
            else 
            {
                showErrorMessage(e.message);
            }
        }
        
        function fileListCreator()
        {
            var ZipfilesMap = {};
            if(patchItems.length > 0)
            {
                var patchTypeIndex = 0;
                var addPatchTypes = function(){
                    if(patchTypeIndex < patchItems.length)
                    {
                        var metaTypeitemDetail = patchItems[patchTypeIndex];
                        var componentType = metaTypeitemDetail.metaType;
                        var metaTypeitems = metaTypeitemDetail.items;
                        
                        var patchItemIndex = 0;
                        var addSingleTypeItems = function(){
                            if(patchItemIndex < metaTypeitems.length)
                            {
                                //collect file
                                var item = metaTypeitems[patchItemIndex];
                                var fileName = item.fileName;
                                var fullName = item.compName;
                                var fileData = undefined;
                                var compKey = componentType+'#'+fileName;
                                if(mmap[componentType] == undefined)
                                {
                                    if(folderMap[componentType] != undefined)
                                    {
                                        compKey = folderMap[componentType]+'#'+fileName;
                                    }
                                    if(patchDataMap[compKey] != undefined)
                                    {
                                        fileData = patchDataMap[compKey];
                                    }
                                    else
                                    {
                                        if(bundleTypes[componentType] != undefined)
                                        {
                                            for(var key in patchDataMap)
                                            {
                                                if(key != undefined && key.indexOf(compKey+'/') == 0)
                                                {
                                                    var fName = key.replace(componentType+'#','');
                                                    var fileInfo = new Object();
                                                    fileInfo.name = fName;
                                                    fileInfo.data = patchDataMap[key];
                                                    fileInfo.type = componentType;
                                                    ZipfilesMap[fName]= fileInfo;
                                                }
                                            }
                                        }
                                        else
                                            console.log('component not found.'+componentType+'----'+fullName);
                                    }
                                }
                                else
                                {
                                    compKey = componentType+'#'+fullName;
                                    if(patchDataMap[compKey] != undefined)
                                    {
                                        if(ZipfilesMap[fileName] != undefined)
                                        {
                                            var fileInfo = ZipfilesMap[fileName];
                                            var zipData = fileInfo.data;
                                            var newData = patchDataMap[compKey];
                                            var tempData = childXMLJoin(zipData,newData,componentType,fullName);
                                            fileData = tempData;
                                        }
                                        else
                                        {
                                            fileData = patchDataMap[compKey];
                                        }
                                    }
                                    else
                                    {
                                        console.log('component not found.'+componentType+'----'+fullName);
                                    }
                                }
                                if(fileData != undefined)
                                {
                                    var fileInfo = new Object();
                                    fileInfo.name = fileName;
                                    fileInfo.data = fileData;
                                    fileInfo.type = componentType;
                                    ZipfilesMap[fileName]= fileInfo;
                                    var metaXmlKey = compKey+'-meta.xml';
                                    if(patchDataMap[metaXmlKey] != undefined)
                                    {
                                        var metaXmlFileName = fileName+'-meta.xml';
                                        var xmlData = patchDataMap[metaXmlKey];
                                        
                                        var xmlfileInfo = new Object();
                                        xmlfileInfo.name = metaXmlFileName;
                                        xmlfileInfo.data = xmlData;
                                        xmlfileInfo.type = componentType;
                                        ZipfilesMap[metaXmlFileName]= xmlfileInfo;
                                    }
                                }
                                patchItemIndex++;
                                setTimeout(addSingleTypeItems, 0005);
                            }
                            else
                            {
                                patchTypeIndex++;
                                setTimeout(addPatchTypes, 0005);
                            }
                        }
                        addSingleTypeItems();
                    }
                    else
                    {
                        zipFiles(ZipfilesMap);
                    }
                }
                addPatchTypes();
            }
            else
            {
                showErrorMessage('No zip files found.');
            }
        }
        
        function zipFiles(ZipfilesMap)
        {
            var ZipfilesList = [];
            for(var key in ZipfilesMap)
            {
                ZipfilesList.push(ZipfilesMap[key]);
            }
            if(packageXml != undefined && packageXml != '')
            {
                var xmlfileInfo = new Object();
                xmlfileInfo.name = 'package.xml';
                xmlfileInfo.data = packageXml;
                xmlfileInfo.type = 'Package-xml';
                ZipfilesList.push(xmlfileInfo);
            }
            if(ZipfilesList.length > 0)
            {
                deploymentZipFileCreator(ZipfilesList);
            }
            else
            {
                showErrorMessage('There should be at least one item to deploy.');
            }
        }
        
        function deploymentZipFileCreator(files) 
        {
            var addIndex = 0;
            var tempWriter;
            function nextFile() 
            {
                var file = files[addIndex];
                if(file.type == 'Profile' || file.type == 'PermissionSet' || mmap[file.type] != undefined || parentMap[file.type] != undefined)
                {
                        tempWriter.add(file.name, new zip.TextReader(file.data), function() {
                        addIndex++;
                        if (addIndex < files.length)
                            nextFile();
                        else
                        {
                            tempWriter.close(function(base64Data) {
                                    base64StrData = base64Data.slice(base64Data.indexOf(';base64,') + 8);
                                    //startDeployment(base64Data);
                                    createLog();
                                });
                        }
                    });
                }
                else
                {
                        tempWriter.add(file.name, new zip.BlobReader(file.data), function() {
                        addIndex++;
                        if(addIndex < files.length)
                            nextFile();
                        else
                        {
                            tempWriter.close(function(base64Data) {
                                    base64StrData = base64Data.slice(base64Data.indexOf(';base64,') + 8);
                                    //startDeployment(base64Data);
                                    createLog();
                                });
                        }
                    });
                }
            }

            function createZipWriter() {
                  zip.createWriter(new zip.Data64URIWriter(), function(writer2) {
                    tempWriter = writer2;
                    nextFile();
                }, function(error) {
                    // onerror callback
                    console.log('Error while creating single zip.');
                    console.log(error);
                    console.log(JSON.stringify(error));
                    if(error.message != undefined)
                    {
                        showErrorMessage(error.message);
                    }
                    else
                    {
                        showErrorMessage('Unknown error.');
                    }
                });
            }
            createZipWriter();
        }
        
        function createLog()
        {
            deploymentLogId = '';
            var multiThreadComps = [];
            var oneThreadComps = [];
            var threadIndex = 0;
            for(var index=0; index < patchItems.length; index++)
            {
                for(var index2=0; index2 < patchItems[index].items.length; index2++)
                {
                    var item = patchItems[index].items[index2];
                    if(oneThreadComps.length > 1000)
                    {
                        multiThreadComps.push(oneThreadComps);
                        oneThreadComps = [];
                    }
                    oneThreadComps.push(item);
                }
            }
            if(oneThreadComps.length > 0)
            {
                multiThreadComps.push(oneThreadComps);
            }
            function createSyncRecords(){
                if(threadIndex < multiThreadComps.length)
                {
                    var syncNameLocal = $("[id$='syncNameId']").val();
                    var oneThreadJSON = multiThreadComps[threadIndex];
                    Visualforce.remoting.Manager.invokeAction(
                        '{!$RemoteAction.FL_RemoteRepositoryController.createSyncRecords}',
                        deploymentLogId,
                        JSON.stringify(oneThreadJSON),
                        syncNameLocal,
                        function(r, e)
                        {
                            if(e.status) 
                            {
                                if(r != undefined && r.length == 18)
                                {
                                    deploymentLogId = r;
                                    threadIndex++;
                                    createSyncRecords();
                                }
                                else
                                {
                                    showErrorMessage('Uknown Error.');
                                }
                            }
                            else
                            {
                                showErrorMessage(e.message);
                                angular.element(document.getElementById('angularControllerId')).scope().enableContinueButton();
                            }
                        });
                }
                else
                {
                    console.log('Sync record created successfuly.');
                    startDeployment();
                }
            }
            createSyncRecords();
        }
        
        function startDeployment()
        {
            setDefaultMessageOnPage("Updating Org...");
            
            var deployOption = getDeployOptions();
            var IsFirstRun = true;
            selfConn.metadata.deploy(base64StrData, deployOption,function(err, result){
                if(IsFirstRun)
                {
                    IsFirstRun = false;
                    if(err) 
                    {
                        console.log('Error while deploy');
                        console.log(err);
                        console.log(JSON.stringify(err));
                        if(err != null && err != undefined)
                        {
                            UnknownErrorInDeploy.push(JSON.stringify(err));
                        }
                        else
                        {
                            IsNullResponseError = true;
                            UnknownErrorInDeploy.push('The metadata to be deployed was sent to the target Salesforce org. However, the target Salesforce org did not return any response.\nTo check the success of deployment, please login to the target Salesforce organization, and check the deployment status.');
                        }
                        finishDeployment();
                    }
                    else
                    {
                        if(result != undefined && result.id != undefined)
                        {
                            var caseSensitiveDeploymentId = result.id.length == 18 ? result.id.slice(0,15) : result.id;
                            var remainingTime = 10;
                            var idMessage = "To get latest up-to-the-second deployment status, Check Deployment status with name: "+ caseSensitiveDeploymentId;
                            var timeCounter = function(){
                                if(remainingTime > 0)
                                {
                                    var strMessage = "Salesforce is updating your org. Checking deployment status in "+remainingTime+" seconds.\n"+idMessage;
                                    setDefaultMessageOnPage(strMessage);
                                    setTimeout(timeCounter, 1000);
                                    remainingTime--;
                                }
                                else
                                {
                                    selfConn.metadata.checkDeployStatus(result.id,true,deployDetail);
                                }
                            }
                            timeCounter();
                        }
                        else
                        {
                            UnknownErrorInDeploy.push('Async Id not found.');
                               finishDeployment();
                        }
                    }
                }
            });
        }
        
        function deployDetail(err, result)
        {
            if(err)
            {
                console.log('Error while deployDetail');
                console.log(err);
                console.log(JSON.stringify(err));
                if(err != null && err != undefined)
                {
                    UnknownErrorInDeploy.push(JSON.stringify(err));
                }
                else
                {
                    IsNullResponseError = true;  
                    UnknownErrorInDeploy.push('The metadata to be deployed was sent to the target Salesforce org. However, the target Salesforce org did not return any response.\nTo check the success of deployment, please login to the target Salesforce organization, and check the deployment status.');
                }
                //finish deployment and save logs.
                finishDeployment();
            }
            else
            {
                if(result.done)
                {
                    if(result.success)
                    {
                        successDeployment = true;
                    }
                    else
                    {
                        successDeployment = false;
                        if(result.errorMessage != undefined)
                        {
                            UnknownErrorInDeploy.push(result.errorMessage);
                        }
                    }
                    if(result.details != undefined)
                    {
                        if(result.details.runTestResult != undefined)
                        {
                            var testCount=0;
                            runTestLog ='No. of Test Run: '+result.details.runTestResult.numTestsRun +'  Failures: '+result.details.runTestResult.numFailures+' Total Time: '+result.details.runTestResult.totalTime+'\n\n';
                            if(result.details.runTestResult.codeCoverageWarnings != undefined)
                            {
                                if(Array.isArray(result.details.runTestResult.codeCoverageWarnings))
                                {
                                    for(var index in result.details.runTestResult.codeCoverageWarnings)
                                    {
                                        if(index < result.details.runTestResult.codeCoverageWarnings.length)
                                        {
                                            var warning = result.details.runTestResult.codeCoverageWarnings[index];
                                            var error = '\n Coverage Warning: ' + 
                                                           '\n Message: '+warning.message;
                                            if(warning.name != undefined)
                                            {
                                                error = error + '\n ' + warning.name;
                                            }
                                            runAllTestMap[warning.name +''+new Date().getTime()+' '+testCount++]= error;
                                        }
                                    }
                                }
                                else
                                {
                                    var warning = result.details.runTestResult.codeCoverageWarnings;
                                    var error = '\n Coverage Warning: ' + 
                                                   '\n Message: '+warning.message;
                                    if(warning.name != undefined)
                                    {
                                        error = error + '\n ' + warning.name;
                                    } 
                                    runAllTestMap[warning.name +''+new Date().getTime()+' '+testCount++]= error;
                                }
                            }
                            if(result.details.runTestResult.failures != undefined)
                            {
                                if(Array.isArray(result.details.runTestResult.failures))
                                {
                                    for(var index in result.details.runTestResult.failures)
                                    {
                                        if(index < result.details.runTestResult.failures.length)
                                        {
                                            var rtf = result.details.runTestResult.failures[index];
                                            var error = '\n Component Fail name: '+rtf.name;
                                            if(rtf.methodName != undefined && rtf.methodName != '')
                                                error +='\n Method Name: '+rtf.methodName;
                                            error +='\n Message: '+rtf.message;
                                            runAllTestMap[rtf.type_x+''+rtf.name+''+new Date().getTime()+' '+testCount++]= error;
                                        }
                                    }
                                }
                                else
                                {
                                    var rtf = result.details.runTestResult.failures;
                                    var error = '\n Component Fail name: '+rtf.name + 
                                                    '\n Message: '+rtf.message;
                                    runAllTestMap[rtf.type_x+''+rtf.name+''+new Date().getTime()+' '+testCount++]= error;
                                }
                            }
                            if(result.details.runTestResult.successes != undefined)
                            {
                                if(Array.isArray(result.details.runTestResult.successes))
                                {
                                    for(var index in result.details.runTestResult.successes)
                                    {
                                        if(index < result.details.runTestResult.successes.length)
                                        {
                                            var rtf = result.details.runTestResult.successes[index];
                                            var scc = '\n Component Pass name: '+rtf.name + 
                                                    '\n Method Name: '+rtf.methodName;
                                            runAllTestMap[scc.name+''+scc.methodName+''+new Date().getTime()+' '+testCount++]= scc;
                                        }
                                    }
                                }
                                else
                                {
                                    var rtf = result.details.runTestResult.successes;
                                    var scc = '\n Component Pass name: '+rtf.name + 
                                            '\n Method Name: '+rtf.methodName;
                                    runAllTestMap[scc.name+''+scc.methodName+''+new Date().getTime()+' '+testCount++]= scc;
                                }
                            }   
                        }
                        if(result.details.componentFailures != undefined)
                        {
                            if(Array.isArray(result.details.componentFailures))
                            {
                                for(var index in result.details.componentFailures)
                                {
                                    if(index < result.details.componentFailures.length)
                                    {
                                        var failureComp = result.details.componentFailures[index];
                                        var error = '\n File name: '+failureComp.fileName + 
                                                            ', Component name: '+failureComp.fullName + 
                                                            ' (Line: ' + failureComp.lineNumber + ': Column:' + failureComp.columnNumber + ') : ' + 
                                                            '\n Message: '+failureComp.problem;
                                        errorItemMap[failureComp.componentType+':'+failureComp.fileName+''+failureComp.fullName] = error;
                                    }
                                }
                            }
                            else
                            {
                                var failureComp = result.details.componentFailures;
                                var error = '\n File name: '+failureComp.fileName + 
                                                            ', Component name: '+failureComp.fullName + 
                                                            '\n Message: '+failureComp.problem;
                                errorItemMap[failureComp.componentType+':'+failureComp.fileName+''+failureComp.fullName] = error;
                            }
                        }
                        if(result.details.componentSuccesses != undefined && result.success)
                        {
                            if(Array.isArray(result.details.componentSuccesses))
                            {
                                for(var index in result.details.componentSuccesses)
                                {
                                    if(index < result.details.componentSuccesses.length)
                                    {
                                        var successComp = result.details.componentSuccesses[index];
                                        if(successComp.fullName != 'package.xml')
                                        {
                                            var componentStatus = ( successComp.created == 'true' ? 'CREATED ' : successComp.changed == 'true' ? 'UPDATED ' : successComp.deleted == 'true' ? 'DELETED ' : ' N/A ');
                                            var successMessage = "";            
                                            if(componentStatus != ' N/A ')
                                            {
                                                successMessage = '\n Component '+successComp.fullName + ' is '+componentStatus;
                                                if(!IsCheckOnly)
                                                {
                                                    if(componentStatus == 'CREATED ')
                                                        createdSet[successComp.componentType+':'+successComp.fullName] = successComp.componentType+':'+successComp.fullName;
                                                    else if(componentStatus == 'UPDATED ')
                                                        updatedSet[successComp.componentType+':'+successComp.fullName] = successComp.componentType+':'+successComp.fullName;
                                                    else if(componentStatus == 'DELETED ')
                                                        deletedSet[successComp.componentType+':'+successComp.fullName] = successComp.componentType+':'+successComp.fullName;
                                                }    
                                            }
                                            else
                                            {
                                                //if item status in N/A.
                                                successMessage = '\n Component '+successComp.fullName + '  NO CHANGE';
                                            }
                                            successItemMap[successComp.componentType+':'+successComp.fileName+''+successComp.fullName] = successMessage;
                                        }
                                    }
                                }
                            }
                            else
                            {
                                var successComp = result.details.componentSuccesses;
                                var componentStatus = ( successComp.created == 'true' ? 'CREATED ' : successComp.changed == 'true' ? 'UPDATED ' : successComp.deleted == 'true' ? 'DELETED ' : ' N/A ');
                                var successMessage = '\n Component '+successComp.fullName + ' is '+componentStatus;
                                successItemMap[successComp.componentType+':'+successComp.fileName+''+successComp.fullName] = successMessage;
                            }
                        }
                    }
                    //finish deployment and save logs.
                    finishDeployment();
                }
                else
                {
                    var caseSensitiveDeploymentId = result.id.length == 18 ? result.id.slice(0,15) : result.id;
                    var remainingTime = 10;
                    var idMessage = "To get latest up-to-the-second deployment status, Check Deployment status with name: "+ caseSensitiveDeploymentId;
                    var timeCounter = function(){
                        if(remainingTime > 0)
                        {
                            var strMessage = "Salesforce is updating your org. Checking deployment status in "+remainingTime+" seconds.\n"+idMessage;
                            setDefaultMessageOnPage(strMessage);
                            setTimeout(timeCounter, 1000);
                            remainingTime--;
                        }
                        else
                        {
                            selfConn.metadata.checkDeployStatus(result.id,true,deployDetail);
                        }
                    }
                    timeCounter();
                }
            }
        } 
        
        //finish deployment and save logs.
        function finishDeployment()
        {
                //Success Log
                successLog += '\n---------- Success Log Begin ----------------\n';
                var tempMap = {};
                for(var key in successItemMap)
                {
                    var successList = [];
                    var temp = key.split(':');
                    var mType = 'Unknown';
                    if(temp.length > 0)
                    {
                        mType = temp[0];
                    }
                    if(tempMap[mType])
                    {
                        successList = tempMap[mType];
                    }
                    successList.push(successItemMap[key]);
                    tempMap[mType] = successList;
                }
                //successItemMap = {};
                for(var key in tempMap)
                {
                    if(IsCheckOnly)
                        successLog +=  '\n\n---------- Validate '+key+' ----------------\n';
                    else
                        successLog +=  '\n\n---------- Deployed '+key+' ----------------\n';
                    var successList = tempMap[key];
                    for(var index in successList)
                    {
                        if(index < successList.length)
                            successLog += successList[index];
                    }
                }
                tempMap = {};
                successLog += '\n\n---------- Success Log Finished ----------------\n';
                
                // Error Log
                errorLog += '\n---------- Error Log Begin ----------------\n';
                for(var index in UnknownErrorInDeploy)
                {
                    if(index < UnknownErrorInDeploy.length)
                    {
                        errorLog += UnknownErrorInDeploy[index];
                        errorLog += '\n';
                    }
                }
                tempMap = {};
                for(var key in errorItemMap)
                {
                    var successList = [];
                    var temp = key.split(':');
                    var mType = 'Unknown';
                    if(temp.length > 0)
                    {
                        mType = temp[0];
                    }
                    if(tempMap[mType])
                    {
                        successList = tempMap[mType];
                    }
                    successList.push(errorItemMap[key]);
                    tempMap[mType] = successList;
                }
                //errorItemMap = {};
                for(var key in tempMap)
                {
                    if(IsCheckOnly)
                        errorLog +=  '\n\n---------- Validate '+key+' ----------------\n';
                    else
                        errorLog +=  '\n\n---------- Deployed '+key+' ----------------\n';
                    var successList = tempMap[key];
                    for(var index in successList)
                    {
                        if(index < successList.length)
                            errorLog += successList[index];
                    }
                }
                tempMap = {};
                errorLog += '\n---------- Error Log Finished ----------------\n';
                
                
                
                
                var attDMLList = [];
                attDMLList.push({ParentId: deploymentLogId,Name : IsCheckOnly ? 'Validate Success Log' : 'Deployment Success Log',Body: stringToBase64Encode(successLog),ContentType : 'text/plain'});
                var IsRunTestEmpty=true;
                for(var key in runAllTestMap)
                {
                    IsRunTestEmpty=false;
                    break;
                }
                if(!IsRunTestEmpty)
                {
                    //Run all test log
                    var fulldetail = runTestLog;
                    runTestLog = '\n---------- Run All Tests Log Begin ----------------\n';
                    runTestLog += fulldetail;
                    for(var key in runAllTestMap)
                    {
                        runTestLog +=  runAllTestMap[key];
                        runTestLog += '\n';
                    }
                    runTestLog += '\n\n---------- Run All Tests Log Finished ----------------\n';
                    var runTestLogName = RunTesOption == 'RunSpecifiedTests' ? 'Run Specified Tests Log' : 'Run All Tests Log';
                    attDMLList.push({ParentId: deploymentLogId,Name : runTestLogName,Body: stringToBase64Encode(runTestLog),ContentType : 'text/plain'});
                }
                attDMLList.push({ParentId: deploymentLogId,Name : IsCheckOnly ? 'Error Log' : 'Error Log',Body: stringToBase64Encode(errorLog),ContentType : 'text/plain'});
                var selfConn = new flosumsf.Connection({ accessToken: '{!$Api.Session_Id}' });
                selfConn.sobject('Attachment').create(attDMLList,logSaveHandler);
        }
        
        function logSaveHandler(err, ret)
        {
            if (err) 
            {
                console.log(err);
                showErrorMessage(err.errorCode);
            }
            else
            {
                unbindWindow();
                setDefaultMessageOnPage('Deployment Done.');

                if (successDeployment) {
                    var jsonUpdateVersion = JSON.stringify(updateVersion);
                    Visualforce.remoting.Manager.invokeAction(
                    '{!$RemoteAction.FL_RemoteRepositoryController.updateVersionComponent}',
                    jsonUpdateVersion,
                    function(r, e){
                        if (e.status) {
                            //angular.element(document.getElementById('angularControllerId')).scope().mergeSelectedList(r);
                        }
                        else
                        {
                            showErrorMessage(e.message);
                        }
                    });
                }

                redirectToLog(successDeployment,deploymentLogId);
            }
        }
        
        function setDefaultMessageOnPage(str)
        {
            if($("#msg") != undefined)
            {
                $("#msg").remove();
            }
            var parentVal = $("[id$='msg']");
            if(parentVal != undefined && str!='')
            {
                var childVal = '<span id="msg"><span ><div class="message warningM4" role="alert"><table border="0" cellpadding="0" cellspacing="0" class="messageTable" style="padding:0px;margin:0px;"><tbody><tr valign="top"><td><img alt="warning" class="" src="/s.gif" title="warning"></td><td class="messageCell"><div id="j_id0:meta:j_id15:j_id16:j_id18" class="messageText"><span>'+str+'</span></span></span>';
                parentVal.before(childVal);
            }
        }
        
        function setCompTypes() 
        {
            angular.element(document.getElementById('angularControllerId')).scope().disableUpdateOrg();
            angular.element(document.getElementById('angularControllerId')).scope().disableNextPreviousButton(); 
            angular.element(document.getElementById('angularControllerId')).scope().conflictDisableNextPreviousButton(); 
            createRequestForRetrieval();
        }
        
        function nextTypeForRetrieval()
        {
            deployCompMap = {};
            attachmentIdsListToDeploy = [];
            attachmentIndex = 0;
            //On Completion of retrieval
            requestIndex++;
            setDefaultMessageOnPage('');
            //Here iterate wrapper of download changes array and if crc of that wrapper object do not match add it in conflict list,(finally empty the local org map as no longer needed)
            var bodyCount = 0;
            var localAttLi = [];
            for(var i=0; i<allCompsMap.length; i++) 
            {
                var key = allCompsMap[i].compType+'#'+allCompsMap[i].compName;
                var compWithStatus = allCompsMap[i];
                if(localOrgCompCrcMap[key] != undefined) 
                //if(localOrgCompCrcMap[key].compCRC != undefined) 
                {
                    if(localOrgCompCrcMap[key] != compWithStatus.compCRC) 
                    //if(localOrgCompCrcMap[key].compCRC != compWithStatus.compCRC) 
                    {
                        // This indicates local org have same component with different crc means changed value hence need to be updated, thus status = modified
                        compWithStatus.Status = 'Modified';
                        compWithStatus.base64Content = localOrgCompBase64Map[key];
                        localUpdateCompList.push(compWithStatus);
                    }
                    else 
                    {
                        compWithStatus.Status = 'Synced';
                        localUpdateCompList.push(compWithStatus);
                    }   
                }
                else 
                {
                    //indicates org do not have this comp, so it need to be included in list, thus status = new 
                    compWithStatus.Status = 'New';
                    localUpdateCompList.push(compWithStatus);
                    listOfcomIds.push(compWithStatus.compId);
                }
                if((bodyCount + compWithStatus.contentSize) > 2000000 && localAttLi.length > 0)
                {
                    attachmentIdsListToDeploy.push(localAttLi);
                    localAttLi = [];
                    bodyCount = 0;
                }
                if(compWithStatus.Status == 'Modified' || compWithStatus.Status == 'New')
                {
                    localAttLi.push(compWithStatus.contentId);
                    bodyCount = bodyCount + compWithStatus.contentSize;
                    //
                    var metaLi = [];
                    if(deployCompMap[compWithStatus.compType] != undefined)
                    {
                        metaLi = deployCompMap[compWithStatus.compType];
                    }
                    metaLi.push(compWithStatus);
                    deployCompMap[compWithStatus.compType] = metaLi;
                }
            }
            if(localAttLi.length > 0)
            {
                attachmentIdsListToDeploy.push(localAttLi);
            }
            //now we have list of wrapper and we have to show that list as components to be updated, 1st hide first pageBlock reinitialize all pagination variables and then show secondPageBlock

            var componentList = [];
            var componentListConflict = [];
            
            for(var i = 0; i < localUpdateCompList.length ; i++) {
              if (localUpdateCompList[i].Status == 'Modified') {
                angular.element(document.getElementById('angularControllerId')).scope().disableContinueButton();
                componentListConflict.push(localUpdateCompList[i]);
              }
              else {
                componentList.push(localUpdateCompList[i]); 
              }
            }
            if (componentListConflict.length > 0) {

              jsonComponentListConflict = JSON.stringify(componentListConflict);

              angular.element(document.getElementById('angularControllerId')).scope().Commit();
              //angular.element(document.getElementById('angularControllerId')).scope().getStatusConflicts();

            }
            
            angular.element(document.getElementById('angularControllerId')).scope().reRenderSecondPage();
        }
        
        //Retrieval
        //Function to create retrieval request
        function createRequestForRetrieval()
        {
            AsyncIdMap = {};
            currentRequestLi = [];
            currentRequestIndex = 0;
            var requestDetailLi = [];
            var largeRequestLi = [];
            var totalCompCount = 0;
            for(var compIndex = 0; compIndex < requestMetaTypeLi.length; compIndex++)
            {
                var metaType = requestMetaTypeLi[compIndex];
                var items = filteredMetaItems[metaType];
                totalCompCount+= items.length
            }
            function createRequestFollAll(){
                if(requestIndex < requestMetaTypeLi.length)
                {
                    var metaType = requestMetaTypeLi[requestIndex];
                    var items = filteredMetaItems[metaType];
                    console.log(metaType+'(NO:- '+items.length+')');
                    if(totalCompCount > 50 && (metaType == 'StaticResource' || metaType == 'Document' || metaType == 'EmailTemplate' || metaType == 'Profile' || metaType == 'PermissionSet'))
                    {
                        var requestDetail = {};
                        requestDetail.MetaType = metaType;
                        requestDetail.Items = items;
                        requestDetail.ItemNames = [];
                        requestDetail.IsFirst = true;
                        var folderNames = {};
                        for(var index=0; index< items.length; index++)
                        {
                            var temoFileName = items[index].fullName;
                            requestDetail.ItemNames.push(temoFileName);
                            if(typeToFolderMap[metaType] != undefined && temoFileName.indexOf('/') > -1)
                            {
                                var folderName = temoFileName.slice(0,temoFileName.indexOf('/'));
                                folderNames[folderName] = folderName;
                            }
                        }
                        for(var folderName in folderNames)
                        {
                            requestDetail.ItemNames.push(folderName);
                        }
                        largeRequestLi.push(requestDetail);
                    }
                    else
                    {
                        var requestDetail = {};
                        requestDetail.MetaType = metaType;
                        requestDetail.Items = items;
                        requestDetail.ItemNames = [];
                        requestDetail.IsFirst = true;
                        var folderNames = {};
                        for(var index=0; index< items.length; index++)
                        {
                            var temoFileName = items[index].fullName;
                            requestDetail.ItemNames.push(temoFileName);
                            if(typeToFolderMap[metaType] != undefined && temoFileName.indexOf('/') > -1)
                            {
                                var folderName = temoFileName.slice(0,temoFileName.indexOf('/'));
                                folderNames[folderName] = folderName;
                            }
                        }
                        for(var folderName in folderNames)
                        {
                            requestDetail.ItemNames.push(folderName);
                        }
                        requestDetailLi.push(requestDetail);
                    }
                    requestIndex++;
                    createRequestFollAll();
                }
                else
                {
                    if(requestDetailLi.length > 0)
                    {
                        currentRequestLi.push(requestDetailLi);
                    }
                    for(var largeIndex=0; largeIndex < largeRequestLi.length; largeIndex++)
                    {
                        requestDetailLi = [];
                        requestDetailLi.push(largeRequestLi[largeIndex]);
                        currentRequestLi.push(requestDetailLi);
                    }
                    console.log(currentRequestLi);
                    console.log('Total '+currentRequestLi.length+' request detail created.');
                    if(filteredMetaItems['Profile'] != undefined || filteredMetaItems['PermissionSet'] != undefined)
                    {
                        listPermissionItems();
                    }
                    else
                        processRequestForRetrieval();
                    //angular.element(document.getElementById('angularControllerId')).scope().finishRetrieval();
                }
            }
            createRequestFollAll();
        }
        
        function listPermissionItems()
        {
               var queryLi = [];
               var query = new Object();
               query.folder = '';
               query.type = 'CustomObject';
               queryLi.push(query);
               selfConn.metadata.list(queryLi, ''+apiVersion, function(err, result){
                   if(err)
                   {
                       console.log(err);
                   }
                   else
                   {
                       var tempLi = [];
                       if(Array.isArray(result))
                       {
                           for(var index in result)
                           {
                               if(index < result.length)
                               {
                                   var meta = result[index];
                                   if(meta != undefined && meta.fullName != undefined)
                                   {
                                       tempLi.push(meta.fullName);
                                   }
                               }
                           }
                       }
                       else
                       {
                           var meta = result;
                           if(meta != undefined && meta.fullName != undefined)
                           {
                               tempLi.push(meta.fullName);
                           }
                       }
                       if(tempLi.length > 0)
                           permissionMap['CustomObject'] = tempLi;
                   }
                   processRequestForRetrieval();
              });
        }
        
        function processRequestForRetrieval()
        {
            if(currentRequestIndex < currentRequestLi.length)
            {
                var typesExistInRequest = {};
                var requestDetailLi = currentRequestLi[currentRequestIndex];
                var req = getRetrieveRequest();
                for(var index=0; index <requestDetailLi.length; index++)
                {
                    var requestDetail = requestDetailLi[index];
                    var metaItemsInRequest = [];
                    var oneType = {};
                    oneType.name = requestDetail.MetaType;
                    oneType.members = requestDetail.ItemNames;
                    req.unpackaged.types.push(oneType);
                    typesExistInRequest[requestDetail.MetaType] = requestDetail.MetaType;
                    setDefaultMessageOnPage('Retrieving metadata...');
                }
                if(typesExistInRequest['Profile'] != undefined || typesExistInRequest['PermissionSet'] != undefined)
                {
                    for(var key in permissionMap)
                    {
                        var tempType = {};
                        tempType.name = key;
                        tempType.members = permissionMap[key];
                        req.unpackaged.types.push(tempType);
                    }
                }
                if(typesExistInRequest['CustomObjectTranslation'] != undefined)
                {
                    for(var index = 0; index < customObjectTranslationsInfoSet.length; index++)
                    {
                        var tempType = {};
                        tempType.name = customObjectTranslationsInfoSet[index];
                        tempType.members = ['*'];
                        req.unpackaged.types.push(tempType);
                    }
                }
                if(typesExistInRequest['Translations'] != undefined)
                {
                    for(var index = 0; index < translationsInfoSet.length; index++)
                    {
                        var tempType = {};
                        tempType.name = translationsInfoSet[index];
                        tempType.members = ['*'];
                        req.unpackaged.types.push(tempType);
                    }
                }
                console.log(req);
                selfConn.metadata.retrieve(req,function(err, result){
                    if(err)
                    {
                        console.log('Error while creating retrieval request.');
                        console.log(err);
                        console.log(req);
                        showErrorMessage(JSON.stringify(err));
                    }
                    else
                    {
                        if(result != undefined && result.id != undefined)
                        {
                            AsyncIdMap[result.id] = requestDetailLi;
                        }
                    }
                    currentRequestIndex++;
                    processRequestForRetrieval();
                });
            }
            else
            {
                AsyncIdsLi = [];
                AsyncIdsIndex = 0;
                for(var AsyncId in AsyncIdMap)
                {
                    AsyncIdsLi.push(AsyncId);
                }
                console.log('Total requests created--'+AsyncIdsLi.length);
                if(AsyncIdsLi.length > 0)
                {
                    currentRequestLi = [];
                    setTimeout(checkRetrievalStatus, 10000);
                }
                else
                {
                    console.log('No request created.');
                }
            }
        }
        
        function checkRetrievalStatus()
        {
            if(AsyncIdsIndex < AsyncIdsLi.length)
            {
                var currentAsyncId = AsyncIdsLi[AsyncIdsIndex];
                var currentAsyncDetailLi = AsyncIdMap[currentAsyncId];
                //var currentMetaType = currentAsyncDetail.MetaType;
                //setDefaultMessageOnPage('Retrieving '+currentMetaType+'.');
                //console.log('Checking request('+currentMetaType+') for retrieval('+(AsyncIdsIndex+1)+'/'+AsyncIdsLi.length+')');
                setDefaultMessageOnPage('Checking retrieval status...');
                selfConn.metadata.checkRetrieveStatus(currentAsyncId,function(err,result){
                    if(err) 
                    {
                        console.log('Error in checkRetrieveStatus.');
                        console.log(err);
                        //showErrorMessage(JSON.stringify(err));
                        breakRetrievalRequest(currentAsyncId);
                    }
                    else
                    {
                        if(result != undefined && result.id != undefined && AsyncIdMap[result.id] != undefined)
                        {
                            if(result.done == 'true')
                            {
                                if(result.success != 'true')
                                {
                                    console.log('Error in retrieval(result.success).');
                                    console.log(result.errorMessage);
                                    //showErrorMessage(result.errorMessage);
                                    breakRetrievalRequest(currentAsyncId);
                                }
                                else
                                {
                                        var zipStr = result.zipFile;
                                        console.log('Zip file length-'+(zipStr.length/(1024*1024))+' MB');
                                        var tempZip = new JSZip(zipStr,{base64:true});
                                        var zipFiles = tempZip.files;
                                        //console.log(zipFiles);
                                        var commitDetailWrap = {};
                                        for(var tempRequestIndex=0; tempRequestIndex < currentAsyncDetailLi.length; tempRequestIndex++)
                                        {
                                            var currentAsyncDetail = currentAsyncDetailLi[tempRequestIndex];
                                            var currentMetaType = currentAsyncDetail.MetaType;
                                            for(var metaIndex=0; metaIndex < currentAsyncDetail.Items.length; metaIndex++)
                                            {
                                                var meta = currentAsyncDetail.Items[metaIndex];
                                                var compDetail = new Object();
                                                compDetail.fullName = meta.fullName;
                                                compDetail.fileName = meta.fileName;
                                                compDetail.metaType = currentMetaType;
                                                compDetail.crcCode = 0;
                                                compDetail.lastModifiedDate = meta.lastModifiedDate;
                                                compDetail.lastModifiedByName = meta.lastModifiedByName;
                                                var fileName = meta.fileName;
                                                var key = currentMetaType+'#'+fileName;
                                                if(mmap[currentMetaType] != undefined)
                                                {
                                                    key = currentMetaType+'#'+meta.fullName;
                                                }
                                                if(bundleTypes[currentMetaType] != undefined)
                                                {
                                                    var fileZip = new JSZip();
                                                    for(var tempFileName in zipFiles)
                                                    {
                                                        if(tempFileName != undefined && tempFileName.indexOf(fileName+'/') == 0)
                                                        {
                                                            var bundleData = getCrcWithData(zipFiles[tempFileName].asBinary());
                                                            fileZip.file(tempFileName,bundleData.data,{binary:true});
                                                            compDetail.crcCode += bundleData.crc32;
                                                        }
                                                    }
                                                    if(compDetail.crcCode != 0)
                                                    {
                                                        compDetail.base64Content = fileZip.generate({type:"base64",compression:"DEFLATE"});
                                                    }
                                                }
                                                else if(zipFiles[fileName] != undefined)
                                                {
                                                    if(currentMetaType == 'Profile' || currentMetaType == 'PermissionSet')
                                                    {
                                                        var fileData = getCrcWithData(zipFiles[fileName].asText());
                                                        compDetail.crcCode = fileData.crc32;
                                                        var fileZip = new JSZip();
                                                        fileZip.file(fileName,fileData.data,{binary:true});
                                                        compDetail.base64Content = fileZip.generate({type:"base64",compression:"DEFLATE"});
                                                    }
                                                    else if(mmap[currentMetaType] == undefined)
                                                    {
                                                        var fileData = getCrcWithData(zipFiles[fileName].asBinary());
                                                        compDetail.crcCode = fileData.crc32;
                                                        var fileZip = new JSZip();
                                                        fileZip.file(fileName,fileData.data,{binary:true});
                                                        var metaXmlData = zipFiles[fileName+"-meta.xml"];
                                                        if(metaXmlData != undefined)
                                                        {
                                                            var tempXMLData = getCrcWithData(metaXmlData.asBinary());
                                                            compDetail.crcCode = compDetail.crcCode+' '+tempXMLData.crc32;
                                                            fileZip.file(fileName+"-meta.xml",tempXMLData.data,{binary:true});
                                                        }
                                                        compDetail.base64Content = fileZip.generate({type:"base64",compression:"DEFLATE"});
                                                    }
                                                    else
                                                    {
                                                        var fileData = zipFiles[fileName].asText();
                                                        var childDataMap = getChildFileMap(currentMetaType,zipFiles[fileName].asText(),fileName);
                                                        if(childDataMap[key] != undefined)
                                                        {
                                                            var childCompData = childDataMap[key];
                                                            var fileZip = new JSZip();
                                                            fileZip.file(fileName,childCompData.data,{binary:true});
                                                            compDetail.crcCode = childCompData.crc32;
                                                            compDetail.base64Content = fileZip.generate({type:"base64",compression:"DEFLATE"});
                                                        }
                                                    }
                                                }
                                                if(compDetail.crcCode != 0)
                                                {
                                                    commitDetailWrap[compDetail.metaType+'#'+compDetail.fullName] = compDetail;
                                                }
                                            }
                                            if(typeToFolderMap[currentMetaType] != undefined && filteredMetaItems[typeToFolderMap[currentMetaType]] != undefined)
                                            {
                                                var folderMetadataItems = filteredMetaItems[typeToFolderMap[currentMetaType]];
                                                for(var metaIndex=0; metaIndex < folderMetadataItems.length; metaIndex++)
                                                {
                                                    var meta = folderMetadataItems[metaIndex];
                                                    
                                                    var compDetail = new Object();
                                                    compDetail.fullName = meta.fullName;
                                                    compDetail.fileName = meta.fileName;
                                                    compDetail.metaType = typeToFolderMap[currentMetaType];
                                                    compDetail.crcCode = 0;
                                                    compDetail.lastModifiedDate = meta.lastModifiedDate;
                                                    compDetail.lastModifiedByName = meta.lastModifiedByName;
                                                    compDetail.base64Content;
                                                    var fileName = meta.fileName;
                                                    var key = currentMetaType+'#'+meta.fileName;
                                                    
                                                    if(zipFiles[fileName] != undefined)
                                                    {
                                                        var fileData = getCrcWithData(zipFiles[fileName].asBinary());
                                                        compDetail.crcCode = fileData.crc32;
                                                        var fileZip = new JSZip();
                                                        fileZip.file(fileName,fileData.data,{binary:true});
                                                        compDetail.base64Content = fileZip.generate({type:"base64",compression:"DEFLATE"});
                                                    }
                                                    if(compDetail.crcCode != 0)
                                                    {
                                                        commitDetailWrap[compDetail.metaType+'#'+compDetail.fullName] = compDetail;
                                                    }
                                                }
                                            }
                                        }
                                        //console.log(commitDetailWrap);
                                        if(!isMapEmpty(commitDetailWrap))
                                        {
                                            for(var key in commitDetailWrap)
                                            {
                                                localOrgCompCrcMap[key] = commitDetailWrap[key].crcCode;
                                                localOrgCompBase64Map[key] = commitDetailWrap[key].base64Content;
                                            }
                                            cotinueCheckRetrievalStatus();
                                        }
                                        else
                                        {
                                            console.log('No item found.');
                                            cotinueCheckRetrievalStatus();
                                        }
                                }
                            }
                            else
                            {
                                RemainingAsyncIdLi.push(currentAsyncId);
                                cotinueCheckRetrievalStatus();
                            }
                        }
                    }
                });
            }
            else
            {
                AsyncIdsLi = [];
                AsyncIdsIndex = 0;
                if(RemainingAsyncIdLi.length > 0)
                {
                    for(var index=0; index < RemainingAsyncIdLi.length; index++ )
                    {
                        AsyncIdsLi.push(RemainingAsyncIdLi[index]);
                    }
                    RemainingAsyncIdLi = [];
                }
                if(AsyncIdsLi.length > 0)
                {
                    AsyncIdsIndex = -1;
                    var remainingTime = 10;
                    var timeCounter = function(){
                          if(remainingTime > 0)
                          {
                              setDefaultMessageOnPage("Retrieval status check is scheduled after "+remainingTime+" seconds.");
                              remainingTime--;
                              setTimeout(timeCounter, 1000);
                          }
                          else
                          {
                              cotinueCheckRetrievalStatus();
                          }
                    }
                    timeCounter();
                }
                else if(currentRequestLi.length > 0)
                {
                    currentRequestIndex = 0;
                    AsyncIdMap = {};
                    setTimeout(processRequestForRetrieval, 005);
                }
                else
                {
                    nextTypeForRetrieval();
                }
            }
        }
        
        function isMapEmpty(tempMap)
        {
            for(key in tempMap)
            {
                return false;
            }
            return true;
        }
        
        function breakRetrievalRequest(currentAsyncId)
        {
            //console.log('breakRetrievalRequest');
            if(AsyncIdMap[currentAsyncId] != undefined)
            {
                var currentAsyncDetailLi = AsyncIdMap[currentAsyncId];
                //console.log('Pre Request');
                //console.log(currentAsyncDetailLi);
                //console.log('-------------------');
                if(currentAsyncDetailLi.length > 1)
                {
                    for(var index=0; index< currentAsyncDetailLi.length; index++)
                    {
                        var currentAsyncDetail = currentAsyncDetailLi[index];
                        var requestDetailLi = [];
                        requestDetailLi.push(currentAsyncDetail);
                        //console.log(requestDetailLi);
                        currentRequestLi.push(requestDetailLi);
                    }
                }
                else if(currentAsyncDetailLi.length == 1)
                {
                    var currentAsyncDetail = currentAsyncDetailLi[0];
                    var currentMetaType = currentAsyncDetail.MetaType;
                    var items = currentAsyncDetail.Items;
                    if(items.length > 1)
                    {
                        var oneTypeMetaItems = [];
                        var localLimit = Math.floor(items.length *.50);
                        for(var index=0; index< items.length; index++)
                        {
                            if(index != 0 && index % localLimit == 0)
                            {
                                var requestDetail = {};
                                requestDetail.MetaType = currentMetaType;
                                requestDetail.Items = oneTypeMetaItems;
                                requestDetail.ItemNames = [];
                                requestDetail.IsFirst = false;
                                var folderNameMap = {};
                                for(var tempIndex in oneTypeMetaItems)
                                {
                                    if(tempIndex < oneTypeMetaItems.length)
                                    {
                                        var temoFileName = oneTypeMetaItems[tempIndex].fullName;
                                        requestDetail.ItemNames.push(temoFileName);
                                        if(typeToFolderMap[currentMetaType] != undefined && temoFileName.indexOf('/') > -1)
                                        {
                                            var folderName = temoFileName.slice(0,temoFileName.indexOf('/'));
                                            folderNameMap[folderName] = folderName;
                                        }
                                    }
                                }
                                for(var folderName in folderNameMap)
                                {
                                    requestDetail.ItemNames.push(folderName);
                                }
                                var requestDetailLi = [];
                                requestDetailLi.push(requestDetail);
                                //console.log(requestDetailLi);
                                currentRequestLi.push(requestDetailLi);
                                oneTypeMetaItems = [];
                            }
                            oneTypeMetaItems.push(items[index]);
                        }
                        if(oneTypeMetaItems.length > 0)
                        {
                            var requestDetail = {};
                            requestDetail.MetaType = currentMetaType;
                            requestDetail.Items = oneTypeMetaItems;
                            requestDetail.ItemNames = [];
                            requestDetail.IsFirst = true;
                            var folderNameMap = {};
                            for(var tempIndex in oneTypeMetaItems)
                            {
                                if(tempIndex < oneTypeMetaItems.length)
                                {
                                    var temoFileName = oneTypeMetaItems[tempIndex].fullName;
                                    requestDetail.ItemNames.push(temoFileName);
                                    if(typeToFolderMap[currentMetaType] != undefined && temoFileName.indexOf('/') > -1)
                                    {
                                        var folderName = temoFileName.slice(0,temoFileName.indexOf('/'));
                                        folderNameMap[folderName] = folderName;
                                    }
                                }
                            }
                            for(var folderName in folderNameMap)
                            {
                                requestDetail.ItemNames.push(folderName);
                            }
                            var requestDetailLi = [];
                            requestDetailLi.push(requestDetail);
                            //console.log(requestDetailLi);
                            currentRequestLi.push(requestDetailLi);
                        }
                    }
                }
            }
            //console.log('---after break----');
            cotinueCheckRetrievalStatus();
        }
        
        function cotinueCheckRetrievalStatus()
        {
            AsyncIdsIndex++;
            setTimeout(checkRetrievalStatus, 10000);
        }
        
        function getCrcWithData(zipData)
        {
            var r = new Object();
            r.crc32 = normalZip.crc32(zipData,32);
            r.data = zipData;
            return r;
        }
        
        function getRetrieveRequest() 
        {
            var retrieveRequest = new Object();
            retrieveRequest.apiVersion = apiVersion;
            retrieveRequest.singlePackage = true;
            retrieveRequest.unpackaged = {};
            retrieveRequest.unpackaged.types = [];
            return retrieveRequest;
        }
        
        function createSelfConnection()
        {
            var conn = new flosumsf.Connection({ accessToken: '{!$Api.Session_Id}' });
            conn.metadata.pollTimeout = 12000000;
            conn.metadata.pollInterval = 4000;
            return conn;
        }
        
        /*function createFileMap(tempComponentType,base64str)
        {
            var tempZip = new JSZip(base64str,{base64:true});
            if(tempComponentType == 'Profile' || tempComponentType == 'PermissionSet')
            {
                for(var fileName in tempZip.files)
                {
                    if(fileName != undefined && (fileName.indexOf("profiles/") == 0 || fileName.indexOf("permissionsets/") == 0)) 
                    {
                        var fileData = tempZip.files[fileName].asText();
                        fileMap[tempComponentType+"#"+fileName] = getCrcWithData(fileData);
                    }
                }
            }
            else if(mmap[tempComponentType] == undefined)
            {
                for(var fileName in tempZip.files)
                {
                    if(fileName != undefined && fileName.charAt(fileName.length - 1) != '/' && fileName != 'package.xml' && fileName != 'undefined') 
                    {
                        var fileData = tempZip.files[fileName].asBinary();
                        fileMap[tempComponentType+"#"+fileName] = getCrcWithData(fileData);
                    }
                }
            }
            else
            {
                for(var fileName in tempZip.files)
                {
                    if(fileName != undefined && fileName.charAt(fileName.length - 1) != '/' && fileName != 'package.xml' && fileName != 'undefined') 
                    {
                        getChildFileMap(tempComponentType,tempZip.files[fileName].asText(),fileName);
                    }
                }
            }
        }*/
        
        function getChildFileMap(metaType,xml,fileName)
        {
            var childCompMap = {};
            var fullName = '';
            if(metaType != 'CustomLabel')
            {
                fullName = fileName.slice(fileName.indexOf("/")+1,fileName.lastIndexOf('.'))+".";
            }
    
            var x2js = new X2JS();
            var jsnMap ={};
            var tempJSON = '';
            var srcjson = x2js.xml_str2json(xml);
            if(srcjson != undefined && srcjson != null)
            {
                var srcitems;
                if(metaType == 'CustomLabel')
                {
                    var srcMetaItem = srcjson.CustomLabels;
                    srcitems = srcMetaItem.labels;
                }
                else if(metaType == 'CustomField')
                {
                    var srcMetaItem = srcjson.CustomObject;
                    srcitems = srcMetaItem.fields;
                }
                else if(metaType == 'ListView')
                {
                    var srcMetaItem = srcjson.CustomObject;
                    srcitems = srcMetaItem.listViews;
                }
                else if(metaType == 'CompactLayout')
                {
                    var srcMetaItem = srcjson.CustomObject;
                    srcitems = srcMetaItem.compactLayouts;
                }
                else if(metaType == 'WebLink')
                {
                    var srcMetaItem = srcjson.CustomObject;
                    srcitems = srcMetaItem.webLinks;
                }
                else if(metaType == 'RecordType')
                {
                    var srcMetaItem = srcjson.CustomObject;
                    srcitems = srcMetaItem.recordTypes;
                }
                else if(metaType == 'FieldSet')
                {
                    var srcMetaItem = srcjson.CustomObject;
                    srcitems = srcMetaItem.fieldSets;
                }
                else if(metaType == 'ValidationRule')
                {
                    var srcMetaItem = srcjson.CustomObject;
                    srcitems = srcMetaItem.validationRules;
                }
                else if(metaType == 'AssignmentRule')
                {
                    var srcMetaItem = srcjson.AssignmentRules;
                    srcitems = srcMetaItem.assignmentRule;
                }
                else if(metaType == 'AutoResponseRule')
                {
                    var srcMetaItem = srcjson.AutoResponseRules;
                    srcitems = srcMetaItem.autoResponseRule;
                }
                else if(metaType == 'WorkflowTask')
                {
                    var srcMetaItem = srcjson.Workflow;
                    srcitems = srcMetaItem.tasks;
                }
                else if(metaType == 'WorkflowOutboundMessage')
                {
                    var srcMetaItem = srcjson.Workflow;
                    srcitems = srcMetaItem.outboundMessages;
                }
                else if(metaType == 'WorkflowFieldUpdate')
                {
                    var srcMetaItem = srcjson.Workflow;
                    srcitems = srcMetaItem.fieldUpdates;
                }
                else if(metaType == 'WorkflowAlert')
                {
                    var srcMetaItem = srcjson.Workflow;
                    srcitems = srcMetaItem.alerts;
                }
                else if( metaType == 'WorkflowRule')
                {
                    var srcMetaItem = srcjson.Workflow;
                    srcitems = srcMetaItem.rules;
                }
                else if(metaType == 'SharingCriteriaRule')
                {
                    var srcMetaItem = srcjson.SharingRules;
                    srcitems = srcMetaItem.sharingCriteriaRules;
                }
                else if(metaType == 'SharingOwnerRule')
                {
                    var srcMetaItem = srcjson.SharingRules;
                    srcitems = srcMetaItem.sharingOwnerRules;
                }
                else if(metaType == 'BusinessProcess')
                {
                    var srcMetaItem = srcjson.CustomObject;
                    srcitems = srcMetaItem.businessProcesses;
                }
                else if(metaType == 'SharingReason')
                {
                    var srcMetaItem = srcjson.CustomObject;
                    srcitems = srcMetaItem.sharingReasons;
                }
                else if(metaType == 'EscalationRule')
                {
                    var srcMetaItem = srcjson.EscalationRules;
                    srcitems = srcMetaItem.escalationRule;
                }
                else if(metaType == 'MatchingRule')    
                {
                    var srcMetaItem = srcjson.MatchingRules;
                    srcitems = srcMetaItem.matchingRules;
                }
                else if(metaType == 'ManagedTopic')
                {
                    var srcMetaItem = srcjson.ManagedTopics;
                    srcitems = srcMetaItem.ManagedTopic;
                }
                if(srcitems != undefined)
                {
                    if(srcitems.fullName == undefined)
                    {   
                        for(var i in srcitems)  
                        {
                            if(i < srcitems.length)
                            {
                                var v = srcitems[i];
                                jsnMap[v.fullName]= JSON.stringify(v);
                            }
                        }            
                    }
                    else
                    {
                        jsnMap[srcitems.fullName] = JSON.stringify(srcitems);
                    }
                }
            }
            for(var name in jsnMap)
            {
                var tempXml = '';
                var tempJSON = jsnMap[name];
                if(tempJSON != undefined)
                {
                    //header
                    if(metaType == 'CustomLabel')
                    {
                        tempXml = '<?xml version="1.0" encoding="UTF-8"?><CustomLabels xmlns="http://soap.sforce.com/2006/04/metadata">';
                    }
                    else if(metaType == 'AssignmentRule' )
                    {
                        tempXml = '<?xml version="1.0" encoding="UTF-8"?><AssignmentRules xmlns="http://soap.sforce.com/2006/04/metadata">';
                    }
                    else if(metaType == 'AutoResponseRule')
                    {
                        tempXml = '<?xml version="1.0" encoding="UTF-8"?><AutoResponseRules xmlns="http://soap.sforce.com/2006/04/metadata">';
                    }
                    else if(metaType == 'WorkflowAlert' || metaType == 'WorkflowFieldUpdate'|| metaType == 'WorkflowOutboundMessage'|| metaType == 'WorkflowTask' || metaType == 'WorkflowRule')
                    {
                        tempXml = '<?xml version="1.0" encoding="UTF-8"?><Workflow xmlns="http://soap.sforce.com/2006/04/metadata">';
                    }
                    else if(metaType == 'SharingCriteriaRule' || metaType == 'SharingOwnerRule')
                    {
                        tempXml = '<?xml version="1.0" encoding="UTF-8"?><SharingRules xmlns="http://soap.sforce.com/2006/04/metadata">';
                    }
                    else if(metaType == 'EscalationRule')
                    {
                        tempXml = '<?xml version="1.0" encoding="UTF-8"?><EscalationRules xmlns="http://soap.sforce.com/2006/04/metadata">';
                    }
                    else if(metaType == 'MatchingRule')
                    {
                        tempXml = '<?xml version="1.0" encoding="UTF-8"?><MatchingRules xmlns="http://soap.sforce.com/2006/04/metadata">';
                    }
                    else if(metaType == 'ManagedTopic')
                    {
                        tempXml = '<?xml version="1.0" encoding="UTF-8"?><ManagedTopics xmlns="http://soap.sforce.com/2006/04/metadata">';
                    }
                    else
                    {
                        tempXml = '<?xml version="1.0" encoding="UTF-8"?><CustomObject xmlns="http://soap.sforce.com/2006/04/metadata">';
                    }
                    
                    //body
                    if(metaType == 'CustomLabel')
                    {
                        tempXml = tempXml +'<labels>'+x2js.json2xml_str($.parseJSON(tempJSON))+'</labels>';
                    }
                    else if(metaType == 'CustomField')
                    {
                        tempXml = tempXml +'<fields>'+x2js.json2xml_str($.parseJSON(tempJSON))+'</fields>'; 
                    }
                    else if(metaType == 'ListView')
                    {
                        tempXml = tempXml +'<listViews>'+x2js.json2xml_str($.parseJSON(tempJSON))+'</listViews>';
                    }
                    else if(metaType == 'CompactLayout')
                    {
                        tempXml = tempXml +'<compactLayouts>'+x2js.json2xml_str($.parseJSON(tempJSON))+'</compactLayouts>';
                    }
                    else if(metaType == 'WebLink')
                    {
                        tempXml = tempXml +'<webLinks>'+x2js.json2xml_str($.parseJSON(tempJSON))+'</webLinks>';
                    }
                    else if(metaType == 'RecordType')
                    {
                        tempXml = tempXml +'<recordTypes>'+x2js.json2xml_str($.parseJSON(tempJSON))+'</recordTypes>';
                    }
                    else if(metaType == 'FieldSet')
                    {
                        tempXml = tempXml +'<fieldSets>'+x2js.json2xml_str($.parseJSON(tempJSON))+'</fieldSets>';
                    }
                    else if(metaType == 'ValidationRule')
                    {
                        tempXml = tempXml +'<validationRules>'+x2js.json2xml_str($.parseJSON(tempJSON))+'</validationRules>';
                    }
                    else if(metaType == 'AssignmentRule')
                    {
                        tempXml = tempXml +'<assignmentRule>'+x2js.json2xml_str($.parseJSON(tempJSON))+'</assignmentRule>';
                    }
                    else if(metaType == 'AutoResponseRule')
                    {
                        tempXml = tempXml +'<autoResponseRule>'+x2js.json2xml_str($.parseJSON(tempJSON))+'</autoResponseRule>';
                    }
                    else if(metaType == 'WorkflowAlert')
                    {
                        tempXml = tempXml +'<alerts>'+x2js.json2xml_str($.parseJSON(tempJSON))+'</alerts>';
                    }
                    else if(metaType == 'WorkflowFieldUpdate')
                    {
                        tempXml = tempXml +'<fieldUpdates>'+x2js.json2xml_str($.parseJSON(tempJSON))+'</fieldUpdates>';
                    }
                    else if(metaType == 'WorkflowOutboundMessage')
                    {
                        tempXml = tempXml +'<outboundMessages>'+x2js.json2xml_str($.parseJSON(tempJSON))+'</outboundMessages>';
                    }
                    else if(metaType == 'WorkflowTask')
                    {
                        tempXml = tempXml +'<tasks>'+x2js.json2xml_str($.parseJSON(tempJSON))+'</tasks>';
                    }
                    else if(metaType == 'WorkflowRule')
                    {
                        tempXml = tempXml +'<rules>'+x2js.json2xml_str($.parseJSON(tempJSON))+'</rules>';
                    }
                    else if(metaType == 'SharingCriteriaRule')
                    {
                        tempXml = tempXml +'<sharingCriteriaRules>'+x2js.json2xml_str($.parseJSON(tempJSON))+'</sharingCriteriaRules>';
                    }
                    else if(metaType == 'SharingOwnerRule')
                    {
                        tempXml = tempXml +'<sharingOwnerRules>'+x2js.json2xml_str($.parseJSON(tempJSON))+'</sharingOwnerRules>';
                    }
                    else if(metaType == 'EscalationRule')
                    {
                        tempXml = tempXml +'<escalationRule>'+x2js.json2xml_str($.parseJSON(tempJSON))+'</escalationRule>';
                    }
                    else if(metaType == 'MatchingRule')
                    {
                        tempXml = tempXml +'<matchingRules>'+x2js.json2xml_str($.parseJSON(tempJSON))+'</matchingRules>';
                    }
                    else if(metaType == 'ManagedTopic')
                    {
                        tempXml = tempXml +'<managedTopic>'+x2js.json2xml_str($.parseJSON(tempJSON))+'</managedTopic>';
                    }
                    else if(metaType == 'BusinessProcess')
                    {
                        tempXml = tempXml +'<businessProcesses>'+x2js.json2xml_str($.parseJSON(tempJSON))+'</businessProcesses>';
                    }
                    else if(metaType == 'SharingReason')
                    {
                        tempXml = tempXml +'<sharingReasons>'+x2js.json2xml_str($.parseJSON(tempJSON))+'</sharingReasons>';
                    }
                    
                    
                    //footer
                    if(metaType == 'CustomLabel')
                    {
                        tempXml = tempXml +'</CustomLabels>';
                    }
                    else if(metaType == 'AssignmentRule' )
                    {
                        tempXml = tempXml +'</AssignmentRules>';
                    }
                    else if(metaType == 'AutoResponseRule')
                    {
                        tempXml = tempXml +'</AutoResponseRules>';
                    }
                    else if(metaType == 'WorkflowAlert' || metaType == 'WorkflowFieldUpdate'|| metaType == 'WorkflowOutboundMessage'|| metaType == 'WorkflowTask' || metaType == 'WorkflowRule')
                    {
                        tempXml = tempXml +'</Workflow>';
                    }
                    else if(metaType == 'SharingCriteriaRule' || metaType == 'SharingOwnerRule')
                    {
                        tempXml = tempXml +'</SharingRules>';
                    }
                    else if(metaType == 'EscalationRule')
                    {
                        tempXml = tempXml +'</EscalationRules>';
                    }
                    else if(metaType == 'MatchingRule')
                    {
                        tempXml = tempXml +'</MatchingRules>';
                    }
                    else if(metaType == 'ManagedTopic')
                    {
                        tempXml = tempXml +'</ManagedTopics>';
                    }
                    else
                    {
                        tempXml = tempXml +'</CustomObject>';
                    }
                    tempXml = unescape(encodeURIComponent(tempXml));
                    childCompMap[metaType+"#"+fullName+""+name]= getCrcWithData(tempXml);
                }
            }
            return childCompMap;
        }
        
        function childSplitter(fullXml,metaType,fileName)
        {
            if(fullXml != undefined)
            {
                var fullName = '';
                if(metaType != 'CustomLabel')
                {
                    fullName = fileName.slice(fileName.indexOf("/")+1,fileName.lastIndexOf('.'))+".";
                }
                var x2js = new X2JS();
                var tgtmap = {};
                var srcjson = x2js.xml_str2json(fullXml);
                if(srcjson != null)
                {
                    var srcitems;
                    if(metaType == 'CustomLabel')
                    {
                        var srcMetaItem = srcjson.CustomLabels;
                        srcitems = srcMetaItem.labels;
                    }
                    else if(metaType == 'CustomField')
                    {
                        var srcMetaItem = srcjson.CustomObject;
                        srcitems = srcMetaItem.fields;
                    }
                    else if(metaType == 'ListView')
                    {
                        var srcMetaItem = srcjson.CustomObject;
                        srcitems = srcMetaItem.listViews;
                    }
                    else if(metaType == 'CompactLayout')
                    {
                        var srcMetaItem = srcjson.CustomObject;
                        srcitems = srcMetaItem.compactLayouts;
                    }
                    else if(metaType == 'WebLink')
                    {
                        var srcMetaItem = srcjson.CustomObject;
                        srcitems = srcMetaItem.webLinks;
                    }
                    else if(metaType == 'RecordType')
                    {
                        var srcMetaItem = srcjson.CustomObject;
                        srcitems = srcMetaItem.recordTypes;
                    }
                    else if(metaType == 'FieldSet')
                    {
                        var srcMetaItem = srcjson.CustomObject;
                        srcitems = srcMetaItem.fieldSets;
                    }
                    else if(metaType == 'ValidationRule')
                    {
                        var srcMetaItem = srcjson.CustomObject;
                        srcitems = srcMetaItem.validationRules;
                    }
                    else if(metaType == 'AssignmentRule')
                    {
                        var srcMetaItem = srcjson.AssignmentRules;
                        srcitems = srcMetaItem.assignmentRule;
                    }
                    else if(metaType == 'AutoResponseRule')
                    {
                        var srcMetaItem = srcjson.AutoResponseRules;
                        srcitems = srcMetaItem.autoResponseRule;
                    }
                    else if(metaType == 'WorkflowTask')
                    {
                        var srcMetaItem = srcjson.Workflow;
                        srcitems = srcMetaItem.tasks;
                    }
                    else if(metaType == 'WorkflowOutboundMessage')
                    {
                        var srcMetaItem = srcjson.Workflow;
                        srcitems = srcMetaItem.outboundMessages;
                    }
                    else if(metaType == 'WorkflowFieldUpdate')
                    {
                        var srcMetaItem = srcjson.Workflow;
                        srcitems = srcMetaItem.fieldUpdates;
                    }
                    else if(metaType == 'WorkflowAlert')
                    {
                        var srcMetaItem = srcjson.Workflow;
                        srcitems = srcMetaItem.alerts;
                    }
                    else if( metaType == 'WorkflowRule')
                    {
                        var srcMetaItem = srcjson.Workflow;
                        srcitems = srcMetaItem.rules;
                    }
                    else if(metaType == 'SharingCriteriaRule')
                    {
                        var srcMetaItem = srcjson.SharingRules;
                        srcitems = srcMetaItem.sharingCriteriaRules;
                    }
                    else if(metaType == 'SharingOwnerRule')
                    {
                        var srcMetaItem = srcjson.SharingRules;
                        srcitems = srcMetaItem.sharingOwnerRules;
                    }
                    else if(metaType == 'BusinessProcess')
                    {
                        var srcMetaItem = srcjson.CustomObject;
                        srcitems = srcMetaItem.businessProcesses;
                    }
                    else if(metaType == 'SharingReason')
                    {
                        var srcMetaItem = srcjson.CustomObject;
                        srcitems = srcMetaItem.sharingReasons;
                    }
                    else if(metaType == 'EscalationRule')
                    {
                        var srcMetaItem = srcjson.EscalationRules;
                        srcitems = srcMetaItem.escalationRule;
                    }
                    else if(metaType == 'MatchingRule')
                    {
                        var srcMetaItem = srcjson.MatchingRules;
                        srcitems = srcMetaItem.matchingRules;
                    }
                    else if(metaType == 'ManagedTopic')
                    {
                        var srcMetaItem = srcjson.ManagedTopics;
                        srcitems = srcMetaItem.ManagedTopic;
                    }
                    if(srcitems != undefined)
                    {
                        if(srcitems.fullName == undefined)
                        {                   
                            $.each(srcitems, function( i, v )
                            {
                                tgtmap[fullName+''+v.fullName] = JSON.stringify(v);
                            });  
                        }
                        else
                        {
                            tgtmap[fullName+''+srcitems.fullName] = JSON.stringify(srcitems);
                        }
                    }
                    if(metadataTypeHeaderMap[metaType] != undefined && metadataTypePreTagMap[metaType]  != undefined && metadataTypePostTagMap[metaType]  != undefined && metadataTypeFooterMap[metaType] != undefined)
                    {
                        for(var itemName in tgtmap)
                        {
                            tempXml = '';

                            //header
                            tempXml = metadataTypeHeaderMap[metaType];
                            //body
                            tempXml += metadataTypePreTagMap[metaType]+''+x2js.json2xml_str($.parseJSON(tgtmap[itemName]))+''+metadataTypePostTagMap[metaType];
                            //footer
                            tempXml += metadataTypeFooterMap[metaType];
                            
                            
                            if(tempXml != '')
                            {
                                patchDataMap[metaType+'#'+itemName] = tempXml;
                            }
                        }
                    }
                }
            }
        }
        
        function childXMLJoin(zipData,newData,metaType,fullName)
        {
            if(metaType != 'CustomLabel')
            {
                fullName = fullName.slice(fullName.lastIndexOf(".")+1,(fullName.length));
            }
            var joinData = ''+zipData;
            if(mmap[metaType] != undefined)
            {
                var fullParentObject = new Object();
                var x2js = new X2JS();
                var tgtmap = {};
                var srcjson = x2js.xml_str2json(newData);
                if(srcjson != null)
                {
                    var srcitems;
                    if(metaType == 'CustomLabel')
                    {
                        var srcMetaItem = srcjson.CustomLabels;
                        srcitems = srcMetaItem.labels;
                    }
                    else if(metaType == 'CustomField')
                    {
                        var srcMetaItem = srcjson.CustomObject;
                        srcitems = srcMetaItem.fields;
                    }
                    else if(metaType == 'ListView')
                    {
                        var srcMetaItem = srcjson.CustomObject;
                        srcitems = srcMetaItem.listViews;
                    }
                    else if(metaType == 'CompactLayout')
                    {
                        var srcMetaItem = srcjson.CustomObject;
                        srcitems = srcMetaItem.compactLayouts;
                    }
                    else if(metaType == 'WebLink')
                    {
                        var srcMetaItem = srcjson.CustomObject;
                        srcitems = srcMetaItem.webLinks;
                    }
                    else if(metaType == 'RecordType')
                    {
                        var srcMetaItem = srcjson.CustomObject;
                        srcitems = srcMetaItem.recordTypes;
                    }
                    else if(metaType == 'FieldSet')
                    {
                        var srcMetaItem = srcjson.CustomObject;
                        srcitems = srcMetaItem.fieldSets;
                    }
                    else if(metaType == 'ValidationRule')
                    {
                        var srcMetaItem = srcjson.CustomObject;
                        srcitems = srcMetaItem.validationRules;
                    }
                    else if(metaType == 'AssignmentRule')
                    {
                        var srcMetaItem = srcjson.AssignmentRules;
                        srcitems = srcMetaItem.assignmentRule;
                    }
                    else if(metaType == 'AutoResponseRule')
                    {
                        var srcMetaItem = srcjson.AutoResponseRules;
                        srcitems = srcMetaItem.autoResponseRule;
                    }
                    else if(metaType == 'WorkflowTask')
                    {
                        var srcMetaItem = srcjson.Workflow;
                        srcitems = srcMetaItem.tasks;
                    }
                    else if(metaType == 'WorkflowOutboundMessage')
                    {
                        var srcMetaItem = srcjson.Workflow;
                        srcitems = srcMetaItem.outboundMessages;
                    }
                    else if(metaType == 'WorkflowFieldUpdate')
                    {
                        var srcMetaItem = srcjson.Workflow;
                        srcitems = srcMetaItem.fieldUpdates;
                    }
                    else if(metaType == 'WorkflowAlert')
                    {
                        var srcMetaItem = srcjson.Workflow;
                        srcitems = srcMetaItem.alerts;
                    }
                    else if( metaType == 'WorkflowRule')
                    {
                        var srcMetaItem = srcjson.Workflow;
                        srcitems = srcMetaItem.rules;
                    }
                    else if(metaType == 'SharingCriteriaRule')
                    {
                        var srcMetaItem = srcjson.SharingRules;
                        srcitems = srcMetaItem.sharingCriteriaRules;
                    }
                    else if(metaType == 'SharingOwnerRule')
                    {
                        var srcMetaItem = srcjson.SharingRules;
                        srcitems = srcMetaItem.sharingOwnerRules;
                    }
                    else if(metaType == 'BusinessProcess')
                    {
                        var srcMetaItem = srcjson.CustomObject;
                        srcitems = srcMetaItem.businessProcesses;
                    }
                    else if(metaType == 'SharingReason')
                    {
                        var srcMetaItem = srcjson.CustomObject;
                        srcitems = srcMetaItem.sharingReasons;
                    }
                    else if(metaType == 'EscalationRule')
                    {
                        var srcMetaItem = srcjson.EscalationRules;
                        srcitems = srcMetaItem.escalationRule;
                    }
                    else if(metaType == 'MatchingRule')
                    {
                        var srcMetaItem = srcjson.MatchingRules;
                        srcitems = srcMetaItem.matchingRules;
                    }
                    else if(metaType == 'ManagedTopic')
                    {
                        var srcMetaItem = srcjson.ManagedTopics;
                        srcitems = srcMetaItem.ManagedTopic;
                    }
                    
                    if(srcitems != undefined)
                    {
                        if(srcitems.fullName == undefined)
                        {                   
                            $.each(srcitems, function( i, v )
                            {
                                tgtmap[v.fullName] = JSON.stringify(v);
                            });  
                        }
                        else
                        {
                            tgtmap[srcitems.fullName] = JSON.stringify(srcitems);
                        }
                    }
                    if(tgtmap[fullName] != undefined)
                    {
                        var oldjson = x2js.xml_str2json(zipData);
                        if(oldjson != undefined)
                        {
                            var srcitems;
                            if(metaType == 'CustomLabel')
                            {
                                var srcMetaItem = oldjson.CustomLabels;
                                srcitems = srcMetaItem.labels;
                            }
                            else if(metaType == 'CustomField')
                            {
                                var srcMetaItem = oldjson.CustomObject;
                                srcitems = srcMetaItem.fields;
                            }
                            else if(metaType == 'ListView')
                            {
                                var srcMetaItem = oldjson.CustomObject;
                                srcitems = srcMetaItem.listViews;
                            }
                            else if(metaType == 'CompactLayout')
                            {
                                var srcMetaItem = oldjson.CustomObject;
                                srcitems = srcMetaItem.compactLayouts;
                            }
                            else if(metaType == 'WebLink')
                            {
                                var srcMetaItem = oldjson.CustomObject;
                                srcitems = srcMetaItem.webLinks;
                            }
                            else if(metaType == 'RecordType')
                            {
                                var srcMetaItem = oldjson.CustomObject;
                                srcitems = srcMetaItem.recordTypes;
                            }
                            else if(metaType == 'FieldSet')
                            {
                                var srcMetaItem = oldjson.CustomObject;
                                srcitems = srcMetaItem.fieldSets;
                            }
                            else if(metaType == 'ValidationRule')
                            {
                                var srcMetaItem = oldjson.CustomObject;
                                srcitems = srcMetaItem.validationRules;
                            }
                            else if(metaType == 'AssignmentRule')
                            {
                                var srcMetaItem = oldjson.AssignmentRules;
                                srcitems = srcMetaItem.assignmentRule;
                            }
                            else if(metaType == 'AutoResponseRule')
                            {
                                var srcMetaItem = oldjson.AutoResponseRules;
                                srcitems = srcMetaItem.autoResponseRule;
                            }
                            else if(metaType == 'WorkflowTask')
                            {
                                var srcMetaItem = oldjson.Workflow;
                                srcitems = srcMetaItem.tasks;
                            }
                            else if(metaType == 'WorkflowOutboundMessage')
                            {
                                var srcMetaItem = oldjson.Workflow;
                                srcitems = srcMetaItem.outboundMessages;
                            }
                            else if(metaType == 'WorkflowFieldUpdate')
                            {
                                var srcMetaItem = oldjson.Workflow;
                                srcitems = srcMetaItem.fieldUpdates;
                            }
                            else if(metaType == 'WorkflowAlert')
                            {
                                var srcMetaItem = oldjson.Workflow;
                                srcitems = srcMetaItem.alerts;
                            }
                            else if( metaType == 'WorkflowRule')
                            {
                                var srcMetaItem = oldjson.Workflow;
                                srcitems = srcMetaItem.rules;
                            }
                            else if(metaType == 'SharingCriteriaRule')
                            {
                                var srcMetaItem = oldjson.SharingRules;
                                srcitems = srcMetaItem.sharingCriteriaRules;
                            }
                            else if(metaType == 'SharingOwnerRule')
                            {
                                var srcMetaItem = oldjson.SharingRules;
                                srcitems = srcMetaItem.sharingOwnerRules;
                            }
                            else if(metaType == 'BusinessProcess')
                            {
                                var srcMetaItem = oldjson.CustomObject;
                                srcitems = srcMetaItem.businessProcesses;
                            }
                            else if(metaType == 'SharingReason')
                            {
                                var srcMetaItem = oldjson.CustomObject;
                                srcitems = srcMetaItem.sharingReasons;
                            }
                            else if(metaType == 'EscalationRule')
                            {
                                var srcMetaItem = oldjson.EscalationRules;
                                srcitems = srcMetaItem.escalationRule;
                            }
                            else if(metaType == 'MatchingRule')
                            {
                                var srcMetaItem = oldjson.MatchingRules;
                                srcitems = srcMetaItem.matchingRules;
                            }
                            else if(metaType == 'ManagedTopic')
                            {
                                var srcMetaItem = oldjson.ManagedTopics;
                                srcitems = srcMetaItem.ManagedTopic;
                            }
                            var preMap = {};
                            if(srcitems != undefined)
                            {
                                if(srcitems.fullName == undefined)
                                {                   
                                    $.each(srcitems, function( i, v )
                                    {
                                        preMap[v.fullName] = JSON.stringify(v);
                                    });  
                                }
                                else
                                {
                                    preMap[srcitems.fullName] = JSON.stringify(srcitems);
                                }
                            }
                            preMap[fullName] = tgtmap[fullName];

                            var updatedJsn = '[';
                            for(var name in preMap)
                            {
                                if(updatedJsn == '[')
                                {
                                    updatedJsn += preMap[name];
                                }
                                else
                                {
                                    updatedJsn+=','+preMap[name];
                                }
                            }
                            updatedJsn+=']';
                            srcitems = JSON.parse(updatedJsn);
                            
                            
                            if(metaType == 'CustomLabel')
                            {
                                srcMetaItem.labels = srcitems;
                                oldjson.CustomLabels = srcMetaItem;
                            }
                            else if(metaType == 'CustomField')
                            {
                                srcMetaItem.fields = srcitems;
                                oldjson.CustomObject = srcMetaItem;
                            }
                            else if(metaType == 'ListView')
                            {
                                srcMetaItem.listViews = srcitems;
                                oldjson.CustomObject = srcMetaItem;
                            }
                            else if(metaType == 'CompactLayout')
                            {
                                srcMetaItem.compactLayouts = srcitems;
                                oldjson.CustomObject = srcMetaItem;
                            }
                            else if(metaType == 'WebLink')
                            {
                                srcMetaItem.webLinks = srcitems;
                                oldjson.CustomObject = srcMetaItem;
                            }
                            else if(metaType == 'RecordType')
                            {
                                srcMetaItem.recordTypes = srcitems;
                                oldjson.CustomObject = srcMetaItem;
                            }
                            else if(metaType == 'FieldSet')
                            {
                                srcMetaItem.fieldSets = srcitems;
                                oldjson.CustomObject = srcMetaItem;
                            }
                            else if(metaType == 'ValidationRule')
                            {   
                                srcMetaItem.validationRules = srcitems;
                                oldjson.CustomObject = srcMetaItem;
                            }
                            else if(metaType == 'AssignmentRule')
                            {       
                                srcMetaItem.assignmentRule = srcitems;
                                oldjson.AssignmentRules = srcMetaItem;
                            }
                            else if(metaType == 'AutoResponseRule')
                            {
                                srcMetaItem.autoResponseRule = srcitems;
                                oldjson.AutoResponseRules = srcMetaItem;
                            }
                            else if(metaType == 'WorkflowTask')
                            {
                                srcMetaItem.tasks = srcitems;
                                oldjson.Workflow = srcMetaItem;
                            }
                            else if(metaType == 'WorkflowOutboundMessage')
                            {
                                srcMetaItem.outboundMessages = srcitems;
                                oldjson.Workflow = srcMetaItem;
                            }
                            else if(metaType == 'WorkflowFieldUpdate')
                            {
                                srcMetaItem.fieldUpdates = srcitems;
                                oldjson.Workflow = srcMetaItem;
                            }
                            else if(metaType == 'WorkflowAlert')
                            {
                                srcMetaItem.alerts = srcitems;
                                oldjson.Workflow = srcMetaItem;
                            }
                            else if(metaType == 'WorkflowRule')
                            {
                                srcMetaItem.rules = srcitems;
                                oldjson.Workflow = srcMetaItem;
                            }
                            else if(metaType == 'SharingCriteriaRule')
                            {
                                srcMetaItem.sharingCriteriaRules = srcitems;
                                oldjson.SharingRules = srcMetaItem;
                            }
                            else if(metaType == 'SharingOwnerRule')
                            {
                                srcMetaItem.sharingOwnerRules = srcitems;
                                oldjson.SharingRules = srcMetaItem;
                            }
                            else if(metaType == 'EscalationRule')
                            {
                                srcMetaItem.escalationRule = srcitems;
                                oldjson.EscalationRules= srcMetaItem;
                            }
                            else if(metaType == 'MatchingRule')
                            {
                                srcMetaItem.matchingRules = srcitems;
                                oldjson.MatchingRules = srcMetaItem;
                            }
                            else if(metaType == 'ManagedTopic')
                            {
                                srcMetaItem.managedTopic = srcitems;
                                oldjson.ManagedTopics = srcMetaItem;
                            }
                            else if(metaType == 'BusinessProcess')
                            {
                                srcMetaItem.businessProcesses = srcitems;
                                oldjson.CustomObject = srcMetaItem;
                            }
                            else if(metaType == 'SharingReason')
                            {
                                srcMetaItem.sharingReasons = srcitems;
                                oldjson.CustomObject = srcMetaItem;
                            }
                            joinData = x2js.json2xml_str(oldjson);
                        }
                    }
                }
            }
            return joinData;
        }
        
        function packageXmlCreator(metaItesList)
        {
            var xml = '<?xml version="1.0" encoding="UTF-8"?><Package xmlns="http://soap.sforce.com/2006/04/metadata">';
            if(metaItesList.length > 0)
            {
                for(var index in metaItesList)
                {
                    if(index < metaItesList.length)
                    {
                        var metaItems = metaItesList[index];
                        var packageXmlLi = metaItems.items;
                        xml = xml + '<types>';
                        for(var index2 in packageXmlLi)
                        {
                            if(index2 < packageXmlLi.length)
                            {
                                xml = xml + '<members>';
                                xml = xml + packageXmlLi[index2].compName;
                                xml = xml + '</members>';
                            }
                        }
                        xml = xml + '<name>'+metaItems.metaType+'</name></types>';
                    }
                }
                xml = xml + '<version>'+apiVersion+'</version></Package>';
            }
            else
                xml = '<?xml version="1.0" encoding="UTF-8"?><Package xmlns="http://soap.sforce.com/2006/04/metadata"><version>'+apiVersion+'</version></Package>';
            return xml;
        }
        
        //to get deployOptions
        function getDeployOptions()
        {
            var deployOption = new Object();
            deployOption.allowMissingFiles=true;
            deployOption.autoUpdatePackage=false;
            deployOption.checkOnly=IsCheckOnly;
            deployOption.ignoreWarnings=false;
            deployOption.performRetrieve=false;
            deployOption.purgeOnDelete=false;
            deployOption.rollbackOnError=true;
            deployOption.singlePackage=true;
            console.log(deployOption);
            return deployOption;
        }
        
        //Validation Profile
        function createValidDATA() {
            var Items = patchItems;
            for(var index in Items)
            {
                if(index < Items.length) {
                    if (ValidName[Items[index].metaType] != undefined && Items[index].items.length > 0) {
                        for(var index2 in Items[index].items) {
                            if(index2 <  Items[index].items.length) {
                                var oldList = ValidName[Items[index].metaType];
                                ValidName[Items[index].metaType].push(Items[index].items[index2].compName);
                            }
                        }
                    }
                }
            }
        }
        
        function validationProfileAndPermissionSet(objectForValidation) {
            var x2js = new X2JS({useDoubleQuotes : true});
            var orignal = x2js.xml_str2json(objectForValidation);
            console.log(x2js.xml_str2json(objectForValidation));
            var ObjectForVal;
            if (orignal.Profile != undefined) {
                ObjectForVal = orignal.Profile;
            }
            else if (orignal.PermissionSet != undefined) {
                ObjectForVal = orignal.PermissionSet;
            }
            if (ObjectForVal != null) {
                //APEX CLASS
                if (ObjectForVal.classAccesses != undefined) {
                    var NewArr =[];
                    var EtallonClasses = ValidName.ApexClass;
                    if(Array.isArray(ObjectForVal.classAccesses))   
                    {
                        for(var index in ObjectForVal.classAccesses) {
                            if (jQuery.inArray(ObjectForVal.classAccesses[index].apexClass, EtallonClasses) !== -1) {
                                NewArr.push(ObjectForVal.classAccesses[index]);
                            }
                        }
                    }
                    else
                    {
                        if (jQuery.inArray(ObjectForVal.classAccesses.apexClass, EtallonClasses) !== -1) {
                            NewArr.push(ObjectForVal.classAccesses);
                        }
                    }
                    if (NewArr.length > 0) {
                        ObjectForVal.classAccesses = NewArr;
                    }
                    else {
                        delete ObjectForVal.classAccesses;
                    }
                }

                //APEX PAGE
                if (ObjectForVal.pageAccesses != undefined) {
                    var NewArr =[];
                    var EtallonPages = ValidName.ApexPage;
                    if(Array.isArray(ObjectForVal.pageAccesses))    
                    {
                        for(var index in ObjectForVal.pageAccesses) {
                            if (jQuery.inArray(ObjectForVal.pageAccesses[index].apexPage, EtallonPages) !== -1) {
                                NewArr.push(ObjectForVal.pageAccesses[index]);
                            }
                        }
                    }
                    else
                    {
                        if (jQuery.inArray(ObjectForVal.pageAccesses.apexPage, EtallonPages) !== -1) {
                            NewArr.push(ObjectForVal.pageAccesses);
                        }
                    }
                    if (NewArr.length > 0) {
                        ObjectForVal.pageAccesses = NewArr;
                    }
                    else {
                        delete ObjectForVal.pageAccesses;
                    }
                }

                //TAB permision
                if (ObjectForVal.tabSettings != undefined && orignal.PermissionSet != undefined) {
                    var NewArr =[];
                    var EtallonTab = ValidName.CustomTab;
                    if(Array.isArray(ObjectForVal.tabSettings)) 
                    {
                        for(var index in ObjectForVal.tabSettings) {
                            if (jQuery.inArray(ObjectForVal.tabSettings[index].tab, EtallonTab) !== -1) {
                                NewArr.push(ObjectForVal.tabSettings[index]);
                            }
                        }
                    }
                    else
                    {
                        if (jQuery.inArray(ObjectForVal.tabSettings.tab, EtallonTab) !== -1) {
                            NewArr.push(ObjectForVal.tabSettings);
                        }
                    }
                    if (NewArr.length > 0) {
                        ObjectForVal.tabSettings = NewArr;
                    }
                    else {
                        delete ObjectForVal.tabSettings;
                    }
                }


                //TAB Profile
                if (ObjectForVal.tabVisibilities != undefined && orignal.Profile != undefined) {
                    var NewArr =[];
                    var EtallonTab = ValidName.CustomTab;
                    if(Array.isArray(ObjectForVal.tabVisibilities)) 
                    {
                        for(var index in ObjectForVal.tabVisibilities) {
                            if (jQuery.inArray(ObjectForVal.tabVisibilities[index].tab, EtallonTab) !== -1) {
                                NewArr.push(ObjectForVal.tabVisibilities[index]);
                            }
                        }
                    }
                    else
                    {
                        if (jQuery.inArray(ObjectForVal.tabVisibilities.tab, EtallonTab) !== -1) {
                            NewArr.push(ObjectForVal.tabVisibilities);
                        }
                    }
                    if (NewArr.length > 0) {
                        ObjectForVal.tabVisibilities = NewArr;
                    }
                    else {
                        delete ObjectForVal.tabVisibilities;
                    }
                }

                //OBJECT
                if (ObjectForVal.objectPermissions != undefined) {
                    var NewArr =[];
                    var EtallonObject = ValidName.CustomObject;
                    console.log(EtallonObject);
                    console.log(ObjectForVal.objectPermissions);
                    if(Array.isArray(ObjectForVal.objectPermissions))   
                    {
                        for(var index in ObjectForVal.objectPermissions) {
                            if (jQuery.inArray(ObjectForVal.objectPermissions[index].object, EtallonObject) !== -1) {
                                NewArr.push(ObjectForVal.objectPermissions[index]);
                            }
                        }
                    }
                    else
                    {
                        if (jQuery.inArray(ObjectForVal.objectPermissions.object, EtallonObject) !== -1) {
                            NewArr.push(ObjectForVal.objectPermissions);
                        }
                    }
                    console.log(NewArr);
                    if (NewArr.length > 0) {
                        ObjectForVal.objectPermissions = NewArr;
                    }
                    else {
                        delete ObjectForVal.objectPermissions;
                    }
                }

                //Layout
                if (ObjectForVal.layoutAssignments != undefined) {
                    var NewArr =[];
                    var EtallonLauout = ValidName.Layout;
                    if(Array.isArray(ObjectForVal.layoutAssignments))   
                    {
                        for(var index in ObjectForVal.layoutAssignments) {
                            if (jQuery.inArray(ObjectForVal.layoutAssignments[index].layout, EtallonLauout) !== -1) {
                                if(ObjectForVal.layoutAssignments[index].recordType != undefined) {
                                    var RecordTypesAvailLi = ValidName.RecordType;
                                    if (jQuery.inArray(ObjectForVal.layoutAssignments[index].recordType, RecordTypesAvailLi) !== -1) {
                                        NewArr.push(ObjectForVal.layoutAssignments[index]);
                                    }
                                }
                                else {
                                    NewArr.push(ObjectForVal.layoutAssignments[index]);
                                }
                            }
                        }
                    }
                    else
                    {
                        if (jQuery.inArray(ObjectForVal.layoutAssignments.layout, EtallonLauout) !== -1) {
                                //NewArr.push(ObjectForVal.layoutAssignments);
                            if(ObjectForVal.layoutAssignments.recordType != undefined) {
                                var RecordTypesAvailLi = ValidName.RecordType;
                                if (jQuery.inArray(ObjectForVal.layoutAssignments.recordType, RecordTypesAvailLi) !== -1) {
                                    NewArr.push(ObjectForVal.layoutAssignments);
                                }
                            }
                            else {
                                NewArr.push(ObjectForVal.layoutAssignments);
                            }
                        }
                    }
                    
                    if (NewArr.length > 0) {
                        ObjectForVal.layoutAssignments = NewArr;
                    }
                    else {
                        delete ObjectForVal.layoutAssignments;
                    }
                }

                //recordType
                if (ObjectForVal.recordTypeVisibilities != undefined) {
                    var NewArr =[];
                    var EtallonObject = ValidName.RecordType;
                    if (EtallonObject.length > 0) {
                        if(Array.isArray(ObjectForVal.recordTypeVisibilities))  
                        {
                            for(var index =0; index < ObjectForVal.recordTypeVisibilities.length; index++) {
                                var RecordTypeName = ObjectForVal.recordTypeVisibilities[index].recordType; 
                                if (jQuery.inArray(RecordTypeName, EtallonObject) !== -1) {
                                    NewArr.push(ObjectForVal.recordTypeVisibilities[index]);
                                }
                            }
                        }
                        else
                        {
                            var RecordTypeName = ObjectForVal.recordTypeVisibilities.recordType;
                            if (jQuery.inArray(RecordTypeName, EtallonObject) !== -1) {
                                NewArr.push(ObjectForVal.recordTypeVisibilities);
                            }
                        }
                    }
                    if (NewArr.length > 0) {
                        ObjectForVal.recordTypeVisibilities = NewArr;
                    }
                    else {
                        delete ObjectForVal.recordTypeVisibilities;
                    }
                }

                //fieldPermissions
                if (ObjectForVal.fieldPermissions != undefined) {
                    var NewArr =[];
                    var EtallonObject = ValidName.CustomField;
                    if (EtallonObject.length > 0) {
                        if(Array.isArray(ObjectForVal.fieldPermissions))    
                        {
                            for(var index =0; index < ObjectForVal.fieldPermissions.length; index++) {
                                var fieldName = ObjectForVal.fieldPermissions[index].field;
                                if (jQuery.inArray(fieldName, EtallonObject) !== -1) {
                                    NewArr.push(ObjectForVal.fieldPermissions[index]);
                                }
                            }
                        }
                        else
                        {
                            var fieldName = ObjectForVal.fieldPermissions.field;
                            if (jQuery.inArray(fieldName, EtallonObject) !== -1) {
                                NewArr.push(ObjectForVal.fieldPermissions);
                            }
                        }
                    }
                    if (NewArr.length > 0) {
                        ObjectForVal.fieldPermissions = NewArr;
                    }
                    else {
                        delete ObjectForVal.fieldPermissions;
                    }
                }
                
                //applicationVisibilities
                if (ObjectForVal.applicationVisibilities != undefined) {
                    var NewArr =[];
                    var EtallonPages = ValidName.CustomApplication;
                    if(Array.isArray(ObjectForVal.applicationVisibilities)) 
                    {
                        for(var index in ObjectForVal.applicationVisibilities) {
                            if (jQuery.inArray(ObjectForVal.applicationVisibilities[index].application, EtallonPages) !== -1) {
                                NewArr.push(ObjectForVal.applicationVisibilities[index]);
                            }
                        }
                    }
                    else
                    {
                        if (jQuery.inArray(ObjectForVal.applicationVisibilities.application, EtallonPages) !== -1) {
                            NewArr.push(ObjectForVal.applicationVisibilities);
                        }
                    }
                    
                    if (NewArr.length > 0) {
                        ObjectForVal.applicationVisibilities = NewArr;
                    }
                    else {
                        delete ObjectForVal.applicationVisibilities;
                    }
                }
                
                //externalDataSourceAccesses
                if (ObjectForVal.externalDataSourceAccesses != undefined) {
                    var NewArr =[];
                    var EtallonPages = ValidName.ExternalDataSource;
                    if(Array.isArray(ObjectForVal.externalDataSourceAccesses))  {
                        for(var index in ObjectForVal.externalDataSourceAccesses) {
                            if (jQuery.inArray(ObjectForVal.externalDataSourceAccesses[index].externalDataSource, EtallonPages) !== -1) {
                                NewArr.push(ObjectForVal.externalDataSourceAccesses[index]);
                            }
                        }
                    }
                    else {
                        if (jQuery.inArray(ObjectForVal.externalDataSourceAccesses.externalDataSource, EtallonPages) !== -1) {
                            NewArr.push(ObjectForVal.externalDataSourceAccesses);
                        }
                    }
                    if (NewArr.length > 0) {
                        ObjectForVal.externalDataSourceAccesses = NewArr;
                    }
                    else {
                        delete ObjectForVal.externalDataSourceAccesses;
                    }
                }
                
                //customPermissions
                if (ObjectForVal.customPermissions != undefined) {
                    var NewArr =[];
                    var EtallonPages = ValidName.CustomPermission;
                    if(Array.isArray(ObjectForVal.customPermissions))   
                    {
                        for(var index in ObjectForVal.customPermissions) {
                            if (jQuery.inArray(ObjectForVal.customPermissions[index].name, EtallonPages) !== -1) {
                                NewArr.push(ObjectForVal.customPermissions[index]);
                            }
                        }
                    }
                    else
                    {
                        if (jQuery.inArray(ObjectForVal.customPermissions.name, EtallonPages) !== -1) {
                            NewArr.push(ObjectForVal.customPermissions);
                        }
                    }
                    if (NewArr.length > 0) {
                        ObjectForVal.customPermissions = NewArr;
                    }
                    else {
                        delete ObjectForVal.customPermissions;
                    }
                }
            }

            if (orignal.Profile != undefined && ObjectForVal != null) {
                 orignal.Profile = ObjectForVal;
            }
            else if (orignal.PermissionSet != undefined && ObjectForVal != null) {
                orignal.PermissionSet = ObjectForVal;
            }
            var returnXML = x2js.json2xml_str(orignal);
            console.log(orignal);
            return returnXML;
        }
        
        function showErrorMessage(str)
        {
            if($('#msg') != undefined)
            {
                $('#msg').remove();
            }
            var parentVal = $("[id$='msg']");
            if(parentVal != undefined)
            {
                var childVal = '<span id="msg">'+
                                '<span>'+
                                    '<div class="message errorM3" role="alert">'+
                                        '<table border="0" cellpadding="0" cellspacing="0" class="messageTable" style="padding:0px;margin:0px;">'+
                                            '<tbody>'+
                                                '<tr valign="top">'+
                                                '<td>'+
                                                    '<img alt="ERROR" class="msgIcon" src="/s.gif" title="ERROR">'+
                                                '</td>'+
                                                '<td class="messageCell">'+
                                                    '<div class="messageText">'+
                                                        '<span style="color:#cc0000">'+
                                                            '<h4>Error:</h4>'+
                                                        '</span>'+
                                                        str+'<br>'+
                                                    '</div>'+
                                                '</td>'+
                                                '</tr>'+
                                                '<tr>'+
                                                    '<td></td>'+
                                                    '<td></td>'+
                                                '</tr>'+
                                            '</tbody>'+
                                        '</table>'+
                                    '</div>'+
                                '</span>'+
                            '</span>';
                parentVal.before(childVal);
            }
            unbindWindow();
        }
        
        function stringToBase64Encode(str)
        {
            return window.btoa(unescape(encodeURIComponent(str)));
        }
        
        function bindWindow()
        {
            $(window).bind("beforeunload", function() { 
                return "Deployment may be in progress.";
            });
            
        }
        
        function unbindWindow()
        {
            $(window).unbind();
        }

        function deleteMainTag(xmlFile) {
            var tempXml = xmlFile;
            
            if (tempXml.lastIndexOf('</') != -1) {
                var position = tempXml.lastIndexOf('</');
                var position2 = tempXml.lastIndexOf('>');
                closeMainTag = tempXml.substr(position+2, position2 - position - 2);

                openMainTag = '<' + closeMainTag;
                closeMainTag = '</' + closeMainTag + '>';
                //console.log('closeMainTag = ' + closeMainTag);

                //openMainTag = '<' + closeMainTag.substr(2, closeMainTag.length - 3);
                //console.log('openMainTag = ' + openMainTag);

                var tempXml2 = '';
                if (tempXml.indexOf(openMainTag) != -1) {
                    position = tempXml.indexOf(openMainTag);
                    tempXml2 = tempXml.substr(position);

                    position = tempXml2.indexOf('>');
                    openMainTag = tempXml2.substr(0, position + 1);

                    position = tempXml.indexOf(openMainTag);
                    position2 = tempXml.lastIndexOf(closeMainTag);

                    beforOpenMainTag = tempXml.substr(0, position);
                    betweenMainTag = tempXml.substr(position + openMainTag.length, position2 - position - openMainTag.length);
                    //console.log('beforOpenMainTag = ' + beforOpenMainTag);
                    //console.log('openMainTag = ' + openMainTag);
                    //console.log('betweenMainTag = ' + betweenMainTag);
                }
            }
        }

        function formatXmlDeleteTitle(xml) {
            var result = xml;
            if (result.indexOf('>') != -1) {
                result = result.substr(result.indexOf('>')+1);
            }
            if (result.indexOf('<') != -1) {
                result = result.substr(result.indexOf('<'));
            }
            //console.log('II>>>>>result\n\n'+result);

            return result;
        }

        function formatXmlParse(xml, newXml) {
            var tempXml = xml;
            var resultXml = newXml;
            if (tempXml.indexOf('<0>') != -1) {
                var position = tempXml.indexOf('<0>');
                var startStr = tempXml.substr(0, position);

                //console.log('position = ' + position);
                //console.log('startStr = ' + startStr);

                var startMainTag = -1;
                var endMainTag = -1;
                if (startStr.lastIndexOf('<') != -1) {
                    startMainTag = startStr.lastIndexOf('<');
                }
                if (startStr.lastIndexOf('>') != -1) {
                    endMainTag = startStr.lastIndexOf('>');
                }
                
                var mainTag = '';
                var mainTagClose = '';
                //console.log('startMainTag = ' + startMainTag);
                //console.log('endMainTag = ' + endMainTag);
                if (startMainTag != -1 && endMainTag != -1) {
                    mainTag = startStr.substr(startMainTag, endMainTag - startMainTag + 1);
                    mainTagClose = '</' + mainTag.substr(1);
                }

                //console.log('mainTag = ' + mainTag);
                //console.log('mainTagClose = ' + mainTagClose);

                var bodyMainTag = '';
                // if (tempXml.lastIndexOf(mainTag) != -1 && tempXml.lastIndexOf(mainTagClose) != -1) {
                //     startMainTag = tempXml.lastIndexOf(mainTag);
                //     endMainTag = tempXml.lastIndexOf(mainTagClose);
                //     console.log('startMainTag = ' + startMainTag);
                //     console.log('endMainTag = ' + endMainTag);
                //     console.log(endMainTag - startMainTag + mainTagClose.length);
                //     bodyMainTag = tempXml.substr(startMainTag, endMainTag - startMainTag + mainTagClose.length);
                // }
                if (tempXml.indexOf(mainTag) != -1 && tempXml.indexOf(mainTagClose) != -1) {
                    startMainTag = tempXml.indexOf(mainTag);
                    endMainTag = tempXml.indexOf(mainTagClose);
                    //console.log('startMainTag = ' + startMainTag);
                    //console.log('endMainTag = ' + endMainTag);
                    //console.log(endMainTag - startMainTag + mainTagClose.length);
                    bodyMainTag = tempXml.substr(startMainTag, endMainTag - startMainTag + mainTagClose.length);
                }

                //console.log('bodyMainTag = ' + bodyMainTag);
                bodyMainTag = parseBodyArr(mainTag, mainTagClose, bodyMainTag);
                //console.log('bodyMainTag = ' + bodyMainTag);
                
                //console.log('startMainTag = ' + startMainTag);
                //console.log('endMainTag = ' + endMainTag);
                //console.log('tempXml.length = ' + tempXml.length);

                resultXml += tempXml.substr(0, startMainTag) + bodyMainTag;
                tempXml = tempXml.substr(endMainTag + mainTagClose.length);

                //console.log('mainTag = ' + mainTag);
                //console.log('mainTagClose = ' + mainTagClose);
                //console.log('resultXml = ' + resultXml);
                //console.log('tempXml = ' + tempXml);

                resultXml = formatXmlParse(tempXml, resultXml);
            }
            else {
                resultXml += tempXml;
            }

            return resultXml;
        }

        function parseBodyArr(mainTag, mainTagClose, bodyMainTag) {
            //console.log('bodyMainTag.length - mainTag.length - mainTag.length = ' + (bodyMainTag.length - mainTag.length - mainTag.length));
            var tempBody = bodyMainTag.substr(mainTag.length, bodyMainTag.length - mainTag.length - mainTag.length - 1);
            var result = '';
            //console.log('tempBody = ' + tempBody);

            var startLastTag = -1;
            var endLastTag = -1;
            var lastTag = '';
            if (tempBody.lastIndexOf('</') != -1) {
                startLastTag = tempBody.lastIndexOf('</');
            }
            if (tempBody.lastIndexOf('>') != -1) {
                endLastTag = tempBody.lastIndexOf('>');
            }
            if (startLastTag != -1 && endLastTag != -1) {
                lastTag = tempBody.substr(startLastTag + 2, endLastTag - startLastTag - 2);
            }
            //console.log('lastTag = ' + lastTag);

            for (var i = 0; i <= Number(lastTag); i++) {
                if (tempBody.indexOf('<' + i.toString() + '>') != -1) {
                    var startIndexTag = -1;
                    var endIndexTag = -1;
                    var strIndexBody = '';
                    //var strIndexTag = '';
                    var indexTag = '';
                    if (tempBody.indexOf('<' + i.toString() + '>') != -1) {
                        startIndexTag = tempBody.indexOf('<' + i.toString() + '>');
                    }
                    if (tempBody.indexOf('</' + i.toString() + '>') != -1) {
                        endIndexTag = tempBody.indexOf('</' + i.toString() + '>');
                    }

                    //console.log('startIndexTag = ' + startIndexTag);
                    //console.log('endIndexTag = ' + endIndexTag);

                    //var strStartTag = '<' + i.toString() + '>';
                    //var strEndTag = '<' + i.toString() + '>';
                    if (startIndexTag != -1 && endIndexTag != -1) {
                        strIndexBody = tempBody.substr(startIndexTag + (i.toString().length + 2), endIndexTag - startIndexTag - (i.toString().length + 2));
                        //tempBody = tempBody.substr(endIndexTag + (i.toString().length +3));
                        //indexTag = tempBody.substr(startIndexTag + 2, endIndexTag - startIndexTag - 1);
                    }
                    //console.log(i.toString() + ' - strIndexBody = ' + strIndexBody);
                    //console.log('tempBody = ' + tempBody);

                    //////////////*************
                    var newBody = '';
                    if (strIndexBody.indexOf('<0>') != -1) {
                        //newBody = strIndexBody.substr(strIndexBody.indexOf('<' + i.toString() + '>'), strIndexBody.indexOf('<0>'));
                        newBody = strIndexBody.substr(0, strIndexBody.indexOf('<0>'));
                        console.log('newBody = ' + newBody);

                        var newStartMainTag = -1;
                        var newEndMainTag = -1;
                        if (newBody.lastIndexOf('<') != -1) {
                            newStartMainTag = newBody.lastIndexOf('<');
                        }
                        if (newBody.lastIndexOf('>') != -1) {
                            newEndMainTag = newBody.lastIndexOf('>');
                        }
                        
                        var newMainTag = '';
                        var newMainTagClose = '';
                        //console.log('newStartMainTag = ' + newStartMainTag);
                        //console.log('newEndMainTag = ' + newEndMainTag);
                        if (newStartMainTag != -1 && newEndMainTag != -1) {
                            newMainTag = newBody.substr(newStartMainTag, newEndMainTag - newStartMainTag + 1);
                            newMainTagClose = '</' + newMainTag.substr(1);
                        }

                        if (i == 0) {
                            var tempBody1 = tempBody.substr(0, tempBody.indexOf(newMainTag));
                            var tempBody2 = tempBody.substr(tempBody.indexOf(newMainTag), tempBody.indexOf(newMainTagClose) - tempBody.indexOf(newMainTag) + newMainTagClose.length);
                            var tempBody3 = tempBody.substr(tempBody.indexOf(newMainTagClose) + newMainTagClose.length);
                            //console.log('tempBody1 = ' + tempBody1);
                            //console.log('tempBody2 = ' + tempBody2);
                            //console.log('tempBody3 = ' + tempBody3);

                            tempBody2 = formatXmlParse(tempBody2, '');
                            //console.log('tempBody2 = ' + tempBody2);

                            tempBody = tempBody1 + tempBody2 + tempBody3;
                        }
                        else {
                            var tempBody00 = tempBody.substr(0, tempBody.indexOf('<' + i.toString() + '>') + ('<' + i.toString() + '>').length);
                            var tempBodyLast = tempBody.substr(tempBody.indexOf('<' + i.toString() + '>') + ('<' + i.toString() + '>').length);
                            var tempBody11 = tempBodyLast.substr(0, tempBodyLast.indexOf(newMainTag));
                            var tempBody22 = tempBodyLast.substr(tempBodyLast.indexOf(newMainTag), tempBodyLast.indexOf(newMainTagClose) - tempBodyLast.indexOf(newMainTag) + newMainTagClose.length);
                            var tempBody33 = tempBodyLast.substr(tempBodyLast.indexOf(newMainTagClose) + newMainTagClose.length);
                            //console.log('tempBody11 = ' + tempBody11);
                            //console.log('tempBody22 = ' + tempBody22);
                            //console.log('tempBody33 = ' + tempBody33);

                            tempBody22 = formatXmlParse(tempBody22, '');
                            //console.log('tempBody22 = ' + tempBody22);

                            tempBody = tempBody00 + tempBody11 + tempBody22 + tempBody33;
                        }

                        
                        
                        //strIndexBody = formatXmlParse(strIndexBody, '');
                        var newStartIndexTag = -1;
                        var newEndIndexTag = -1;
                        strIndexBody = '';
                        //var strIndexTag = '';
                        var indexTag = '';
                        if (tempBody.indexOf('<' + i.toString() + '>') != -1) {
                            newStartIndexTag = tempBody.indexOf('<' + i.toString() + '>');
                        }
                        if (tempBody.indexOf('</' + i.toString() + '>') != -1) {
                            newEndIndexTag = tempBody.indexOf('</' + i.toString() + '>');
                        }

                        //console.log('newStartIndexTag = ' + newStartIndexTag);
                        //console.log('newEndIndexTag = ' + newEndIndexTag);

                        //var strStartTag = '<' + i.toString() + '>';
                        //var strEndTag = '<' + i.toString() + '>';
                        if (newStartIndexTag != -1 && newEndIndexTag != -1) {
                            strIndexBody = tempBody.substr(newStartIndexTag + (i.toString().length + 2), newEndIndexTag - newStartIndexTag - (i.toString().length + 2));
                            //tempBody = tempBody.substr(newEndIndexTag + (i.toString().length +3));
                            //indexTag = tempBody.substr(newStartIndexTag + 2, newEndIndexTag - newStartIndexTag - 1);
                        }
                        //console.log('strIndexBody = ' + strIndexBody);
                        //console.log('tempBody = ' + tempBody);

                        strIndexBody = formatXmlParse(strIndexBody, '');
                    }
                    //////////////*************

                    /**************************************************/
                    //var strIndexBody = '<fullName>Needs Analysis</fullName><default>false</default>';
                    var notEmptyTags = 0
                    var arrIndexBody = strIndexBody.split('</') ;
                    if (arrIndexBody.length > 1) {
                        for (k = 0; k < arrIndexBody.length; k++) {
                            lastChar = arrIndexBody[k].substr(arrIndexBody[k].length - 1);
                            if (lastChar != '>') {
                                notEmptyTags = 1;
                            }
                        }
                    }
                    else {
                        notEmptyTags = 1;
                    }
                    //console.log('notEmptyTags = ' + notEmptyTags);
                    /**************************************************/

                    if (notEmptyTags == 1) {
                        if (strIndexBody.indexOf('<0>') != -1) {
                            strIndexBody = formatXmlParse(strIndexBody, '');
                        }
                        result += mainTag + strIndexBody + mainTagClose;
                    }
                }
            }
            //console.log('result = ' + result);

            //tempBody = tempBody.replace(/<[0-9]*[0-9]*[0-9]>/g, mainTag);
            //tempBody = tempBody.replace(/<\/[0-9]*[0-9]*[0-9]>/g, mainTagClose);
            //return tempBody;

            return result;
        }

        function formatXml(xml) {
            var reg = /(>)(<)(\/*)/g;
            var wsexp = / *(.*) +\n/g;
            var contexp = /(<.+>)(.+\n)/g;
            xml = xml.replace(reg, '$1\n$2$3').replace(wsexp, '$1\n').replace(contexp, '$1\n$2');
            var pad = 0;
            var formatted = '';
            var lines = xml.split('\n');
            var indent = 0;
            var lastType = 'other';
            // 4 types of tags - single, closing, opening, other (text, doctype, comment) - 4*4 = 16 transitions 
            var transitions = {
                'single->single'    : 0,
                'single->closing'   : -1,
                'single->opening'   : 0,
                'single->other'     : 0,
                'closing->single'   : 0,
                'closing->closing'  : -1,
                'closing->opening'  : 0,
                'closing->other'    : 0,
                'opening->single'   : 1,
                'opening->closing'  : 0, 
                'opening->opening'  : 1,
                'opening->other'    : 1,
                'other->single'     : 0,
                'other->closing'    : -1,
                'other->opening'    : 0,
                'other->other'      : 0
            };

            for (var i=0; i < lines.length; i++) {
                var ln = lines[i];
                var single = Boolean(ln.match(/<.+\/>/)); // is this line a single tag? ex. <br />
                var closing = Boolean(ln.match(/<\/.+>/)); // is this a closing tag? ex. </a>
                var opening = Boolean(ln.match(/<[^!].*>/)); // is this even a tag (that's not <!something>)
                var type = single ? 'single' : closing ? 'closing' : opening ? 'opening' : 'other';
                var fromTo = lastType + '->' + type;
                lastType = type;
                var padding = '';

                indent += transitions[fromTo];
                for (var j = 0; j < indent; j++) {
                    padding += '\t';
                }

                formatted += padding + ln + '\n';
            }

            var str = formatted;
            var lastPosition=0;
            var positions = [];
            for(var i=0; i<str.length; i++) {
                if (str[i] == '<' && str[i+1]=='/') {
                    //console.log('1-'+i);
                    lastPosition = i-1;
                    var temp = {};
                    temp.b = i-1;
            
                    for(i; i>0; i--) {
                        if(str[i] == '>') {
                            temp.a = i+1;
                            positions.push(temp);
                            i = lastPosition+1;
                            //console.log(positions);
                            break;
                        }
                    }
                }
            }

            var result = '';
            for (var k=0; k<positions.length; k++) {
                if (k==0) {
                    result = str.substr(0, positions[k].a);
                    //console.log(result);
                }
                var strAB = str.substr(positions[k].a, positions[k].b - positions[k].a + 1);
                if (k == positions.length-1) {
                    var strBz = str.substr(positions[k].b + 1);
                    //console.log('\''+strBz+'\'');
                }
                else {
                    var strBz = str.substr(positions[k].b + 1, positions[k+1].a - positions[k].b-1);
                    //console.log('\''+strBz+'\'');
                }
                // var tempStr = strAB.match(/[\wа-яё]+/gi);
            
                if (strAB.match(/[\wа-яё]+/gi) != null) {
                    strAB = strAB.replace(/\t/ig, '');
                    strAB = strAB.replace(/\n/ig, '');
                }
              
                result += strAB;
                result += strBz;
                //console.log('\''+strAB+'\'');
                //console.log(result);
            }

            if (result != '') {
                formatted = result;
            }

            return formatted;
        };

        function formatXmldeleteEmptyTag(resStr, xml) {
            var tempXml = xml;
            var resultXml = resStr;
            if (tempXml.indexOf('</') != -1) {
                var position = tempXml.indexOf('</');
                var tempStrForCloseTag = tempXml.substr(position);
                var closeTag = '';
                var openTag = '';
                if (tempStrForCloseTag.indexOf('>') != -1) {
                    position = tempStrForCloseTag.indexOf('>');
                    closeTag = tempStrForCloseTag.substr(0, position + 1);
                    openTag = '<' + closeTag.substr(2, closeTag.length - 2);
                }
                
                var bodyTags = '';
                var position1 = -1;
                var position2 = -1;
                
                if (tempXml.indexOf(openTag) != -1 && tempXml.indexOf(closeTag) != -1) {
                    position1 = tempXml.indexOf(openTag);
                    position2 = tempXml.indexOf(closeTag);
                    if (position2 > position1) {
                        bodyTags = tempXml.substr(position1 + openTag.length, position2 - position1 - closeTag.length + 1);
                    }
                }
                
                var strStart = '';
                var strEnd = '';
                
                if (tempXml.indexOf(openTag) < 0 || position2 < position1) {
                    position2 = tempXml.indexOf(closeTag);
                    strStart = tempXml.substr(0, position2 + closeTag.length);
                    strEnd = tempXml.substr(position2 + closeTag.length);
                }
                
                if (bodyTags != '') {
                    if (bodyTags.match(/[\wа-яё]+/gi) != null) {
                        strStart = tempXml.substr(0, position2 + closeTag.length);
                        strEnd = tempXml.substr(position2 + closeTag.length);
                    }
                    else {
                        var strStart = tempXml.substr(0, position1);
                        var lastTagPosition = strStart.lastIndexOf('>');
                        strStart = strStart.substr(0, lastTagPosition);
                        var strEnd = tempXml.substr(position2 + closeTag.length);
                    }
                }
                
                resultXml += strStart;
                
                resultXml = formatXmldeleteEmptyTag(resultXml, strEnd);
            }
            else {
                resultXml += tempXml;
            }

            return resultXml;
        };

        var objectcollectionTemplate = '<div ng-style="getColor()">'+
                                            '<span ng-if="isObject">'+
                                                 '<table style="border:1px solid black;">'+
                                                    '<tbody >'+
                                                        //'<tr ng-repeat="(key, member) in object">'+
                                                        '<tr ng-repeat="(key, member) in object track by $index">'+

                                                            '<td style="height: 28px; border-top: 1px solid #9C9C9C; border-bottom: 1px solid #9C9C9C; border-left: 1px solid #9C9C9C; border-right: 1px solid #9C9C9C">'+
                                                                /*'<strong>{} {{key}} {{memberInfo(member)}}</strong>'+*/
                                                                '<strong>{{key.trunc(15)}} {{memberInfo(member)}}</strong>'+
                                                            '</td>'+
                                                            '<td style="border-top: 1px solid #9C9C9C; border-bottom: 1px solid #9C9C9C; border-left: 1px solid #9C9C9C; border-right: 1px solid #9C9C9C">'+
                                                                '<member  member="member" setinfo="setinfo"></member>'+
                                                            '</td>'+
                                                        '</tr>'+
                                                    '</tbody>'+
                                                '</table>'+
                                            '</span>'+
                                            '<span ng-if="isValue">'+
                                                '<span ng-if="object.DiffType == VALUE_UNCHANGED">{{object.NewData}}</span>' + 
                                                '<span ng-if="object.DiffType != VALUE_UNCHANGED && IsBase"  style="background-color:#717ECD; color:#F0F1F2;">{{object.OldData}}</span>' + 
                                                '<span ng-if="object.DiffType != VALUE_UNCHANGED && !IsBase"  style="background-color:#4EB1CB; color:#F0F1F2;">{{object.DiffViewValue}}</span>' +
                                                '<span ng-if="object.DiffType != VALUE_UNCHANGED && IsBase && object.DiffType != VALUE_CREATED && !object.DiffAction"  class="iconnDiff glyphicon glyphicon-triangle-right" style="top: 0px;margin-left: 2px;"  ng-click="edit(object, true)"></span>'+
                                                '<span ng-if="object.DiffType != VALUE_UNCHANGED && IsBase && object.DiffType != VALUE_CREATED && object.DiffAction"  class="iconnDiff glyphicon glyphicon-triangle-left" style="top: 0px;margin-left: 2px;"  ng-click="edit(object, true)"></span>'+
                                                '<span ng-if="object.DiffType != VALUE_UNCHANGED && !IsBase && object.DiffType != VALUE_DELETED && !object.DiffAction"  class="iconnDiff glyphicon glyphicon-triangle-left" style="top: 0px;margin-left: 2px;"  ng-click="edit(object, false)"></span>'+
                                                '<span ng-if="object.DiffType != VALUE_UNCHANGED && !IsBase && object.DiffType != VALUE_DELETED && object.DiffAction"  class="iconnDiff glyphicon glyphicon-triangle-right" style="top: 0px;margin-left: 2px;"  ng-click="edit(object, false)"></span>'+
                                            '</span>'+
                                            '<span ng-if="isArray">'+
                                                 '<span ng-if="IsArrayText">'+
                                                    '<table style="border:1px solid black;">'+
                                                        '<tbody >'+
                                                            '<tr style="background-color: #FBFFB7;">'+
                                                                '<td>'+
                                                                '</td>'+
                                                                '<td><strong>Text</strong>'+
                                                                '</td>'+
                                                            '</tr>'+
                                                            '<tr ng-repeat="(key, member) in object">'+
                                                                '<td style="background-color: #FBFFB7;">'+
                                                                    '<strong>{{key}}</strong>'+
                                                                '</td>'+
                                                                '<td>'+
                                                                    '<member  member="member" setinfo="setinfo"></member>'+
                                                                '</td>'+
                                                            '</tr>'+
                                                        '</tbody>'+
                                                    '</table>'+
                                                 '</span>'+
                                                 '<span ng-if="!IsArrayText">'+
                                                    '<table style="border:1px solid black;">'+
                                                        '<tbody >'+
                                                            '<tr style="background-color: #FBFFB7;">'+
                                                                '<td ng-repeat="keyQ in keys"><strong>{{keyQ}}</strong>'+
                                                                '</td>'+
                                                            '</tr>'+
                                                            '<tr ng-repeat="(key, member) in object">'+
                                                                '<td ng-repeat="keyQ in keys" ng-style="CheckStyle(keyQ)" class="contColor">'+
                                                                    '<span  ng-if="!CheckKey(keyQ)">'+
                                                                        '<strong>{{key}}</strong>'+
                                                                     '</span>'+
                                                                     '<span ng-if="CheckKey(keyQ)">'+
                                                                        '<member  member="member[keyQ]" setinfo="setinfo"></member>'+
                                                                     '</span>'+
                                                                '</td>'+
                                                                
                                                            '</tr>'+
                                                        '</tbody>'+
                                                    '</table>'+
                                                 '</span>'+
                                            '</span>'+
                                        '</div>';
        
        var myApp = angular.module("remoteRepository", ['ngDialog', 'base64']);
        
        myApp.directive('objectcollection', function ($compile) {
            return {
                restrict: "E",
                //replace: true,
                scope: {
                    object: '=',
                    setinfo: '='
                },
                template:   objectcollectionTemplate,
                link: function (scope, element, attrs) {
                    var el = $(element);
                    var cont = el.parents(".contColor");
                    var colorCont = null;
                    if (cont.length > 0) {
                        colorCont = $(cont[0]);
                    }
                    var inf = el.parents("#BASE");
                    scope.IsBase = false;
                    if (inf.length > 0) {
                        scope.IsBase = true;
                    }
                    scope.VALUE_CREATED= 'created';
                    scope.VALUE_UPDATED= 'updated';
                    scope.VALUE_DELETED= 'deleted';
                    scope.VALUE_UNCHANGED= 'unchanged';
                    scope.isObject = false;
                    scope.isArray = false;
                    scope.isValue = false;
                    
                    
                    scope.getColor = function() {
                        if (scope.isValue) {
                        }
                        else if (!scope.isArray && !scope.isObject) {
                            //colorCont.css('background-color','#CECCCC');
                        }
                        return {};
                    }
                    scope.memberInfo = function(mm) {
                        if (angular.isObject(mm) && mm.DiffType == null) {
                            var checkMassive = true;
                            var index = 0;
                            for (var key in mm) {
                                if (!angular.isNumber(parseInt(key)) || isNaN(parseInt(key))) {
                                    checkMassive = false;
                                }
                                else {
                                    index ++;
                                }
                            }
                            if (checkMassive) {
                                return '(' + index + ')';
                            }
                            
                        }
                        return '';
                    }
                    scope.edit = function(obj, check) {
                        console.log(obj);
                        if (check) {
                            if (obj.DiffAction) {
                                obj.DiffViewValue = obj.NewData;
                                obj.DiffAction = false;
                            }
                            else {
                                obj.DiffViewValue = obj.OldData;
                                obj.DiffAction = true;
                            }
                            
                        }
                        else {
                            if (obj.DiffAction) {
                                obj.DiffViewValue = obj.NewData;
                                obj.DiffAction = false;
                            }
                            else {
                                obj.DiffViewValue = obj.OldData;
                                obj.DiffAction = true;
                            }
                            
                        }
                        scope.setinfo();
                    }
                    if (angular.isObject(scope.object) && scope.object.DiffType == null) {
                        var checkMassive = true;
                        for (var key in scope.object) {
                            if (!angular.isNumber(parseInt(key)) || isNaN(parseInt(key))) {
                                checkMassive = false;
                            }
                        }
                        if (checkMassive) {
                            scope.isArray = true;
                        }
                        else {
                            scope.isObject = true;
                        }
                    }
                    else if (angular.isArray(scope.object) ) {
                        scope.isArray = true;
                    }
                    else if (typeof scope.object != "undefined"){
                        scope.isValue = true;
                    }
                    scope.keys =[];
                    scope.keys.push('');
                    scope.IsArrayText = true;
                    scope.CheckKey = function(param) {
                        if (param == '') {
                            return false;
                        }
                        else {
                            return true;
                        }
                    }
                    scope.CheckStyle = function(param) {
                        if (param == '') {
                            return {'background-color': '#FBFFB7'};
                        }
                        else {
                            return {};
                        }
                    }
                    
                    if (scope.isArray) {
                        for (var key in scope.object) {
                            var obj = scope.object[key];
                            if (angular.isObject(obj) && obj.DiffType == null) {
                                scope.IsArrayText = false;
                                for (var key in obj) {
                                    if ($.inArray( key, scope.keys)  == -1 && key != '$$hashKey') {
                                        scope.keys.push(key);
                                    }
                                }
                            }
                        }
                        
                    }
                    
                    
                    
                }
            }
        });

        myApp.directive('member', function ($compile) {
            return {
                restrict: "E",
                scope: {
                    member: '=',
                    setinfo: '='
                },
                template:   '<div></div>',
                link: function (scope, element, attrs) {
                    scope.VALUE_CREATED= 'created';
                    scope.VALUE_UPDATED= 'updated';
                    scope.VALUE_DELETED= 'deleted';
                    scope.VALUE_UNCHANGED= 'unchanged';
                    
                    
                    scope.memberNew;
                    var IsObject = false;
                    if (angular.isArray(scope.member)) {
                        scope.memberNew = [];
                    }
                    else if (angular.isObject(scope.member)) {
                        scope.memberNew = {};
                    }

                    if ((angular.isArray(scope.member) || angular.isObject(scope.member)) && scope.member.DiffType == null) {
                        var IsAdd = false;
                        for (var key in scope.member) {
                            var Obj  = scope.member[key];
                            if (Obj.DiffType != null && Obj.DiffType != this.VALUE_UNCHANGED) {
                                scope.memberNew[key] = Obj;
                                IsAdd = true;
                            }
                            else {
                                var check1 = checkView(Obj);
                                if (check1) {
                                    scope.memberNew[key] = Obj;
                                    IsAdd = true;
                                }
                            }
                            
                        }
                        /*if (true) {
                            element.append("<collection collection='member'></collection>"); 
                            $compile(element.contents())(scope);
                        }*/
                        if (IsAdd) {
                            element.append("<objectcollection object='memberNew' setinfo='setinfo'></objectcollection>"); 
                            $compile(element.contents())(scope);
                        }
                        
                        
                    }
                    else {
                        element.append("<objectcollection object='member' setinfo='setinfo'></objectcollection>"); 
                        $compile(element.contents())(scope);
                    }
                    
                    function checkView(members) {
                        var returnInfo = false; 
                        for (var key in members) {
                            var on = members[key];
                            if ((angular.isArray(on) || angular.isObject(on)) && on.DiffType == null) {
                                var ch = checkView(on);
                                if (ch) {
                                    returnInfo = true;
                                }
                            }
                            else if (on != null && on.DiffType != null && on.DiffType != 'unchanged') {
                                returnInfo = true;
                            }
                        }
                        return returnInfo;
                    }
                    
                }
            }
        });

        var mergeinfoTemplate = '<div ng-show="!Show">'+
                                    '<div class="spinner">'+
                                      '<div class="rect1"></div>'+
                                      '<div class="rect2"></div>'+
                                      '<div class="rect3"></div>'+
                                      '<div class="rect4"></div>'+
                                      '<div class="rect5"></div>'+
                                    '</div>'+
                                '</div>'+
                                '<div ng-show="table.length > 0 && Show">'+
                                    '<div >'+
                                        /*'<div style="width: 48%;float: left;border: 1px solid #36a0fe;;border-radius: 6px;padding: 5px;text-align: center;background-color: #36a0fe; position">'+
                                            '<strong>Source File</strong>'+
                                        '</div>'+
                                        '<div style="float: left;width: 4%;height: 12px;"></div>'+
                                        '<div style="width: 48%;float: left;border: 1px solid #13FF00;border-radius: 6px;padding: 5px;text-align: center;background-color: #13FF00;">'+
                                            '<strong>Target File</strong>'+
                                        '</div>'+*/
                                        '<div style="width: 48%;float: left; padding: 5px;text-align: center; position">'+
                                            '<strong>Source File</strong>'+
                                        '</div>'+
                                        '<div style="float: left;width: 4%;height: 12px;"></div>'+
                                        '<div style="width: 48%;float: left; padding: 5px;text-align: center;">'+
                                            '<strong>Target File</strong>'+
                                        '</div>'+
                                    '</div>'+
                                    '<div >'+
                                        '<div style="width: 50%; float: left;">'+
                                            '<div class="BASE" style="overflow-x: scroll; border: 1px solid #9C9C9C; border-radius: 6px; padding: 5px; margin-right: 23px;">'+
                                                '<table style="border:1px solid black;">'+
                                                    '<tbody id="display">'+
                                                        '<tr ng-repeat="line in table" style="height: 27px;">'+
                                                            '<td style="border-top: 1px solid #9C9C9C; border-bottom: 1px solid #9C9C9C; border-left: 1px solid #9C9C9C; border-right: 1px solid #9C9C9C">'+
                                                                '{{line.indexBase}}'+
                                                            '</td>'+
                                                            '<td style="border-top: 1px solid #9C9C9C; border-bottom: 1px solid #9C9C9C; border-left: 1px solid #9C9C9C; border-right: 1px solid #9C9C9C">'+
                                                                '<pre class="{{line.BaseClass}}" >{{line.valueBase}}</pre>'+
                                                            '</td>'+
                                                        '</tr>'+
                                                    '</tbody>'+
                                                '</table>'+
                                            '</div>'+
                                        '</div>'+

                                        '<div style="width: 46px; float: left; margin-left: -23px; padding-top: 6px;">'+
                                            '<table style="border:1px solid black;">'+
                                                '<tbody id="displayA">'+
                                                    '<tr ng-repeat="line in table" style="height: 27px;">'+
                                                        '<td style="border-top: 1px solid #9C9C9C; border-bottom: 1px solid #9C9C9C; border-left: 1px solid #9C9C9C; border-right: 1px solid #9C9C9C" ng-show="line.removed && line.Button">'+
                                                            '<span ng-show="!line.edit" class="iconnDiff glyphicon glyphicon-plus" ng-click="remove(line)"></span>'+
                                                            '<span ng-show="line.edit" class="iconnDiff glyphicon glyphicon-fast-backward" ng-click="removeBack(line)"></span>'+
                                                        '</td>'+
                                                        '<td style="width: 23px; border-top: 1px solid #9C9C9C; border-bottom: 1px solid #9C9C9C; border-left: 1px solid #9C9C9C; border-right: 1px solid #9C9C9C" ng-show="!line.removed">'+
                                                            '<div class="EmpyBlock"></div>'+
                                                        '</td>'+
                                                        '<td style="border-top: 1px solid #9C9C9C; border-bottom: 1px solid #9C9C9C; border-left: 1px solid #9C9C9C; border-right: 1px solid #9C9C9C" ng-show="line.add && line.Button">'+
                                                            '<span ng-show="!line.edit" class="iconnDiff glyphicon glyphicon-minus" ng-click="add(line)"></span>'+
                                                            '<span ng-show="line.edit" class="iconnDiff glyphicon glyphicon-fast-forward" ng-click="addBack(line)"></span>'+
                                                        '</td>'+
                                                        '<td style="width: 23px; border-top: 1px solid #9C9C9C; border-bottom: 1px solid #9C9C9C; border-left: 1px solid #9C9C9C; border-right: 1px solid #9C9C9C" ng-show="!line.add">'+
                                                            '<div class="EmpyBlock"></div>'+
                                                        '</td>'+
                                                    '</tr>'+
                                                 '</tbody>'+
                                            '</table>'+
                                        '</div>'+
                                        
                                        '<div style="width: 50%; float: right; margin-left: -23px;">'+
                                            '<div class="NEW" style="overflow-x: scroll; border: 1px solid #9C9C9C; border-radius: 6px; padding: 5px; margin-left: 23px;">'+
                                                '<table style="border:1px solid black;">'+
                                                    '<tbody id="display2">'+
                                                        '<tr ng-repeat="line in table" style="height: 27px;">'+
                                                            '<td style="border-top: 1px solid #9C9C9C; border-bottom: 1px solid #9C9C9C; border-left: 1px solid #9C9C9C; border-right: 1px solid #9C9C9C">'+
                                                                '{{line.indexNew}}'+
                                                            '</td>'+
                                                            '<td style="border-top: 1px solid #9C9C9C; border-bottom: 1px solid #9C9C9C; border-left: 1px solid #9C9C9C; border-right: 1px solid #9C9C9C">'+
                                                                '<pre class="{{line.NewClass}}" >{{line.valueNew}}</pre>'+
                                                            '</td>'+
                                                        '</tr>'+
                                                    '</tbody>'+
                                                '</table>'+
                                            '</div>'+
                                        '</div>'+
                                    '</div>'+
                                '</div>';
        myApp.directive("mergeinfo", [function () {
            return {
                scope: {
                    sourse: '@',
                    target: '@',
                    file: "="
                },
                restrict: 'E',
                template: mergeinfoTemplate,
                link: function (scope, element, attributes, ngModelController) {
                    console.log(scope);
                    console.log(ngModelController);
                    var BaseElement = $(element).find(".BASE");
                    var NewElement = $(element).find(".NEW");
                    console.log(BaseElement);
                    scope.Show = false;
                    scope.start = false;
                    scope.table = [];
                    scope.returnValue = '';
                    BaseElement.scroll(function(event){
                        if (event.type == 'scroll') {
                            var inf = event.currentTarget.scrollLeft;
                            NewElement.scrollLeft(inf);
                        }
                        
                    })
                    NewElement.scroll(function(event){
                        if (event.type == 'scroll') {
                            var inf = event.currentTarget.scrollLeft;
                            BaseElement.scrollLeft(inf);
                        }
                    })
                    scope.$watch('sourse', function(newValue, oldValue) {
                      if (scope.sourse != null && scope.sourse != '' && scope.start) {
                          getView();
                      }
                      else if (scope.sourse != null && scope.sourse != '' && !scope.start) {
                        scope.start = true;
                      }
                    });
                    scope.$watch('target', function(newValue, oldValue) {
                      if (scope.target != null && scope.target != '' && scope.start) {
                          getView();
                      }
                      else if (scope.target != null && scope.target != '' && !scope.start) {
                        scope.start = true;
                      }
                    });
                    
                    scope.add = function(line) {
                        for (var x= line.index -1; x< scope.table.length ; x++) {
                            if (scope.table[x].add) {
                                scope.table[x].edit = true;
                                scope.table[x].valueNew = '';
                                scope.table[x].BaseClass = 'editClass';
                                scope.table[x].NewClass = 'editClass';
                            }
                            else {
                                break;
                            }
                        }
                        scope.getReturnModel();
                        
                        
                    }
                    
                    scope.addBack = function(line) {
                        for (var x= line.index -1; x< scope.table.length ; x++) {
                            if (scope.table[x].add) {
                                scope.table[x].edit = false;
                                scope.table[x].valueNew = scope.table[x].NewBackup;
                                scope.table[x].BaseClass = '';
                                scope.table[x].NewClass = 'addClass';
                            }
                            else {
                                break;
                            }
                        }
                        scope.getReturnModel();
                        
                        
                    }
                    
                    scope.remove = function(line) {
                        for (var x= line.index-1; x< scope.table.length ; x++) {
                            if (scope.table[x].removed) {
                                scope.table[x].edit = true;
                                scope.table[x].valueNew = scope.table[x].valueBase;
                                scope.table[x].BaseClass = 'editClass';
                                scope.table[x].NewClass = 'editClass';
                            }
                            else {
                                break;
                            }
                        }
                        scope.getReturnModel();
                        
                    }
                    
                    scope.removeBack = function(line) {
                        for (var x= line.index -1; x< scope.table.length ; x++) {
                            if (scope.table[x].removed) {
                                scope.table[x].edit = false;
                                scope.table[x].valueNew = '';
                                scope.table[x].BaseClass = 'removeClass';
                                scope.table[x].NewClass = '';
                            }
                            else {
                                break;
                            }
                        }
                        scope.getReturnModel();
                        
                    }
                    
                    scope.getReturnModel = function () {
                        var returnST = '';
                        for (var x= 0; x< scope.table.length ; x++) {
                            var line = scope.table[x];
                            if (line.removed && line.edit || line.add && !line.edit || !line.removed && !line.add) {
                                returnST += line.valueNew + '\n';
                            }
                        }
                        scope.file = returnST;
                        
                        
                    }
                    
                    function getView() {
                        scope.table = [];
                        var diff = JsDiff.diffLines(scope.sourse, scope.target);
                        
                        var indexBase = 1;
                        var indexNew = 1;
                        var index = 1;
                        diff.forEach(function(part){
                            var lin = part.value.split('\n');
                            var color = part.added ? '#4EB1CB' :
                            part.removed ? '#717ECD' : 'white';
                            var ButtonCheck = false;
                            for (var x=0; x< lin.length; x++) {
                                if (x == (lin.length -1) && lin[x] == '') {
                                    continue;
                                }
                                var Line = {};
                                Line.index = index;
                                Line.edit = false;
                                
                                index++;
                                if (part.added) {
                                    Line.indexBase = '';
                                    Line.indexNew = indexNew;
                                    Line.valueBase = '';
                                    Line.valueNew = lin[x] == '' ? '': lin[x];
                                    Line.NewBackup = lin[x] == '' ? '': lin[x];
                                    Line.add = true;
                                    Line.NewClass = 'addClass'
                                    if (!ButtonCheck) {
                                        Line.Button = true;
                                        ButtonCheck = true;
                                    }
                                    else {
                                        Line.Button = false;
                                    }
                                    Line.color = color;
                                    Line.removed = false;
                                    indexNew++;
                                }
                                else if (part.removed) {
                                    Line.indexBase = indexBase;
                                    Line.indexNew = '';
                                    Line.valueBase = lin[x] == '' ? '': lin[x];
                                    Line.valueNew = '';
                                    Line.add = false;
                                    if (!ButtonCheck) {
                                        Line.Button = true;
                                        ButtonCheck = true;
                                    }
                                    else {
                                        Line.Button = false;
                                        
                                    }
                                    Line.color = color;
                                    Line.removed = true;
                                    Line.BaseClass = 'removeClass'
                                    indexBase++;
                                }
                                else {
                                    Line.indexBase = indexBase;
                                    Line.indexNew = indexNew;
                                    Line.valueBase = lin[x] != '' ? lin[x]: '';
                                    Line.valueNew = lin[x] != '' ? lin[x]: '';
                                    Line.add = false;
                                    Line.color = color;
                                    Line.removed = false;
                                    indexBase++;
                                    indexNew++;
                                }
                                scope.table.push(Line);
                            }
                       });
                       scope.Show = true;
                       console.log(scope.table);
                       scope.getReturnModel();
                    }
                    
                }
            }
        }]);

        var mergeXmlTemplate = '<div ng-show="!Show">'+
                                    '<div class="spinner">'+
                                      '<div class="rect1"></div>'+
                                      '<div class="rect2"></div>'+
                                      '<div class="rect3"></div>'+
                                      '<div class="rect4"></div>'+
                                      '<div class="rect5"></div>'+
                                    '</div>'+
                                '</div>'+
                                '<div ng-show="Show">'+
                                    '<div >'+
                                        /*'<div style="width: 49%;float: left;border: 2px solid #36a0fe;;border-radius: 6px;padding: 5px;text-align: center;background-color: #36a0fe;">'+
                                            '<strong>Source File</strong>'+
                                        '</div>'+
                                        '<div style="width: 49%;float: left;border: 2px solid #13FF00;border-radius: 6px;padding: 5px;text-align: center;background-color: #13FF00;">'+
                                            '<strong>Target File</strong>'+
                                        '</div>'+*/
                                        '<div style="width: 49%;float: left; padding: 5px;text-align: center;">'+
                                            '<strong>Source File</strong>'+
                                        '</div>'+
                                        '<div style="width: 49%;float: left; padding: 5px;text-align: center;">'+
                                            '<strong>Target File</strong>'+
                                        '</div>'+
                                    '</div>'+                       
                                    '<div >'+
                                        '<div id="BASE" style="width: 49%; height: 600px; overflow: scroll;float: left;border: 2px solid #9C9C9C;border-radius: 6px;padding: 5px;">'+
                                            '<table style="border:1px solid black;">'+
                                                '<tbody id="display">'+
                                                    '<tr ng-repeat="(key, member) in diffXML">'+
                                                        '<td style="height: 28px; border-top: 1px solid #9C9C9C; border-bottom: 1px solid #9C9C9C; border-left: 1px solid #9C9C9C; border-right: 1px solid #9C9C9C">'+
                                                            /*'{} {{key}}'+*/
                                                            '{{key}}'+
                                                        '</td>'+
                                                        '<td style="height: 28px; border-top: 1px solid #9C9C9C; border-bottom: 1px solid #9C9C9C; border-left: 1px solid #9C9C9C; border-right: 1px solid #9C9C9C">'+
                                                            '<member  member="member" setinfo="setinfo"></member>'+
                                                        '</td>'+
                                                    '</tr>'+
                                                '</tbody>'+
                                            '</table>'+
                                        '</div>'+
                                        '<div id="NEW" style="width: 49%; height: 600px; overflow: scroll;border: 2px solid #9C9C9C;border-radius: 6px;padding: 5px;">'+
                                            '<table style="border:1px solid black;">'+
                                                '<tbody id="display2">'+
                                                    '<tr ng-repeat="(key, member) in diffXML">'+
                                                        '<td style="height: 28px; border-top: 1px solid #9C9C9C; border-bottom: 1px solid #9C9C9C; border-left: 1px solid #9C9C9C; border-right: 1px solid #9C9C9C">'+
                                                            /*'{} {{key}}'+*/
                                                            '{{key}}'+
                                                        '</td>'+
                                                        '<td style="height: 28px; border-top: 1px solid #9C9C9C; border-bottom: 1px solid #9C9C9C; border-left: 1px solid #9C9C9C; border-right: 1px solid #9C9C9C">'+
                                                            '<member  member="member" setinfo="setinfo"></member>'+
                                                        '</td>'+
                                                    '</tr>'+
                                                '</tbody>'+
                                            '</table>'+
                                        '</div>'+
                                    '</div>'+
                                '</div>';
        myApp.directive("mergeXml", [function () {
            return {
                scope: {
                    sourse: '@',
                    target: '@',
                    file: "="
                },
                restrict: 'E',
                template: mergeXmlTemplate,
                link: function (scope, element, attributes, ngModelController) {
                    
                    console.log(scope);
                    console.log(ngModelController);
                    var BaseElement = $(element).find("#BASE");
                    var NewElement = $(element).find("#NEW");
                    scope.Show = false;
                    
                    scope.start = false;
                    scope.returnValue = '';
                    BaseElement.scroll(function(event){
                        if (event.type == 'scroll') {
                            var inf = event.currentTarget.scrollLeft;
                            NewElement.scrollLeft(inf);
                            var infV = event.currentTarget.scrollTop;
                            NewElement.scrollTop(infV);
                        }
                        
                    })
                    NewElement.scroll(function(event){
                        if (event.type == 'scroll') {
                            var inf = event.currentTarget.scrollLeft;
                            BaseElement.scrollLeft(inf);
                            var infV = event.currentTarget.scrollTop;
                            BaseElement.scrollTop(infV);
                        }
                    })
                    scope.$watch('sourse', function(newValue, oldValue) {
                      
                        if (scope.sourse != null && scope.sourse != '' && scope.start) {
                          getView();
                      }
                      else if (scope.sourse != null && scope.sourse != '' && !scope.start) {
                        scope.start = true;
                      }
                    });
                    scope.$watch('target', function(newValue, oldValue) {
                      console.log('target');
                        if (scope.target != null && scope.target != '' && scope.start) {
                          getView();
                      }
                      else if (scope.target != null && scope.target != '' && !scope.start) {
                        scope.start = true;
                      }
                    });
                    
                    
                    scope.setinfo = function() {
                        console.log('setinfo');
                        console.log(scope.diffXML);
                        var newObject = cleaningObject.getObject(scope.diffXML);
                        console.log(newObject);
                        var x2js = new X2JS();
                        var returnXML = x2js.json2xml_str(newObject);
                        scope.file = returnXML;
                        
                    }
                    var cleaningObject = function() {
                        return {
                            VALUE_CREATED: 'created',
                            VALUE_UPDATED: 'updated',
                            VALUE_DELETED: 'deleted',
                            VALUE_UNCHANGED: 'unchanged',
                            getObject: function(obj) {
                                if (this.isFunction(obj)) {
                                    throw 'Invalid argument. Function given, object expected.';
                                }
                                if (this.isObject(obj) && obj.DiffType != null) {
                                    return obj.DiffViewValue;
                                    
                                    
                                }
                                var diff;
                                if ((this.isObject(obj) || this.isArray(obj)) && obj.DiffType == null) {
                                    var checkMassive = true;
                                    for (var key in obj) {
                                        if (!angular.isNumber(parseInt(key)) || isNaN(parseInt(key))) {
                                            checkMassive = false;
                                        }
                                    }
                                    if (checkMassive) {
                                        diff = [];
                                        for (var key in obj) {
                                            if (key != '__proto__') {
                                                var ob = this.getObject(obj[key]);
                                                if (this.isAdd(ob)) {
                                                    diff.push(ob);
                                                }
                                            }
                                            
                                        }
                                    }
                                    else {
                                        diff = {};
                                        for (var key in obj) {
                                            if (key != '__proto__' && key != 'remove') {
                                                var ob = this.getObject(obj[key]);
                                                if (this.isAdd(ob)) {
                                                    diff[key] = ob;
                                                }
                                            }
                                            
                                        }
                                    }
                                }
                                return diff;
                            },
                            isAdd: function(obj) {
                                var checkAdd = true;
                                if (obj != null && 'undefined' != typeof(obj)){
                                }
                                else {
                                    checkAdd = false;
                                }
                                if (this.isArray(obj) && obj.length == 0) {
                                    checkAdd = false;
                                }
                                if (this.isObject(obj)) {
                                    var index = 0;
                                    for (var key in obj) {
                                        index ++;
                                    }
                                    if (index == 0) {
                                        checkAdd = false;
                                    }
                                }
                                return checkAdd;
                            },
                            isFunction: function(obj) {
                                return {}.toString.apply(obj) === '[object Function]';
                            },
                            isArray: function(obj) {
                                return {}.toString.apply(obj) === '[object Array]';
                            },
                            isObject: function(obj) {
                                return {}.toString.apply(obj) === '[object Object]';
                            },
                            isValue: function(obj) {
                                return !this.isObject(obj) && !this.isArray(obj);
                            }
                        }
                    }();
                    
                    scope.getReturnModel = function () {
                        var returnST = '';
                        for (var x= 0; x< scope.table.length ; x++) {
                            var line = scope.table[x];
                            if (line.removed && line.edit || line.add && !line.edit || !line.removed && !line.add) {
                                returnST += line.valueNew + '\n';
                            }
                        }
                        scope.file = returnST;
                        
                        
                    }
                    
                    function getView() {
                        var StartDate = new Date();
                        var VStartDate = StartDate.getTime();
                        console.log('Start = ' + StartDate);
                        var x2js = new X2JS();
                        // console.log(scope.target);
                        // var sourseObj = x2js.xml_str2json( scope.sourse );
                        // var targetObj = x2js.xml_str2json( scope.target );
                        // console.log(sourseObj);
                        // console.log(targetObj);

                        beforOpenMainTag = '';
                        openMainTag = '';
                        betweenMainTag = '';
                        closeMainTag = '';
                        deleteMainTag(scope.sourse);
                        console.log('beforOpenMainTag-' + beforOpenMainTag);
                        console.log('openMainTag-'+openMainTag);
                        console.log('betweenMainTag-'+betweenMainTag);
                        console.log('closeMainTag-'+closeMainTag);
                        //var sourseObj = x2js.xml_str2json( scope.sourse );
                        var sourseObj;
                        var targetObj;

                        if (openMainTag != '' && closeMainTag != '') {
                            sourseObj = x2js.xml_str2json( '<xml>'+betweenMainTag+'</xml>' );

                            beforOpenMainTag = '';
                            openMainTag = '';
                            betweenMainTag = '';        
                            closeMainTag = '';

                            deleteMainTag(scope.target);
                            if (openMainTag != '' && closeMainTag != '') {
                                //var targetObj = x2js.xml_str2json( scope.target );
                                targetObj = x2js.xml_str2json( '<xml>'+betweenMainTag+'</xml>' );
                            }
                            else {
                                sourseObj = x2js.xml_str2json( scope.sourse );
                                targetObj = x2js.xml_str2json( scope.target );
                            }
                        }
                        else {
                            sourseObj = x2js.xml_str2json( scope.sourse );
                            targetObj = x2js.xml_str2json( scope.target );
                        }

                        scope.file = scope.target;
                        var diff = deepDiffMapper.map(sourseObj, targetObj);
                        console.log(diff);
                        scope.diffXML = {};
                        scope.diffXML = diff;
                        scope.Show = true;
                        
                        var FinishDate = new Date();
                        console.log('Finish = ' + FinishDate);
                        console.log('Finish = ' + (FinishDate.getTime() - VStartDate));
                    }
                    
                    
                    
                    
                    var deepDiffMapper = function() {
                        return {
                            VALUE_CREATED: 'created',
                            VALUE_UPDATED: 'updated',
                            VALUE_DELETED: 'deleted',
                            VALUE_UNCHANGED: 'unchanged',
                            map: function(obj1, obj2) {
                                console.log('obj1');
                                console.log(obj1);
                                console.log('obj2');
                                console.log(obj2);
                                /****************/
                                /*if (obj1 == undefined && (obj2 == 'true' || obj2 == 'false')) {
                                    obj1 = 'false';
                                }
                                if (obj2 == undefined && (obj1 == 'true' || obj1 == 'false')) {
                                    obj2 = 'false';
                                }*/
                                /****************/
                                if (this.isFunction(obj1) || this.isFunction(obj2)) {
                                    throw 'Invalid argument. Function given, object expected.';
                                }
                                if (this.isValue(obj1) && this.isValue(obj2)) {
                                //if (this.isValue(obj1) && this.isValue(obj2)) {
                                    var DiffType = this.compareValues(obj1, obj2);
                                    if (this.isArray(obj1)) {
                                        var ret = [];
                                        if ($.inArray( obj2, obj1 ) > -1) {
                                            ret.push(this.map(obj2, obj2));
                                        }
                                        for (var key in obj1) {
                                            if (obj1[key] != obj2) {
                                                ret.push(this.map(obj1[key], undefined));
                                            }
                                        }
                                        
                                        return ret;
                                    }
                                    else if (this.isArray(obj2)) {
                                        var ret = [];
                                        if ($.inArray( obj1, obj2)  > -1) {
                                            ret.push(this.map(obj1, obj1));
                                        }
                                        for (var key in obj2) {
                                            if (obj2[key] != obj1) {
                                                ret.push(this.map(undefined, obj2[key]));
                                            }
                                        }
                                        
                                        return ret;
                                    }
                                    else if (this.isObject(obj1)) {
                                        var diffnew = {};
                                        for (var key in obj1) {
                                            diffnew[key] = this.map(obj1[key], undefined);
                                        }
                                        return diffnew;
                                    }
                                    else if (this.isObject(obj2)) {
                                        var diffnew = {};
                                        for (var key in obj2) {
                                            diffnew[key] = this.map(undefined, obj2[key]);
                                        }
                                        return diffnew;
                                    }
                                    var Diffstyle =  {};
                                    if (DiffType == this.VALUE_CREATED) {
                                        Diffstyle['background-color'] = '#4EB1CB';
                                    }
                                    else if (DiffType == this.VALUE_UPDATED) {
                                        Diffstyle['background-color'] = '#86B9EA';
                                    }
                                    else if (DiffType == this.VALUE_DELETED) {
                                        Diffstyle['background-color'] = '#717ECD';
                                    }

                                    console.log('----*DiffType\n\n');
                                    console.log(DiffType);
                                    return {DiffType: DiffType, NewData: obj2, OldData : obj1, DiffAction: false, DiffViewValue: obj2, Diffstyle: Diffstyle};
                                    
                                   
                                }
                                else {
                                    var diff = {};
                                    if (this.isObject(obj1) || this.isObject(obj2)) {
                                        var value2 = undefined;
                                        //if (!this.isUndefined(obj1)) { 
                                            for (var key in obj1) {
                                                if (this.isFunction(obj1[key])) {
                                                    continue;
                                                }
                                                
                                                console.log('III KEY >>> \n\n' + key);
                                               
                                                if (!this.isUndefined(obj2) && 'undefined' != typeof(obj2[key])) {
                                                    value2 = obj2[key];
                                                }
                                                else {
                                                    if (obj1[key] == 'true' || obj1[key] == 'false') {
                                                        value2 = 'false';
                                                    }
                                                    else {
                                                        value2 = '';
                                                    }
                                                }
                                                
                                                diff[key] = this.map(obj1[key], value2);
                                            }
                                        //}
                                        //if (!this.isUndefined(obj2)) {
                                            for (var key in obj2) {
                                                if (this.isFunction(obj2[key]) || ('undefined' != typeof(diff[key]))) {
                                                    continue;
                                                }
                                                
                                                if (obj2[key] == 'true' || obj2[key] == 'false') {
                                                    diff[key] = this.map('false', obj2[key]);
                                                }
                                                else {
                                                    diff[key] = this.map(undefined, obj2[key]);
                                                }
                                            }
                                        //}
                                        
                                        // for (var key in obj1) {
                                        //     if (this.isFunction(obj1[key])) {
                                        //         continue;
                                        //     }
                            
                                        //     var value2 = undefined;
                                        //     if ('undefined' != typeof(obj2[key])) {
                                        //         value2 = obj2[key];
                                        //     }
                            
                                        //     diff[key] = this.map(obj1[key], value2);
                                        // }
                                        // for (var key in obj2) {
                                        //     if (this.isFunction(obj2[key]) || ('undefined' != typeof(diff[key]))) {
                                        //         continue;
                                        //     }
                            
                                        //     diff[key] = this.map(undefined, obj2[key]);
                                        // }
                                    }

                                    
                                    if (this.isArray(obj1) || this.isArray(obj2)) {
                                        diff = [];
                                        obj1 = this.isUndefined(obj1) ? [] : obj1;
                                        obj2 = this.isUndefined(obj2) ? [] : obj2;
                                        if (this.isValue(obj1) || this.isObject(obj1)) {
                                            var temp = obj1;
                                            obj1 = [];
                                            obj1.push(temp);
                                        }
                                        if (this.isValue(obj2) || this.isObject(obj2)) {
                                            var temp = obj2;
                                            obj2 = [];
                                            obj2.push(temp);
                                        }
                                    
                                    //var diff = {};
                                        if (this.isArray(obj2) && this.isArray(obj1)) {
                                            if (this.isValue(obj1[0])) {
                                                var endKey = 0;
                                                /*for (var key in obj2) {*/
                                                for (var key=0; key < obj2.length; key++) {
                                                    var value = obj2[key];
                                                    var Diffstyle =  {};
                                                    if ($.inArray(value, obj1) > -1) {
                                                        diff[key] = {DiffType: this.VALUE_UNCHANGED, NewData: value, OldData : value, DiffAction: false, DiffViewValue: value, Diffstyle: {}}
                                                    }
                                                    else {
                                                        Diffstyle['background-color'] = '#4EB1CB';
                                                        diff[key] = {DiffType: this.VALUE_CREATED, NewData: value, OldData : null, DiffAction: false, DiffViewValue: value, Diffstyle: Diffstyle}
                                                    }
                                                    endKey = key;
                                                }
                                                /*for (var key in obj1) {*/
                                                for (var key=0; key < obj1.length; key++) {
                                                    var value = obj1[key];
                                                    var Diffstyle =  {};
                                                    if ($.inArray(value, obj2) > -1) {
                                                    }
                                                    else {
                                                        endKey++;
                                                        Diffstyle['background-color'] = '#717ECD';
                                                        diff[endKey] = {DiffType: this.VALUE_DELETED, NewData: null, OldData : value, DiffAction: false, DiffViewValue: null, Diffstyle: Diffstyle}
                                                    }
                                                }
                                            }
                                            else if (this.isObject(obj2[0])) {
                                                //analitics key
                                                var KeyName = this.getKey(obj2);
                                                if (KeyName == null) {
                                                    // new logic merge
                                                    var firstObj = obj2[0];
                                                    var CheckMerge = true;
                                                    for (var key in firstObj) {
                                                        if (!this.isValue(firstObj[key])) {
                                                            CheckMerge = false;
                                                            break;
                                                        }
                                                    }
                                                    if (CheckMerge) {
                                                        var keyIndex= 0;
                                                        var obj2LIST = [];
                                                        var obj1LIST = [];
                                                        var obj2MAP = {};
                                                        var obj1MAP = {};
                                                        for (var key in obj2) {
                                                            obj2LIST.push(angular.toJson(obj2[key]));
                                                            obj2MAP[key] = angular.toJson(obj2[key]);
                                                        }
                                                        for (var key in obj1) {
                                                            obj1LIST.push(angular.toJson(obj1[key]));
                                                            obj1MAP[key] = angular.toJson(obj1[key]);
                                                        }
                                                        for (var key in obj2) {
                                                            if (this.isFunction(obj2[key])) {
                                                                continue;
                                                            }
                                                            if ($.inArray(obj2MAP[key], obj1LIST) > -1) {
                                                                diff[key] = this.map(obj2[key], obj2[key]);
                                                            }
                                                            else {
                                                                diff[key] = this.map(undefined, obj2[key]);
                                                            }
                                                            keyIndex = key;
                                                        }
                                                        
                                                        for (var key in obj1) {
                                                            if (this.isFunction(obj1[key])) {
                                                                continue;
                                                            }
                                                            
                                                            if ($.inArray(obj1MAP[key], obj2LIST) == -1) {
                                                                keyIndex++;
                                                                diff[keyIndex] = this.map(obj1[key], undefined);
                                                            }
                                                            
                                                        }
                                                        
                                                        
                                                    }
                                                    else {
                                                        for (var key in obj1) {
                                                            if (this.isFunction(obj1[key])) {
                                                                continue;
                                                            }
                                            
                                                            var value2 = undefined;
                                                            if ('undefined' != typeof(obj2[key])) {
                                                                value2 = obj2[key];
                                                            }
                                            
                                                            diff[key] = this.map(obj1[key], value2);
                                                        }
                                                        for (var key in obj2) {
                                                            if (this.isFunction(obj2[key]) || ('undefined' != typeof(diff[key]))) {
                                                                continue;
                                                            }
                                            
                                                            diff[key] = this.map(undefined, obj2[key]);
                                                        }
                                                    }
                                                }
                                                else {
                                                    //logic merge
                                                    var obj1Map = {};
                                                    var obj1KeyList = [];
                                                    var obj2Map = {};
                                                    var obj2KeyList = [];
                                                    for (var key in obj1) {
                                                        var objQ = obj1[key];
                                                        obj1Map[objQ[KeyName]] = objQ;
                                                        obj1KeyList.push(objQ[KeyName]);
                                                    }
                                                    for (var key in obj2) {
                                                        var objQ = obj2[key];
                                                        obj2Map[objQ[KeyName]] = objQ;
                                                        obj2KeyList.push(objQ[KeyName]);
                                                    }
                                                    var keyIndex = 0;
                                                    for (var key in obj2) {
                                                        if (this.isFunction(obj2[key])) {
                                                            continue;
                                                        }
                                                        var newObj = obj2[key];
                                                        var value = newObj[KeyName];
                                                        keyIndex = key;
                                                        if ($.inArray(value, obj1KeyList) > -1 ) {
                                                            var oldObj = obj1Map[value];
                                                            diff[key] = this.map(oldObj, newObj);
                                                        }
                                                        else {
                                                            diff[key] = this.map(undefined, newObj);
                                                        }
                                                    }
                                                    for (var key in obj1) {
                                                        if (this.isFunction(obj1[key])) {
                                                            continue;
                                                        }
                                                        var oldObj = obj1[key];
                                                        var value = oldObj[KeyName];
                                                        if ($.inArray(value, obj2KeyList) > -1 ) {
                                                        }
                                                        else {
                                                            keyIndex++;
                                                            diff[keyIndex] = this.map(oldObj, undefined);
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                        // else {
                                        //     for (var key in obj1) {
                                        //         if (this.isFunction(obj1[key])) {
                                        //             continue;
                                        //         }
                                
                                        //         var value2 = undefined;
                                        //         if ('undefined' != typeof(obj2[key])) {
                                        //             value2 = obj2[key];
                                        //         }
                                
                                        //         diff[key] = this.map(obj1[key], value2);
                                        //     }
                                        //     for (var key in obj2) {
                                        //         if (this.isFunction(obj2[key]) || ('undefined' != typeof(diff[key]))) {
                                        //             continue;
                                        //         }
                                
                                        //         diff[key] = this.map(undefined, obj2[key]);
                                        //     }
                                        // }
                                    }
                                }


                    
                                return diff;
                    
                            },
                            compareValues: function(value1, value2) {
                                if (value1 === value2) {
                                    return this.VALUE_UNCHANGED;
                                }
                                if ('undefined' == typeof(value1)) {
                                    return this.VALUE_CREATED;
                                }
                                if ('undefined' == typeof(value2)) {
                                    return this.VALUE_DELETED;
                                }
                    
                                return this.VALUE_UPDATED;
                            },
                            getKey: function(list) {
                                var firstObject = list[0];
                                var ListKeyName = [];
                                var MapKeyName = {};
                                var returnvalue = null;
                                for (var key in firstObject) {
                                    if (this.isValue(firstObject[key])) {
                                        ListKeyName.push(key);
                                        MapKeyName[key] = [];
                                    }
                                }
                                if (ListKeyName.length == 0) {
                                    return null;
                                }
                                for (var key in list) {
                                    var object = list[key];
                                    for (var key2 in MapKeyName) {
                                        var value = object[key2]
                                        if ($.inArray(value, MapKeyName[key2]) > -1) {
                                             delete MapKeyName[key2];
                                        }
                                        else {
                                            MapKeyName[key2].push(value);
                                        }
                                    }
                                    
                                }
                                var index = 0;
                                for (var key3 in MapKeyName) {
                                     index++;
                                     if (index == 1) {
                                        returnvalue = key3;
                                     }
                                }
                                if (index == 0) {
                                    returnvalue = null;
                                }
                                
                                return returnvalue;
                                
                            },
                            isFunction: function(obj) {
                                return {}.toString.apply(obj) === '[object Function]';
                            },
                            isArray: function(obj) {
                                return {}.toString.apply(obj) === '[object Array]';
                            },
                            isObject: function(obj) {
                                return {}.toString.apply(obj) === '[object Object]';
                            },
                            isValue: function(obj) {
                                return !this.isObject(obj) && !this.isArray(obj);
                            },
                            isUndefined: function(obj) {
                                return obj === undefined || obj === null;
                            }
                        }
                    }();
                }
            }
        }]);
    //finish

        myApp.service('dataManager', function($q) {
            return {
                FirstStepMerge : function(param) {
                    var deferred = $q.defer();
                    Visualforce.remoting.Manager.invokeAction(
                        '{!$RemoteAction.FL_RemoteRepositoryController.FirstStepMerge}',
                        param,
                        function(result, event) {
                            if (event.status) {
                                deferred.resolve(result);
                            }
                            else {
                                deferred.reject(event);
                            }
                        });
                    return deferred.promise;
                },
                getLastAndDeployAtachment : function(last, deploy) {
                    var deferred = $q.defer();
                    Visualforce.remoting.Manager.invokeAction(
                        '{!$RemoteAction.FL_RemoteRepositoryController.getLastAndDeployAtachment}',
                        last, deploy,
                        function(result, event) {
                            if (event.status) {
                                deferred.resolve(result);
                            }
                            else {
                                deferred.reject(event);
                            }
                        });
                    return deferred.promise;
                }
                
            }
        });

        myApp.service('MergeService', function($q, dataManager) {
            var StartData;
            var FinishData = {};
            var START;
            var FINSH;
            var Iter;
            var mapLastDeployAttachment = {};
            var mapLastVersionAttachment = {};
            function _startMerge() {
                console.log('START');
                Iter = 0;
                getItemInfo();
            }
            function getItemInfo() {
                if (Iter < StartData.length) {
                    var Item = StartData[Iter];
                    dataManager.getLastAndDeployAtachment(Item.LastComponentHistoryATID, Item.DeployedComponentHistoryATID == null ? '' : Item.DeployedComponentHistoryATID).then(
                        function(data) {
                            if (angular.isArray(data) && data.length >= 1) {
                                var LastAtachmentZip;
                                var DeployAtachmentZip;
                                if (data[0].TypeAtt == 'Deploy') {
                                    if (data.length > 1) {
                                        LastAtachmentZip = data[1].base64;
                                    }
                                    else {
                                        LastAtachmentZip = data[0].base64;
                                    }
                                    if (Item.Deployed) {
                                        DeployAtachmentZip = data[0].base64;
                                    }
                                }
                                else {
                                    LastAtachmentZip = data[0].base64;
                                    if (Item.Deployed) {
                                        if (data.length > 1) {
                                            DeployAtachmentZip = data[1].base64;
                                        }
                                        else {
                                            DeployAtachmentZip = data[0].base64;
                                        }
                                    }
                                }
                                var zipLast = new JSZip(LastAtachmentZip, {base64:true});
                                var fileLast = zipLast.file(Item.Label).asBinary();
                                Item.LastCRC32 = zipLast.crc32(fileLast, 32);
                                Item.LastFile = fileLast;
                                if (Item.Deployed) {
                                    var zipDeploy = new JSZip(DeployAtachmentZip, {base64:true});
                                    var fileDeploy = zipDeploy.file(Item.Label).asBinary();
                                    Item.DeployFile = fileDeploy;
                                }
                                
                                getMetaItem();
                            }
                            else {
                                console.log('ERROR dont Atachment');
                            }
                        },
                        function (error) {
                        }
                     );
                }
                else {
                    console.log('FINSH');
                    FINSH = true;
                    angular.element(document.getElementById('angularControllerId')).scope().getStatusConflicts();
                }
                
            }
            
            function getMetaItem() {
                var Item = StartData[Iter];
                if (Item.Attachment != null) {
                    var zip = new JSZip(Item.Attachment, {base64:true});
                    var file = zip.file(Item.Label).asBinary();
                    Item.CRC32 = zip.crc32(file, 32);
                    Item.MetaItemFile = file;
                    if (file.indexOf('<?xml') > -1) {
                        console.log('xml >>>>\n\n');
                        Item.IsXML = true;
                    }
                    else {
                        console.log('GetMETA >>>>\n\n');
                        Item.IsXML = false;
                        
                    }
                    if (zip.file(Item.Label + '-meta.xml') != null) {
                        var fileMeta = zip.file(Item.Label + '-meta.xml').asBinary();
                        Item.MetaItemFileMeta = fileMeta;
                    }
                    AnalyticsMerge();
                                
                }
                else {
                    console.log('ERROR dont Atachment for Meta Item');
                }
            }

            /*function getMetaItem() {
                var Item = StartData[Iter];
                dataManager.getMetaItemAtachment(Item.AttachmentId).then(
                        function(data) {
                            if (data != null && data.base64 != null) {
                                var zip = new JSZip(data.base64, {base64:true});
                                var file = zip.file(Item.Label).asBinary();
                                Item.CRC32 = zip.crc32(file, 32);
                                Item.MetaItemFile = file;
                                if (file.indexOf('<?xml') > -1) {
                                    Item.IsXML = true;
                                }
                                else {
                                    Item.IsXML = false;
                                }
                                AnalyticsMerge();
                                
                                //temp
                                //Iter++;
                                //getItemInfo();
                            }
                            else {
                                console.log('ERROR dont Atachment for Meta Item');
                            }
                        },
                        function (error) {
                        }
                );
                
            }*/
            
            function getChildFileMap(metaType,xml,fileName)
            {
                var fullName = '';
                if(metaType != 'CustomLabel')
                {
                    fullName = fileName.slice(fileName.indexOf("/")+1,fileName.lastIndexOf('.'))+".";
                }
        
                var x2js = new X2JS();
                var jsnMap ={};
                var tempJSON = '';
                var srcjson = x2js.xml_str2json(xml);
                console.log(srcjson);
                console.log(srcjson);
                if(srcjson != undefined && srcjson != null)
                {
                    var srcitems;
                    if(metaType == 'CustomLabel')
                    {
                        var srcMetaItem = srcjson.CustomLabels;
                        srcitems = srcMetaItem.labels;
                    }
                    else if(metaType == 'CustomField')
                    {
                        var srcMetaItem = srcjson.CustomObject;
                        srcitems = srcMetaItem.fields;
                    }
                    else if(metaType == 'ListView')
                    {
                        var srcMetaItem = srcjson.CustomObject;
                        srcitems = srcMetaItem.listViews;
                    }
                    else if(metaType == 'CompactLayout')
                    {
                        var srcMetaItem = srcjson.CustomObject;
                        srcitems = srcMetaItem.compactLayouts;
                    }
                    else if(metaType == 'WebLink')
                    {
                        var srcMetaItem = srcjson.CustomObject;
                        srcitems = srcMetaItem.webLinks;
                    }
                    else if(metaType == 'RecordType')
                    {
                        var srcMetaItem = srcjson.CustomObject;
                        srcitems = srcMetaItem.recordTypes;
                    }
                    else if(metaType == 'FieldSet')
                    {
                        var srcMetaItem = srcjson.CustomObject;
                        srcitems = srcMetaItem.fieldSets;
                    }
                    else if(metaType == 'ValidationRule')
                    {
                        var srcMetaItem = srcjson.CustomObject;
                        srcitems = srcMetaItem.validationRules;
                    }
                    else if(metaType == 'AssignmentRule')
                    {
                        var srcMetaItem = srcjson.AssignmentRules;
                        srcitems = srcMetaItem.assignmentRule;
                    }
                    else if(metaType == 'AutoResponseRule')
                    {
                        var srcMetaItem = srcjson.AutoResponseRules;
                        srcitems = srcMetaItem.autoResponseRule;
                    }
                    else if(metaType == 'WorkflowTask')
                    {
                        var srcMetaItem = srcjson.Workflow;
                        srcitems = srcMetaItem.tasks;
                    }
                    else if(metaType == 'WorkflowOutboundMessage')
                    {
                        var srcMetaItem = srcjson.Workflow;
                        srcitems = srcMetaItem.outboundMessages;
                    }
                    else if(metaType == 'WorkflowFieldUpdate')
                    {
                        var srcMetaItem = srcjson.Workflow;
                        srcitems = srcMetaItem.fieldUpdates;
                    }
                    else if(metaType == 'WorkflowAlert')
                    {
                        var srcMetaItem = srcjson.Workflow;
                        srcitems = srcMetaItem.alerts;
                    }
                    else if( metaType == 'WorkflowRule')
                    {
                        var srcMetaItem = srcjson.Workflow;
                        srcitems = srcMetaItem.rules;
                    }
                    else if(metaType == 'SharingCriteriaRule')
                    {
                        var srcMetaItem = srcjson.SharingRules;
                        srcitems = srcMetaItem.sharingCriteriaRules;
                    }
                    else if(metaType == 'SharingOwnerRule')
                    {
                        var srcMetaItem = srcjson.SharingRules;
                        srcitems = srcMetaItem.sharingOwnerRules;
                    }
                    else if(metaType == 'BusinessProcess')
                    {
                        var srcMetaItem = srcjson.CustomObject;
                        srcitems = srcMetaItem.businessProcesses;
                    }
                    else if(metaType == 'SharingReason')
                    {
                        var srcMetaItem = srcjson.CustomObject;
                        srcitems = srcMetaItem.sharingReasons;
                    }
                    else if(metaType == 'EscalationRule')
                    {
                        var srcMetaItem = srcjson.EscalationRules;
                        srcitems = srcMetaItem.escalationRule;
                    }
                    else if(metaType == 'MatchingRule')    
                    {
                        var srcMetaItem = srcjson.MatchingRules;
                        srcitems = srcMetaItem.matchingRules;
                    }
                    else if(metaType == 'ManagedTopic')
                    {
                        var srcMetaItem = srcjson.ManagedTopics;
                        srcitems = srcMetaItem.ManagedTopic;
                    }
                    if(srcitems != undefined)
                    {
                        if(srcitems.fullName == undefined)
                        {   
                            for(var i in srcitems)  
                            {
                                if(i < srcitems.length)
                                {
                                    var v = srcitems[i];
                                    jsnMap[v.fullName]= JSON.stringify(v);
                                }
                            }            
                        }
                        else
                        {
                            jsnMap[srcitems.fullName] = JSON.stringify(srcitems);
                        }
                    }
                }
                var tempXml;
                for(var name in jsnMap)
                {
                    var tempXml = '';
                    var tempJSON = jsnMap[name];
                    if(tempJSON != undefined)
                    {
                        //header
                        if(metaType == 'CustomLabel')
                        {
                            tempXml = '<?xml version="1.0" encoding="UTF-8"?><CustomLabels xmlns="http://soap.sforce.com/2006/04/metadata">';
                        }
                        else if(metaType == 'AssignmentRule' )
                        {
                            tempXml = '<?xml version="1.0" encoding="UTF-8"?><AssignmentRules xmlns="http://soap.sforce.com/2006/04/metadata">';
                        }
                        else if(metaType == 'AutoResponseRule')
                        {
                            tempXml = '<?xml version="1.0" encoding="UTF-8"?><AutoResponseRules xmlns="http://soap.sforce.com/2006/04/metadata">';
                        }
                        else if(metaType == 'WorkflowAlert' || metaType == 'WorkflowFieldUpdate'|| metaType == 'WorkflowOutboundMessage'|| metaType == 'WorkflowTask' || metaType == 'WorkflowRule')
                        {
                            tempXml = '<?xml version="1.0" encoding="UTF-8"?><Workflow xmlns="http://soap.sforce.com/2006/04/metadata">';
                        }
                        else if(metaType == 'SharingCriteriaRule' || metaType == 'SharingOwnerRule')
                        {
                            tempXml = '<?xml version="1.0" encoding="UTF-8"?><SharingRules xmlns="http://soap.sforce.com/2006/04/metadata">';
                        }
                        else if(metaType == 'EscalationRule')
                        {
                            tempXml = '<?xml version="1.0" encoding="UTF-8"?><EscalationRules xmlns="http://soap.sforce.com/2006/04/metadata">';
                        }
                        else if(metaType == 'MatchingRule')
                        {
                            tempXml = '<?xml version="1.0" encoding="UTF-8"?><MatchingRules xmlns="http://soap.sforce.com/2006/04/metadata">';
                        }
                        else if(metaType == 'ManagedTopic')
                        {
                            tempXml = '<?xml version="1.0" encoding="UTF-8"?><ManagedTopics xmlns="http://soap.sforce.com/2006/04/metadata">';
                        }
                        else
                        {
                            tempXml = '<?xml version="1.0" encoding="UTF-8"?><CustomObject xmlns="http://soap.sforce.com/2006/04/metadata">';
                        }
                        
                        //body
                        if(metaType == 'CustomLabel')
                        {
                            tempXml = tempXml +'<labels>'+x2js.json2xml_str($.parseJSON(tempJSON))+'</labels>';
                        }
                        else if(metaType == 'CustomField')
                        {
                            tempXml = tempXml +'<fields>'+x2js.json2xml_str($.parseJSON(tempJSON))+'</fields>';
                        }
                        else if(metaType == 'ListView')
                        {
                            tempXml = tempXml +'<listViews>'+x2js.json2xml_str($.parseJSON(tempJSON))+'</listViews>';
                        }
                        else if(metaType == 'CompactLayout')
                        {
                            tempXml = tempXml +'<compactLayouts>'+x2js.json2xml_str($.parseJSON(tempJSON))+'</compactLayouts>';
                        }
                        else if(metaType == 'WebLink')
                        {
                            tempXml = tempXml +'<webLinks>'+x2js.json2xml_str($.parseJSON(tempJSON))+'</webLinks>';
                        }
                        else if(metaType == 'RecordType')
                        {
                            tempXml = tempXml +'<recordTypes>'+x2js.json2xml_str($.parseJSON(tempJSON))+'</recordTypes>';
                        }
                        else if(metaType == 'FieldSet')
                        {
                            tempXml = tempXml +'<fieldSets>'+x2js.json2xml_str($.parseJSON(tempJSON))+'</fieldSets>';
                        }
                        else if(metaType == 'ValidationRule')
                        {
                            tempXml = tempXml +'<validationRules>'+x2js.json2xml_str($.parseJSON(tempJSON))+'</validationRules>';
                        }
                        else if(metaType == 'AssignmentRule')
                        {
                            tempXml = tempXml +'<assignmentRule>'+x2js.json2xml_str($.parseJSON(tempJSON))+'</assignmentRule>';
                        }
                        else if(metaType == 'AutoResponseRule')
                        {
                            tempXml = tempXml +'<autoResponseRule>'+x2js.json2xml_str($.parseJSON(tempJSON))+'</autoResponseRule>';
                        }
                        else if(metaType == 'WorkflowAlert')
                        {
                            tempXml = tempXml +'<alerts>'+x2js.json2xml_str($.parseJSON(tempJSON))+'</alerts>';
                        }
                        else if(metaType == 'WorkflowFieldUpdate')
                        {
                            tempXml = tempXml +'<fieldUpdates>'+x2js.json2xml_str($.parseJSON(tempJSON))+'</fieldUpdates>';
                        }
                        else if(metaType == 'WorkflowOutboundMessage')
                        {
                            tempXml = tempXml +'<outboundMessages>'+x2js.json2xml_str($.parseJSON(tempJSON))+'</outboundMessages>';
                        }
                        else if(metaType == 'WorkflowTask')
                        {
                            tempXml = tempXml +'<tasks>'+x2js.json2xml_str($.parseJSON(tempJSON))+'</tasks>';
                        }
                        else if(metaType == 'WorkflowRule')
                        {
                            tempXml = tempXml +'<rules>'+x2js.json2xml_str($.parseJSON(tempJSON))+'</rules>';
                        }
                        else if(metaType == 'SharingCriteriaRule')
                        {
                            tempXml = tempXml +'<sharingCriteriaRules>'+x2js.json2xml_str($.parseJSON(tempJSON))+'</sharingCriteriaRules>';
                        }
                        else if(metaType == 'SharingOwnerRule')
                        {
                            tempXml = tempXml +'<sharingOwnerRules>'+x2js.json2xml_str($.parseJSON(tempJSON))+'</sharingOwnerRules>';
                        }
                        else if(metaType == 'EscalationRule')
                        {
                            tempXml = tempXml +'<escalationRule>'+x2js.json2xml_str($.parseJSON(tempJSON))+'</escalationRule>';
                        }
                        else if(metaType == 'MatchingRule')
                        {
                            tempXml = tempXml +'<matchingRules>'+x2js.json2xml_str($.parseJSON(tempJSON))+'</matchingRules>';
                        }
                        else if(metaType == 'ManagedTopic')
                        {
                            tempXml = tempXml +'<managedTopic>'+x2js.json2xml_str($.parseJSON(tempJSON))+'</managedTopic>';
                        }
                        else if(metaType == 'BusinessProcess')
                        {
                            tempXml = tempXml +'<businessProcesses>'+x2js.json2xml_str($.parseJSON(tempJSON))+'</businessProcesses>';
                        }
                        else if(metaType == 'SharingReason')
                        {
                            tempXml = tempXml +'<sharingReasons>'+x2js.json2xml_str($.parseJSON(tempJSON))+'</sharingReasons>';
                        }
                        
                        
                        //footer
                        if(metaType == 'CustomLabel')
                        {
                            tempXml = tempXml +'</CustomLabels>';
                        }
                        else if(metaType == 'AssignmentRule' )
                        {
                            tempXml = tempXml +'</AssignmentRules>';
                        }
                        else if(metaType == 'AutoResponseRule')
                        {
                            tempXml = tempXml +'</AutoResponseRules>';
                        }
                        else if(metaType == 'WorkflowAlert' || metaType == 'WorkflowFieldUpdate'|| metaType == 'WorkflowOutboundMessage'|| metaType == 'WorkflowTask' || metaType == 'WorkflowRule')
                        {
                            tempXml = tempXml +'</Workflow>';
                        }
                        else if(metaType == 'SharingCriteriaRule' || metaType == 'SharingOwnerRule')
                        {
                            tempXml = tempXml +'</SharingRules>';
                        }
                        else if(metaType == 'EscalationRule')
                        {
                            tempXml = tempXml +'</EscalationRules>';
                        }
                        else if(metaType == 'MatchingRule')
                        {
                            tempXml = tempXml +'</MatchingRules>';
                        }
                        else if(metaType == 'ManagedTopic')
                        {
                            tempXml = tempXml +'</ManagedTopics>';
                        }
                        else
                        {
                            tempXml = tempXml +'</CustomObject>';
                        }
                        //fileMap[metaType+"#"+fullName+""+name]=   getCrcWithData(tempXml);
                        
                    }
                }
                return tempXml;
            }
            
            function AnalyticsMerge() {
                var Item = StartData[Iter];
                if (Item.IsXML) {
                    //Object.merge
                    console.log('III Item.Deployed >>>>\n\n'+Item.Deployed);

                    console.log('######### Item.LastComponentHistoryChangedBy == localUser ##########');
                    console.log(Item.LastComponentHistoryChangedBy == localUser);
                    console.log(Item.LastComponentHistoryChangedBy);
                    console.log(localUser);
                    console.log('######### Item.LastComponentHistoryCRC32 == JSON.parse(Item.CRC32) ##########');
                    console.log(Item.LastComponentHistoryCRC32 == JSON.parse(Item.CRC32));
                    console.log(Item.LastComponentHistoryCRC32);
                    console.log(JSON.parse(Item.CRC32));
                    console.log('######### Item.LastComponentHistoryCRC32 == Item.DeployedComponentHistoryCRC32 ##########');
                    console.log(Item.LastComponentHistoryCRC32 == Item.DeployedComponentHistoryCRC32);

                    Item.DeployFile = decodeURIComponent( escape( Item.DeployFile ) );
                    Item.LastFile = decodeURIComponent( escape( Item.LastFile ) );
                    Item.MetaItemFile = decodeURIComponent( escape( Item.MetaItemFile ) );

                    Item.IsIdentical = false;
                    if (Item.Deployed == false || Item.DeployFile == null) {
                        if (Item.LastComponentHistoryCRC32 != null && Item.LastComponentHistoryCRC32 == JSON.parse(Item.CRC32)) {
                            Item.IsIdentical = true;
                            Item.CONFLICT = false;
                            Item.mergeFile = Item.MetaItemFile;
                        }
                        else {
                            if (Item.LastComponentHistoryCRC32 != null && Item.LastComponentHistoryChangedBy == localUser) {
                                Item.IsIdentical = false;
                                Item.CONFLICT = false;
                                Item.mergeFile = Item.MetaItemFile;
                            }
                            else {
                                Item.CONFLICT = true;
                            }
                        }
                        FinishData[Item.ItemId] = Item;
                        Iter++;
                        return getItemInfo();
                    }
                    else {
                        if (Item.DeployedComponentHistoryCRC32 != null && Item.LastComponentHistoryCRC32 != null && Item.LastComponentHistoryCRC32 == Item.DeployedComponentHistoryCRC32) {
                            Item.IsIdentical = true;
                            Item.CONFLICT = false;
                            Item.mergeFile = Item.MetaItemFile;
                        }
                        if (Item.DeployedComponentHistoryCRC32 != null && Item.DeployFile == Item.MetaItemFile) {
                            Item.CONFLICT = false;
                            Item.mergeFile = Item.LastFile;
                        }
                        if (Item.LastComponentHistoryCRC32 != null && Item.LastComponentHistoryChangedBy == localUser) {
                            Item.IsIdentical = false;
                            Item.CONFLICT = false;
                            Item.mergeFile = Item.LastFile;
                        }

                        FinishData[Item.ItemId] = Item;
                        Iter++;
                        return getItemInfo();
                    }
                    ////////////////// conflict //////////////
                    Item.CONFLICT = true;
                    FinishData[Item.ItemId] = Item;
                    Iter++;
                    return getItemInfo();
                    //////////////////////////////////////////

                    var x2js = new X2JS();
                    var LastFile = x2js.xml_str2json(Item.LastFile);
                    
                    var DeployFile = x2js.xml_str2json(Item.DeployFile);
                    var MetaItemFile;
                    
                    var customXML = getChildFileMap(Item.ComponentType, Item.MetaItemFile, Item.APIName);
                    if (customXML === undefined || customXML === null) {
                        MetaItemFile = x2js.xml_str2json(Item.MetaItemFile);
                    }
                    else {
                        MetaItemFile = x2js.xml_str2json(customXML);
                        Item.IsCustomXML = true;
                        Item.CustomXMLFile = customXML;
                    }
                    //console.log(customXML);
                    console.log('######### Merge Text ##########');
                    console.log('######### DeployFile ##########');
                    console.log(Item.DeployFile);
                    console.log('######### LastFile ##########');
                    console.log(Item.LastFile);
                    console.log('######### MetaItemFile ##########');
                    console.log(Item.MetaItemFile);

                    DiffMapper3Way.setCONFLICT(false);
                    var merge = DiffMapper3Way.map(DeployFile, LastFile, MetaItemFile);
                    if (DiffMapper3Way.getCONFLICT()) {
                        Item.CONFLICT = true;
                    }
                    else {
                        Item.CONFLICT = false;
                        Item.merge = merge;

                        var strMergeFile = x2js.json2xml_str(merge);
                        /*if (strMergeFile.indexOf('<?xml') > -1) {
                            Item.mergeFile = x2js.json2xml_str(merge);
                        }
                        else {
                            Item.mergeFile = '<?xml version="1.0" encoding="UTF-8"?>' + x2js.json2xml_str(merge);  
                        }*/
                        if (strMergeFile.indexOf('<?xml') > -1) {
                            Item.mergeFile = formatXmlDeleteTitle(x2js.json2xml_str(merge));
                            console.log('II>>>>>Item.mergeFile\n\n'+Item.mergeFile);
                            //Item.mergeFile = File;
                        }
                        else {
                            //Item.mergeFile = '<?xml version="1.0" encoding="UTF-8"?>' + File;
                            Item.mergeFile = x2js.json2xml_str(merge);
                        }

                        stringHttp = '<0>h</0><1>t</1><2>t</2><3>p</3><4>:</4><5>/</5><6>/</6><7>s</7><8>o</8><9>a</9><10>p</10><11>.</11><12>s</12><13>f</13><14>o</14><15>r</15><16>c</16><17>e</17><18>.</18><19>c</19><20>o</20><21>m</21><22>/</22><23>2</23><24>0</24><25>0</25><26>6</26><27>/</27><28>0</28><29>4</29><30>/</30><31>m</31><32>e</32><33>t</33><34>a</34><35>d</35><36>a</36><37>t</37><38>a</38>';
                        Item.mergeFile = Item.mergeFile.replace(stringHttp, "");

                        // Item.mergeFile = Item.mergeFile.replace(/<[0-9]*[0-9]*[0-9]>/g, "");
                        // Item.mergeFile = Item.mergeFile.replace(/<\/[0-9]*[0-9]*[0-9]>/g, "");
                        
                        // Item.mergeFile = Item.mergeFile.replace(/><\//g, ">\n<\/");
                        // Item.mergeFile = Item.mergeFile.replace(/></g, ">\n<");

                        Item.mergeFile = formatXmlParse(Item.mergeFile, '');
                        Item.mergeFile = Item.mergeFile.replace(/><\//g, ">\n<\/");
                        Item.mergeFile = Item.mergeFile.replace(/></g, ">\n<");
                        Item.mergeFile = Item.mergeFile.replace(/    /g, "");
                        
                        Item.mergeFile = formatXml(Item.mergeFile);
                        Item.mergeFile = formatXmldeleteEmptyTag('', Item.mergeFile);
                        Item.mergeFile = Item.mergeFile.replace(/\t/ig, '    ');

                        Item.mergeFile = '<?xml version="1.0" encoding="UTF-8"?>\n' + Item.mergeFile;
                    }

                    console.log('II beauty >>>>>Item.mergeFile\n\n'+Item.mergeFile);
                    FinishData[Item.ItemId] = Item;
                    
                }
                else {
                    //merge text file
                    var diffO = new diff_match_patch();
                    
                    console.log('######### Merge Text ##########');
                    console.log('######### DeployFile ##########');
                    console.log(Item.DeployFile);
                    console.log('######### LastFile ##########');
                    console.log(Item.LastFile);
                    console.log('######### MetaItemFile ##########');
                    console.log(Item.MetaItemFile);

                    // if (Item.Deployed == false || Item.DeployFile == '') {
                    //     //var patch2 = diffO.patch_make(Item.LastFile, Item.MetaItemFile);
                    //     Item.CONFLICT = true;
                    // }
                    // else {
                    //     var patch2 = diffO.patch_make(Item.DeployFile, Item.MetaItemFile);
                    //     var apply2 = diffO.patch_apply(patch2, Item.LastFile);
                    //     if (apply2[1].length > 0) {
                    //         for (var x = 0; x < apply2[1].length; x++) {
                    //             if (!apply2[1][x]) {
                    //                 Item.CONFLICT = true;
                    //             }
                    //         }
                    //     }
                    // }


                    // var apply2 = diffO.patch_apply(patch2, Item.LastFile);
                    // if (apply2[1].length > 0) {
                    //     for (var x = 0; x < apply2[1].length; x++) {
                    //         if (!apply2[1][x]) {
                    //             Item.CONFLICT = true;
                    //         }
                    //     }
                    // }

                    if (Item.Deployed == false || Item.DeployFile == '') {
                        if (Item.LastCRC32 != null && Item.LastCRC32 == JSON.parse(Item.CRC32)) {
                            Item.IsIdentical = true;
                            Item.CONFLICT = false;
                            Item.mergeFile = Item.MetaItemFile;
                        }
                        else {
                            if (Item.LastCRC32 != null && Item.LastComponentHistoryChangedBy == localUser) {
                                Item.IsIdentical = false;
                                Item.CONFLICT = false;
                                Item.mergeFile = Item.MetaItemFile;
                            }
                            else {
                                Item.CONFLICT = true;
                            }
                        }
                        
                        // var patch2 = diffO.patch_make(Item.LastFile, Item.MetaItemFile);
                        // var apply2 = diffO.patch_apply(patch2, Item.LastFile);
                        // if (apply2[1].length > 0) {
                        //     for (var x = 0; x < apply2[1].length; x++) {
                        //         if (!apply2[1][x]) {
                        //             Item.CONFLICT = true;
                        //         }
                        //     }
                        // }
                    }
                    else {
                        // console.log('######### Item.LastFile == Item.DeployFile ##########');
                        // console.log(Item.LastFile == Item.DeployFile);
                        // console.log(Item.LastFile);
                        // console.log(Item.DeployFile);
                        
                        // console.log('######### Item.DeployFile == MetaItemFile ##########');
                        // console.log(Item.DeployFile == Item.MetaItemFile);
                        // console.log(Item.DeployFile);
                        // console.log(Item.MetaItemFile);

                        // console.log('######### Item.LastComponentHistoryChangedBy == localUser ##########');
                        // console.log(Item.LastComponentHistoryChangedBy == localUser);
                        // console.log(Item.LastComponentHistoryChangedBy);
                        // console.log(localUser);

                        if (Item.LastComponentHistoryCRC32 != null && Item.LastFile == Item.DeployFile) {
                            Item.IsIdentical = true;
                            Item.CONFLICT = false;
                            Item.mergeFile = Item.MetaItemFile;
                        }
                        else{
                            if (Item.DeployFile == Item.MetaItemFile) {
                                Item.CONFLICT = false;
                                Item.mergeFile = Item.LastFile;
                            }
                            else {
                                if (Item.LastComponentHistoryChangedBy == localUser) {
                                    Item.IsIdentical = false;
                                    Item.CONFLICT = false;
                                    Item.mergeFile = Item.LastFile;
                                }
                                else {
                                    var patch2 = diffO.patch_make(Item.DeployFile, Item.MetaItemFile);
                                    var apply2 = diffO.patch_apply(patch2, Item.LastFile);

                                    var patch3 = diffO.patch_make(Item.LastFile, Item.MetaItemFile);
                                    var apply3 = diffO.patch_apply(patch3, Item.DeployFile);

                                    console.log('apply2[0] = apply2[1]' + (apply2[0] == apply2[1]));

                                    if (apply2[0] == apply3[0]) {
                                        /*if (apply2[1].length > 0) {
                                            for (var x = 0; x < apply2[1].length; x++) {
                                                if (!apply2[1][x]) {
                                                    Item.CONFLICT = true;
                                                }
                                            }
                                        }*/
                                        Item.CONFLICT = false;
                                    }
                                    else {
                                        Item.CONFLICT = true;
                                        /*if (apply2[1].length > 0) {
                                            for (var x = 0; x < apply2[1].length; x++) {
                                                if (!apply2[1][x]) {
                                                    Item.CONFLICT = true;
                                                }
                                            }
                                        }*/
                                    }

                                    if (!Item.CONFLICT) {
                                        Item.mergeFile = apply2[0]
                                        Item.CONFLICT = false;
                                    }
                                }
                            }
                        }
                    }
                    
                    /*if (!Item.CONFLICT) {
                        Item.mergeFile = apply2[0]
                        Item.CONFLICT = false;
                    }*/
                    
                    console.log('!! merge >>' + Item.mergeFile);
                    FinishData[Item.ItemId] = Item;
                }
                Iter++;
                getItemInfo();
            }
            
            
            var DiffMapper3Way = function() {
                var CONFLICT = false;
                return {
                    
                    VALUE_CREATED: 'created',
                    VALUE_UPDATED: 'updated',
                    VALUE_DELETED: 'deleted',
                    VALUE_UNCHANGED: 'unchanged',
                    getCONFLICT: function() {
                        return CONFLICT;
                    },
                    setCONFLICT: function(param) {
                        CONFLICT = param;
                    },
                    map: function(obj1, obj2, obj3) {
                        // obj1 Main Object
                        // obj2 Last Branch Object
                        // obj3 New Object
                        if (this.isFunction(obj1) || this.isFunction(obj2) || this.isFunction(obj3)) {
                            throw 'Invalid argument. Function given, object expected.';
                        }
                        var diff = {};
                        if (this.isValue(obj1) && this.isValue(obj2) && this.isValue(obj3)) {
                            return this.compareValues(obj1, obj2, obj3);
                        }
                        else {
                            /*console.log('FieldObj1-');
                            console.log(obj1);
                            console.log(this.getKey(obj1));
                            console.log(this.isObject(obj1));
                            console.log('FieldObj2-');
                            console.log(obj2);
                            console.log(this.getKey(obj2));
                            console.log(this.isObject(obj2));
                            console.log('FieldObj3-');
                            console.log(obj3);
                            console.log(this.getKey(obj3));
                            console.log(this.isObject(obj3));*/
                            if (this.isObject(obj1) || this.isObject(obj2) || this.isObject(obj3)) {
                                var obj1Value = undefined;
                                var obj2Value = undefined;
                                var obj3Value = undefined;
                                if (!this.isUndefined(obj1)) {
                                    for (var key in obj1) {
                                        if (this.isFunction(obj1[key])) {
                                            continue;
                                        }
                                        if (!this.isUndefined(obj2) && 'undefined' != typeof(obj2[key])) {
                                            obj2Value = obj2[key];
                                        }
                                        if (!this.isUndefined(obj3) && 'undefined' != typeof(obj3[key])) {
                                            obj3Value = obj3[key];
                                        }
                                        diff[key] = this.map(obj1[key], obj2Value, obj3Value);
                                    }
                                }
                                if (!this.isUndefined(obj2)) {
                                    for (var key in obj2) {
                                        if (this.isFunction(obj2[key]) || 'undefined' != typeof(diff[key])) {
                                            continue;
                                        }
                                        if (!this.isUndefined(obj3) && 'undefined' != typeof(obj3[key])) {
                                            obj3Value = obj3[key];
                                        }
                                        diff[key] = this.map(undefined, obj2[key], obj3Value);
                                    }
                                }
                                if (!this.isUndefined(obj3)) {
                                    for (var key in obj3) {
                                        if (this.isFunction(obj3[key]) || 'undefined' != typeof(diff[key])) {
                                            continue;
                                        }
                                        diff[key] = this.map(undefined, undefined, obj3[key]);
                                    }
                                }
                            }
                            if (this.isArray(obj1) || this.isArray(obj2) || this.isArray(obj3)) {
                                console.log('ValueObj1-');
                                console.log(this.isValue(obj1));
                                console.log(this.isObject(obj1));
                                console.log('ValueObj2-');
                                console.log(this.isValue(obj2));
                                console.log(this.isObject(obj2));
                                console.log('ValueObj3-');
                                console.log(this.isValue(obj3));
                                console.log(this.isObject(obj3));

                                diff = [];
                                obj1 = this.isUndefined(obj1) ? [] : obj1;
                                obj2 = this.isUndefined(obj2) ? [] : obj2;
                                obj3 = this.isUndefined(obj3) ? [] : obj3;
                                if (this.isValue(obj1) || this.isObject(obj1)) {
                                    var temp = obj1;
                                    obj1 = [];
                                    obj1.push(temp);
                                }
                                if (this.isValue(obj2) || this.isObject(obj2)) {
                                    var temp = obj2;
                                    obj2 = [];
                                    obj2.push(temp);
                                }
                                if (this.isValue(obj3) || this.isObject(obj3)) {
                                    var temp = obj3;
                                    obj3 = [];
                                    obj3.push(temp);
                                }
                                if (this.isArray(obj1) && this.isArray(obj2) && this.isArray(obj3)) {
                                    if (this.isObject(obj1[0]) || this.isObject(obj2[0]) || this.isObject(obj3[0])) {
                                        var KeyName = null;

                                        console.log('obj1-');
                                        console.log(this.isObject(obj1[0]));
                                        console.log('obj2-');
                                        console.log(this.isObject(obj2[0]));
                                        console.log('obj3-');
                                        console.log(this.isObject(obj3[0]));
                                        if (obj1.length >= obj2.length && obj1.length >= obj3.length) {
                                            KeyName = this.getKey(obj1);
                                            console.log('keyName1-' + KeyName);
                                        }
                                        else if (obj2.length >= obj1.length && obj2.length >= obj3.length) {
                                            KeyName = this.getKey(obj2);
                                            console.log('keyName2-' + KeyName);
                                        }
                                        else if (obj3.length >= obj1.length && obj3.length >= obj2.length) {
                                            KeyName = this.getKey(obj3);
                                            console.log('keyName3-' + KeyName);
                                        }
                                        console.log('keyName' + KeyName);
                                        if (KeyName != null) {
                                            var obj1Map = {};
                                            var obj1KeyList = [];
                                            var obj2Map = {};
                                            var obj2KeyList = [];
                                            var obj3Map = {};
                                            var obj3KeyList = [];
                                            for (var key in obj1) {
                                                var objQ = obj1[key];
                                                obj1Map[objQ[KeyName]] = objQ;
                                                obj1KeyList.push(objQ[KeyName]);
                                            }
                                            for (var key in obj2) {
                                                var objQ = obj2[key];
                                                obj2Map[objQ[KeyName]] = objQ;
                                                obj2KeyList.push(objQ[KeyName]);
                                            }
                                            for (var key in obj3) {
                                                var objQ = obj3[key];
                                                obj3Map[objQ[KeyName]] = objQ;
                                                obj3KeyList.push(objQ[KeyName]);
                                            }
                                            console.log('ValueObj1-');
                                            console.log(obj1Map);
                                            console.log(obj1KeyList);
                                            console.log('ValueObj2-');
                                            console.log(obj2Map);
                                            console.log(obj2KeyList);
                                            console.log('ValueObj3-');
                                            console.log(obj3Map);
                                            console.log(obj3KeyList);
                                            for (var key in obj3) {
                                                if (this.isFunction(obj3[key])) {
                                                    continue;
                                                }
                                                var newObj = obj3[key];
                                                var value = newObj[KeyName];
                                                var oldObj1 = obj1Map[value];
                                                var oldObj2 = obj2Map[value];
                                                console.log(oldObj1);
                                                console.log(oldObj2);
                                                diff.push(this.map(oldObj1, oldObj2, newObj));
                                            }
                                            for (var key in obj2) {
                                                if (this.isFunction(obj2[key])) {
                                                   continue;
                                                }
                                                var newObj = obj2[key];
                                                var value = newObj[KeyName];
                                                if ($.inArray(value, obj3KeyList) == -1 && $.inArray(value, obj1KeyList) > -1) {
                                                    var oldObj1 = obj1Map[value];
                                                    diff.push(this.map(oldObj1, newObj, undefined));
                                                }
                                                else if ($.inArray(value, obj3KeyList) == -1 && $.inArray(value, obj1KeyList) == -1) {
                                                    diff.push(this.map(undefined, newObj, undefined));
                                                }
                                            }
                                            for (var key in obj1) {
                                                if (this.isFunction(obj1[key])) {
                                                   continue;
                                                }
                                                var newObj = obj1[key];
                                                var value = newObj[KeyName];
                                                if ($.inArray(value, obj2KeyList) == -1 && $.inArray(value, obj3KeyList) == -1) {
                                                    diff.push(this.map(newObj, undefined, undefined));
                                                }
                                            }
                                        }
                                        else {
                                            //console.log('1');
                                            var firstObj;
                                            if (this.isObject(obj1[0])) {
                                                firstObj = obj1[0];
                                            }
                                            else if (this.isObject(obj2[0])) {
                                                firstObj = obj2[0];
                                            }
                                            else if (this.isObject(obj3[0])) {
                                                firstObj = obj3[0];
                                            }
                                            var CheckMerge = true;
                                            for (var key in firstObj) {
                                                if (!this.isValue(firstObj[key])) {
                                                    CheckMerge = false;
                                                    break;
                                                }
                                            }
                                            if (CheckMerge) {
                                                var obj3LIST = [];
                                                var obj2LIST = [];
                                                var obj1LIST = [];
                                                var obj3MAP = {};
                                                var obj2MAP = {};
                                                var obj1MAP = {};
                                                for (var key in obj3) {
                                                    obj3LIST.push(angular.toJson(obj3[key]));
                                                    obj3MAP[key] = angular.toJson(obj3[key]);
                                                }
                                                for (var key in obj2) {
                                                    obj2LIST.push(angular.toJson(obj2[key]));
                                                    obj2MAP[key] = angular.toJson(obj2[key]);
                                                }
                                                for (var key in obj1) {
                                                    obj1LIST.push(angular.toJson(obj1[key]));
                                                    obj1MAP[key] = angular.toJson(obj1[key]);
                                                }
                                                
                                                for (var key in obj3) {
                                                    if (this.isFunction(obj3[key])) {
                                                        continue;
                                                    }
                                                    if ($.inArray(obj3MAP[key], obj1LIST) > -1 && $.inArray(obj3MAP[key], obj2LIST) > -1) {
                                                        diff.push(this.map(obj3[key], obj3[key], obj3[key]));
                                                    }
                                                    else if ($.inArray(obj3MAP[key], obj1LIST) == -1 && $.inArray(obj3MAP[key], obj2LIST) > -1) {
                                                        diff.push(this.map(undefined, obj3[key], obj3[key]));
                                                    }
                                                    else if ($.inArray(obj3MAP[key], obj1LIST) > -1 && $.inArray(obj3MAP[key], obj2LIST) == -1) {
                                                        diff.push(this.map(obj3[key], undefined , obj3[key]));
                                                    }
                                                    else if ($.inArray(obj3MAP[key], obj1LIST) == -1 && $.inArray(obj3MAP[key], obj2LIST) == -1) {
                                                        diff.push(this.map(undefined, undefined , obj3[key]));
                                                    }
                                                    
                                                }
                                                
                                                for (var key in obj2) {
                                                    if (this.isFunction(obj2[key])) {
                                                        continue;
                                                    }
                                                    if ($.inArray(obj2MAP[key], obj3LIST) == -1 && $.inArray(obj2MAP[key], obj1LIST) > -1) {
                                                        diff.push(this.map(obj2[key], obj2[key], undefined));
                                                    }
                                                    else if ($.inArray(obj2MAP[key], obj3LIST) == -1 && $.inArray(obj2MAP[key], obj1LIST) == -1) {
                                                        diff.push(this.map(undefined, obj2[key], undefined));
                                                    }
                                                         
                                                }
                                                
                                                for (var key in obj1) {
                                                    if (this.isFunction(obj1[key])) {
                                                        continue;
                                                    }
                                                    if ($.inArray(obj1MAP[key], obj3LIST) == -1 && $.inArray(obj1MAP[key], obj2LIST) == -1) {
                                                        diff.push(this.map(obj1[key], undefined, undefined));
                                                    }
                                                }
                                            }
                                            else {
                                                if (obj1.length >= obj2.length && obj1.length >= obj3.length) {
                                                    for (var key in obj1) {
                                                        if (this.isFunction(obj1[key])) {
                                                            continue;
                                                        }
                                                        diff.push(this.map(obj1[key], obj2[key], obj3[key]));
                                                    }
                                                }
                                                else if (obj2.length >= obj1.length && obj2.length >= obj3.length) {
                                                    for (var key in obj2) {
                                                        if (this.isFunction(obj2[key])) {
                                                            continue;
                                                        }
                                                        diff.push(this.map(obj1[key], obj2[key], obj3[key]));
                                                    }
                                                }
                                                else {
                                                    for (var key in obj3) {
                                                        if (this.isFunction(obj3[key])) {
                                                            continue;
                                                        }
                                                        diff.push(this.map(obj1[key], obj2[key], obj3[key]));
                                                    }
                                                }
                                            }
                                            
                                        }
                                    }
                                    else {
                                        if (this.isValue(obj1[0]) || this.isValue(obj2[0]) || this.isValue(obj3[0])) {
                                            console.log('Value1-');
                                            console.log(this.isValue(obj1[0]));
                                            console.log('Value2-');
                                            console.log(this.isValue(obj2[0]));
                                            console.log('Value3-');
                                            console.log(this.isValue(obj3[0]));
                                            
                                            for (var key in obj3) {
                                                if (this.isFunction(obj3[key])) {
                                                   continue;
                                                }
                                                var value = obj3[key];
                                                if ($.inArray(value, obj1) > -1 && $.inArray(value, obj2) > -1) {
                                                    diff.push(this.map(value, value, value));
                                                }
                                                else if ($.inArray(value, obj1) == -1 && $.inArray(value, obj2) > -1) {
                                                    diff.push(this.map(undefined, value, value));
                                                }
                                                else if ($.inArray(value, obj1) > -1 && $.inArray(value, obj2) == -1) {
                                                    diff.push(this.map(value, undefined, value));
                                                }
                                                else if ($.inArray(value, obj1) == -1 && $.inArray(value, obj2) == -1) {
                                                    diff.push(this.map(undefined, undefined, value));
                                                }
                                            }
                                            for (var key in obj2) {
                                                if (this.isFunction(obj2[key])) {
                                                   continue;
                                                }
                                                var value = obj2[key];
                                                if ($.inArray(value, obj3) == -1 && $.inArray(value, obj1) > -1) {
                                                    diff.push(this.map(value, value, undefined));
                                                }
                                                else if ($.inArray(value, obj3) == -1 && $.inArray(value, obj1) == -1) {
                                                    diff.push(this.map(undefined, value, undefined));
                                                }
                                            }
                                            for (var key in obj1) {
                                                if (this.isFunction(obj1[key])) {
                                                   continue;
                                                }
                                                var value = obj1[key];
                                                if ($.inArray(value, obj3) == -1 && $.inArray(value, obj2) == -1) {
                                                    diff.push(this.map(value, undefined, undefined));
                                                }
                                            }
                                        }
                                        else {
                                            if (obj1.length >= obj2.length && obj1.length >= obj3.length) {
                                                for (var key in obj1) {
                                                    if (this.isFunction(obj1[key])) {
                                                        continue;
                                                    }
                                                    diff.push(this.map(obj1[key], obj2[key], obj3[key]));
                                                }
                                            }
                                            else if (obj2.length >= obj1.length && obj2.length >= obj3.length) {
                                                for (var key in obj2) {
                                                    if (this.isFunction(obj2[key])) {
                                                        continue;
                                                    }
                                                    diff.push(this.map(obj1[key], obj2[key], obj3[key]));
                                                }
                                            }
                                            else {
                                                for (var key in obj3) {
                                                    if (this.isFunction(obj3[key])) {
                                                        continue;
                                                    }
                                                    diff.push(this.map(obj1[key], obj2[key], obj3[key]));
                                                }
                                            }
                                        }
                                        
                                    }
                                    
                                }
                                // if (this.isArray(obj1) && this.isArray(obj2) && this.isArray(obj3)) {
                                //     if (this.isValue(obj1[0]) || this.isValue(obj2[0]) || this.isValue(obj3[0])) {
                                //      console.log('obj1-');
                                      //   console.log(this.isValue(obj1[0]));
                                      //   console.log('obj2-');
                                      //   console.log(this.isValue(obj2[0]));
                                      //   console.log('obj3-');
                                      //   console.log(this.isValue(obj3[0]));
                                        
                                //         for (var key in obj3) {
                                //             if (this.isFunction(obj3[key])) {
                                //                continue;
                                //             }
                                //             var value = obj3[key];
                                //             if ($.inArray(value, obj1) > -1 && $.inArray(value, obj2) > -1) {
                                //                 diff.push(this.map(value, value, value));
                                //             }
                                //             else if ($.inArray(value, obj1) == -1 && $.inArray(value, obj2) > -1) {
                                //                 diff.push(this.map(undefined, value, value));
                                //             }
                                //             else if ($.inArray(value, obj1) > -1 && $.inArray(value, obj2) == -1) {
                                //                 diff.push(this.map(value, undefined, value));
                                //             }
                                //             else if ($.inArray(value, obj1) == -1 && $.inArray(value, obj2) == -1) {
                                //                 diff.push(this.map(undefined, undefined, value));
                                //             }
                                //         }
                                //         for (var key in obj2) {
                                //             if (this.isFunction(obj2[key])) {
                                //                continue;
                                //             }
                                //             var value = obj2[key];
                                //             if ($.inArray(value, obj3) == -1 && $.inArray(value, obj1) > -1) {
                                //                 diff.push(this.map(value, value, undefined));
                                //             }
                                //             else if ($.inArray(value, obj3) == -1 && $.inArray(value, obj1) == -1) {
                                //                 diff.push(this.map(undefined, value, undefined));
                                //             }
                                //         }
                                //         for (var key in obj1) {
                                //             if (this.isFunction(obj1[key])) {
                                //                continue;
                                //             }
                                //             var value = obj1[key];
                                //             if ($.inArray(value, obj3) == -1 && $.inArray(value, obj2) == -1) {
                                //                 diff.push(this.map(value, undefined, undefined));
                                //             }
                                //         }
                                //     }
                                //     else if (this.isObject(obj1[0]) || this.isObject(obj2[0]) || this.isObject(obj3[0])) {
                                //         var KeyName = null;

                                //         console.log('obj1-');
                                      //   console.log(this.isObject(obj1[0]));
                                      //   console.log('obj2-');
                                      //   console.log(this.isObject(obj2[0]));
                                      //   console.log('obj3-');
                                      //   console.log(this.isObject(obj3[0]));
                                //         if (obj1.length >= obj2.length && obj1.length >= obj3.length) {
                                //             KeyName = this.getKey(obj1);
                                //             console.log('keyName1-' + KeyName);
                                //         }
                                //         else if (obj2.length >= obj1.length && obj2.length >= obj3.length) {
                                //             KeyName = this.getKey(obj2);
                                //             console.log('keyName2-' + KeyName);
                                //         }
                                //         else if (obj3.length >= obj1.length && obj3.length >= obj2.length) {
                                //             KeyName = this.getKey(obj3);
                                //             console.log('keyName3-' + KeyName);
                                //         }
                                //         console.log('keyName' + KeyName);
                                //         if (KeyName != null) {
                                //             var obj1Map = {};
                                //             var obj1KeyList = [];
                                //             var obj2Map = {};
                                //             var obj2KeyList = [];
                                //             var obj3Map = {};
                                //             var obj3KeyList = [];
                                //             for (var key in obj1) {
                                //                 var objQ = obj1[key];
                                //                 obj1Map[objQ[KeyName]] = objQ;
                                //                 obj1KeyList.push(objQ[KeyName]);
                                //             }
                                //             for (var key in obj2) {
                                //                 var objQ = obj2[key];
                                //                 obj2Map[objQ[KeyName]] = objQ;
                                //                 obj2KeyList.push(objQ[KeyName]);
                                //             }
                                //             for (var key in obj3) {
                                //                 var objQ = obj3[key];
                                //                 obj3Map[objQ[KeyName]] = objQ;
                                //                 obj3KeyList.push(objQ[KeyName]);
                                //             }
                                //             for (var key in obj3) {
                                //                 if (this.isFunction(obj3[key])) {
                                //                     continue;
                                //                 }
                                //                 var newObj = obj3[key];
                                //                 var value = newObj[KeyName];
                                //                 var oldObj1 = obj1Map[value];
                                //                 var oldObj2 = obj2Map[value];
                                //                 diff.push(this.map(oldObj1, oldObj2, newObj));
                                //             }
                                //             for (var key in obj2) {
                                //                 if (this.isFunction(obj2[key])) {
                                //                    continue;
                                //                 }
                                //                 var newObj = obj2[key];
                                //                 var value = newObj[KeyName];
                                //                 if ($.inArray(value, obj3KeyList) == -1 && $.inArray(value, obj1KeyList) > -1) {
                                //                     var oldObj1 = obj1Map[value];
                                //                     diff.push(this.map(oldObj1, newObj, undefined));
                                //                 }
                                //                 else if ($.inArray(value, obj3KeyList) == -1 && $.inArray(value, obj1KeyList) == -1) {
                                //                     diff.push(this.map(undefined, newObj, undefined));
                                //                 }
                                //             }
                                //             for (var key in obj1) {
                                //                 if (this.isFunction(obj1[key])) {
                                //                    continue;
                                //                 }
                                //                 var newObj = obj1[key];
                                //                 var value = newObj[KeyName];
                                //                 if ($.inArray(value, obj2KeyList) == -1 && $.inArray(value, obj3KeyList) == -1) {
                                //                     diff.push(this.map(newObj, undefined, undefined));
                                //                 }
                                //             }
                                //         }
                                //         else {
                                //             //console.log('1');
                                //             var firstObj;
                                //             if (this.isObject(obj1[0])) {
                                //                 firstObj = obj1[0];
                                //             }
                                //             else if (this.isObject(obj2[0])) {
                                //                 firstObj = obj2[0];
                                //             }
                                //             else if (this.isObject(obj3[0])) {
                                //                 firstObj = obj3[0];
                                //             }
                                //             var CheckMerge = true;
                                //             for (var key in firstObj) {
                                //                 if (!this.isValue(firstObj[key])) {
                                //                     CheckMerge = false;
                                //                     break;
                                //                 }
                                //             }
                                //             if (CheckMerge) {
                                //                 var obj3LIST = [];
                                //                 var obj2LIST = [];
                                //                 var obj1LIST = [];
                                //                 var obj3MAP = {};
                                //                 var obj2MAP = {};
                                //                 var obj1MAP = {};
                                //                 for (var key in obj3) {
                                //                     obj3LIST.push(angular.toJson(obj3[key]));
                                //                     obj3MAP[key] = angular.toJson(obj3[key]);
                                //                 }
                                //                 for (var key in obj2) {
                                //                     obj2LIST.push(angular.toJson(obj2[key]));
                                //                     obj2MAP[key] = angular.toJson(obj2[key]);
                                //                 }
                                //                 for (var key in obj1) {
                                //                     obj1LIST.push(angular.toJson(obj1[key]));
                                //                     obj1MAP[key] = angular.toJson(obj1[key]);
                                //                 }
                                                
                                //                 for (var key in obj3) {
                                //                     if (this.isFunction(obj3[key])) {
                                //                         continue;
                                //                     }
                                //                     if ($.inArray(obj3MAP[key], obj1LIST) > -1 && $.inArray(obj3MAP[key], obj2LIST) > -1) {
                                //                         diff.push(this.map(obj3[key], obj3[key], obj3[key]));
                                //                     }
                                //                     else if ($.inArray(obj3MAP[key], obj1LIST) == -1 && $.inArray(obj3MAP[key], obj2LIST) > -1) {
                                //                         diff.push(this.map(undefined, obj3[key], obj3[key]));
                                //                     }
                                //                     else if ($.inArray(obj3MAP[key], obj1LIST) > -1 && $.inArray(obj3MAP[key], obj2LIST) == -1) {
                                //                         diff.push(this.map(obj3[key], undefined , obj3[key]));
                                //                     }
                                //                     else if ($.inArray(obj3MAP[key], obj1LIST) == -1 && $.inArray(obj3MAP[key], obj2LIST) == -1) {
                                //                         diff.push(this.map(undefined, undefined , obj3[key]));
                                //                     }
                                                    
                                //                 }
                                                
                                //                 for (var key in obj2) {
                                //                     if (this.isFunction(obj2[key])) {
                                //                         continue;
                                //                     }
                                //                     if ($.inArray(obj2MAP[key], obj3LIST) == -1 && $.inArray(obj2MAP[key], obj1LIST) > -1) {
                                //                         diff.push(this.map(obj2[key], obj2[key], undefined));
                                //                     }
                                //                     else if ($.inArray(obj2MAP[key], obj3LIST) == -1 && $.inArray(obj2MAP[key], obj1LIST) == -1) {
                                //                         diff.push(this.map(undefined, obj2[key], undefined));
                                //                     }
                                                         
                                //                 }
                                                
                                //                 for (var key in obj1) {
                                //                     if (this.isFunction(obj1[key])) {
                                //                         continue;
                                //                     }
                                //                     if ($.inArray(obj1MAP[key], obj3LIST) == -1 && $.inArray(obj1MAP[key], obj2LIST) == -1) {
                                //                         diff.push(this.map(obj1[key], undefined, undefined));
                                //                     }
                                //                 }
                                //             }
                                //             else {
                                //                 if (obj1.length >= obj2.length && obj1.length >= obj3.length) {
                                //                     for (var key in obj1) {
                                //                         if (this.isFunction(obj1[key])) {
                                //                             continue;
                                //                         }
                                //                         diff.push(this.map(obj1[key], obj2[key], obj3[key]));
                                //                     }
                                //                 }
                                //                 else if (obj2.length >= obj1.length && obj2.length >= obj3.length) {
                                //                     for (var key in obj2) {
                                //                         if (this.isFunction(obj2[key])) {
                                //                             continue;
                                //                         }
                                //                         diff.push(this.map(obj1[key], obj2[key], obj3[key]));
                                //                     }
                                //                 }
                                //                 else {
                                //                     for (var key in obj3) {
                                //                         if (this.isFunction(obj3[key])) {
                                //                             continue;
                                //                         }
                                //                         diff.push(this.map(obj1[key], obj2[key], obj3[key]));
                                //                     }
                                //                 }
                                //             }
                                            
                                //         }
                                //     }
                                //     else {
                                //         if (obj1.length >= obj2.length && obj1.length >= obj3.length) {
                                //             for (var key in obj1) {
                                //                 if (this.isFunction(obj1[key])) {
                                //                     continue;
                                //                 }
                                //                 diff.push(this.map(obj1[key], obj2[key], obj3[key]));
                                //             }
                                //         }
                                //         else if (obj2.length >= obj1.length && obj2.length >= obj3.length) {
                                //             for (var key in obj2) {
                                //                 if (this.isFunction(obj2[key])) {
                                //                     continue;
                                //                 }
                                //                 diff.push(this.map(obj1[key], obj2[key], obj3[key]));
                                //             }
                                //         }
                                //         else {
                                //             for (var key in obj3) {
                                //                 if (this.isFunction(obj3[key])) {
                                //                     continue;
                                //                 }
                                //                 diff.push(this.map(obj1[key], obj2[key], obj3[key]));
                                //             }
                                //         }
                                        
                                        
                                //     }
                                    
                                // }
                            }
                            
                            
                            
                        }
                        return diff;
            
                    },
                    compareValues: function(value1, value2, value3) {
                        var returnValue;
                        //GET DIFF1
                        var diff1;
                        if (value1 === value2) {
                            diff1 = this.VALUE_UNCHANGED;
                        }
                        else if ('undefined' == typeof(value1)) {
                            diff1 = this.VALUE_CREATED;
                        }
                        else if ('undefined' == typeof(value2)) {
                            diff1 = this.VALUE_DELETED;
                        }
                        else {
                            diff1 = this.VALUE_UPDATED;
                        }
                        
                        
                        //GET DIFF2
                        var diff2;
                        if (value1 === value3) {
                            diff2 = this.VALUE_UNCHANGED;
                        }
                        else if ('undefined' == typeof(value1)) {
                            diff2 = this.VALUE_CREATED;
                        }
                        else if ('undefined' == typeof(value3)) {
                            diff2 = this.VALUE_DELETED;
                        }
                        else {
                            diff2 = this.VALUE_UPDATED;
                        }
                        
                        //Analise DIFF
                        //VALUE_DELETED
                        if (diff1 == this.VALUE_DELETED && diff2 == this.VALUE_DELETED) {
                            returnValue = null;
                        }
                        if (diff1 == this.VALUE_DELETED && diff2 == this.VALUE_UNCHANGED) {
                            returnValue = null;
                        }
                        if (diff1 == this.VALUE_DELETED && diff2 == this.VALUE_UPDATED) {
                            returnValue = null;
                            console.log(value1);
                            console.log(value2);
                            console.log(value3);
                            CONFLICT = true;
                        }
                        if (diff1 == this.VALUE_DELETED && diff2 == this.VALUE_CREATED) {
                            returnValue = null;
                            console.log(value1);
                            console.log(value2);
                            console.log(value3);
                            CONFLICT = true;
                        }
                        
                        //VALUE_UNCHANGED
                        if (diff1 == this.VALUE_UNCHANGED && diff2 == this.VALUE_DELETED) {
                            returnValue = null;
                        }
                        if (diff1 == this.VALUE_UNCHANGED && diff2 == this.VALUE_UNCHANGED) {
                            returnValue = value3;
                        }
                        if (diff1 == this.VALUE_UNCHANGED && diff2 == this.VALUE_UPDATED) {
                            returnValue = value3;
                        }
                        if (diff1 == this.VALUE_UNCHANGED && diff2 == this.VALUE_CREATED) {
                            returnValue = value3;
                        }
                        
                        //VALUE_UPDATED
                        if (diff1 == this.VALUE_UPDATED && diff2 == this.VALUE_DELETED) {
                            returnValue = value2;
                            console.log(value1);
                            console.log(value2);
                            console.log(value3);
                            CONFLICT = true;
                        }
                        if (diff1 == this.VALUE_UPDATED && diff2 == this.VALUE_UNCHANGED) {
                            returnValue = value2;
                        }
                        if (diff1 == this.VALUE_UPDATED && diff2 == this.VALUE_UPDATED) {
                            console.log('VALUE_UPDATED');
                            console.log(value2);
                            console.log(value3);
                            if (value2 == value3) {
                                returnValue = value3;
                            }
                            else {
                                returnValue = value2;
                                console.log(value1);
                            console.log(value2);
                            console.log(value3);
                                CONFLICT = true;
                            }
                            console.log(CONFLICT);
                        }
                        if (diff1 == this.VALUE_UPDATED && diff2 == this.VALUE_CREATED) {
                            returnValue = null;
                            console.log(value1);
                            console.log(value2);
                            console.log(value3);
                            CONFLICT = true;
                        }
                        
                        //VALUE_CREATED
                        if (diff1 == this.VALUE_CREATED && diff2 == this.VALUE_DELETED) {
                            returnValue = null;
                            console.log(value1);
                            console.log(value2);
                            console.log(value3);
                            CONFLICT = true;
                        }
                        if (diff1 == this.VALUE_CREATED && diff2 == this.VALUE_UNCHANGED) {
                            returnValue = value2;
                            
                        }
                        if (diff1 == this.VALUE_CREATED && diff2 == this.VALUE_UPDATED) {
                            returnValue = null;
                            console.log(value1);
                            console.log(value2);
                            console.log(value3);
                            CONFLICT = true;
                        }
                        if (diff1 == this.VALUE_CREATED && diff2 == this.VALUE_CREATED) {
                            
                            if (value2 == value3) {
                                returnValue = value3;
                            }
                            else {
                                returnValue = value2;
                                console.log(value1);
                            console.log(value2);
                            console.log(value3);
                                CONFLICT = true;
                            }
                        }
                        
                        return returnValue;
                    },
                    getKey: function(list) {
                        var firstObject = list[0];
                        var ListKeyName = [];
                        var MapKeyName = {};
                        var returnvalue = null;
                        for (var key in firstObject) {
                            if (this.isValue(firstObject[key])) {
                                ListKeyName.push(key);
                                MapKeyName[key] = [];
                            }
                        }
                        if (ListKeyName.length == 0) {
                            return null;
                        }
                        for (var key in list) {
                            var object = list[key];
                            for (var key2 in MapKeyName) {
                                var value = object[key2]
                                if ($.inArray(value, MapKeyName[key2]) > -1) {
                                     delete MapKeyName[key2];
                                }
                                else {
                                    MapKeyName[key2].push(value);
                                }
                            }
                            
                        }
                        var index = 0;
                        for (var key3 in MapKeyName) {
                             index++;
                             if (index == 1) {
                                returnvalue = key3;
                             }
                        }
                        if (index == 0) {
                            returnvalue = null;
                        }
                        
                        return returnvalue;
                        
                    },
                    isFunction: function(obj) {
                        return {}.toString.apply(obj) === '[object Function]';
                    },
                    isArray: function(obj) {
                        return {}.toString.apply(obj) === '[object Array]';
                    },
                    isObject: function(obj) {
                        return {}.toString.apply(obj) === '[object Object]';
                    },
                    isValue: function(obj) {
                        return !this.isObject(obj) && !this.isArray(obj);
                    },
                    isUndefined: function(obj) {
                        return obj === undefined || obj === null;
                    }
                }
            }();
            
            
            
            return {
                startMerge: function(data) {
                    StartData = data;
                    START = true;
                    FINSH = false;
                    _startMerge();
                },
                getStatus: function() {
                    var retobj = {};
                    var list = {};
                    for(var key in FinishData) {
                            if ({}.toString.apply(FinishData[key]) === '[object Function]') {
                                continue;
                            }
                        
                            list[key] = FinishData[key].CONFLICT;
                    }
                    
                    retobj.Finish = FINSH
                    retobj.items = list;
                    return retobj;
                },
                getMergeFile: function(ItemId) {
                    return FinishData[ItemId];
                },
                setMergeFile: function(ItemId, File) {
                    var Item = FinishData[ItemId];

                    if (Item.IsXML) {
                        if (File.indexOf('<?xml') > -1) {
                            Item.mergeFile = formatXmlDeleteTitle(File);
                            console.log('II>>>>>Item.mergeFile\n\n'+Item.mergeFile);
                            //Item.mergeFile = File;
                        }
                        else {
                            //Item.mergeFile = '<?xml version="1.0" encoding="UTF-8"?>' + File;
                            Item.mergeFile = File;
                        }
                        //Item.mergeFile = Item.mergeFile.replace(/<[0-9]*[0-9]*[0-9]>/g, "");
                        //Item.mergeFile = Item.mergeFile.replace(/<\/[0-9]*[0-9]*[0-9]>/g, "");

                        //Item.mergeFile = Item.mergeFile.replace(/><\//g, ">\n<\/");
                        //Item.mergeFile = Item.mergeFile.replace(/></g, ">\n<");

                        /*var tempMerge = formatXmlParse(Item.mergeFile, '');
                        tempMerge = tempMerge.replace(/><\//g, ">\n<\/");
                        tempMerge = tempMerge.replace(/></g, ">\n<");
                        console.log('II>>>>>tempMerge\n\n'+tempMerge);*/

                        Item.mergeFile = formatXmlParse(Item.mergeFile, '');
                        //Item.mergeFile = Item.mergeFile;

                        if (openMainTag != '' && closeMainTag != '') {
                            Item.mergeFile = Item.mergeFile.replace('<xml>', openMainTag);
                            Item.mergeFile = Item.mergeFile.replace('</xml>', closeMainTag);
                        }
                        Item.mergeFile = Item.mergeFile.replace(/><\//g, ">\n<\/");
                        Item.mergeFile = Item.mergeFile.replace(/></g, ">\n<");
                        Item.mergeFile = Item.mergeFile.replace(/    /g, "");

                        //Item.mergeFile = formatXmlParse(Item.mergeFile, '');
                        
                        Item.mergeFile = formatXml(Item.mergeFile);
                        Item.mergeFile = formatXmldeleteEmptyTag('', Item.mergeFile);
                        Item.mergeFile = Item.mergeFile.replace(/\t/ig, '    ');
                    }
                    else {
                        Item.mergeFile = File;
                    }
                    //Item.mergeFile = '<?xml version="1.0" encoding="UTF-8"?>' + File;
                    //Item.mergeFile = File;
                    Item.CONFLICT = false;
                    Item.IsManualMerge = true;
                    console.log('II>>>>>Item.mergeFileA\n\n'+Item.mergeFile);
                }
            }
        });

        myApp.$inject = ['$scope', '$filter'];

        myApp.controller("RepositoryController", function($scope, ngDialog, $base64, $compile, dataManager, $filter, MergeService, $interval, $timeout) {
            /*$timeout( function(){ $scope.Commit(); }, 3000);
            $timeout( function(){ $scope.reRenderSecondPage(); }, 10000);*/

            $scope.componentList = [];
            $scope.orderByColumn = 'changedOnLocal';
            $scope.isReverse = true;
            $scope.metaOffSet = 0;
            $scope.totalRecords = 0;
            $scope.staticLimit = 20;
            $scope.viewLimit = $scope.staticLimit;
            $scope.showFirstPageBlock = true;
            $scope.showSecondPageBlock = false;
            $scope.disableNextPrevious = false;
            var tempObj = {};
            tempObj['compName'] = 'Component Name';
            tempObj['compType'] = 'Component Type';
            tempObj['version'] = 'Version';
            tempObj['changedBy'] = 'Changed By';
            //tempObj['changedOn'] = 'Changed On';
            tempObj['changedOnLocal'] = 'Changed On';
            tempObj['committedBy'] = 'Committed By';
            //tempObj['committedOn'] = 'Committed On'; 
            tempObj['committedOnLocal'] = 'Committed On'; 
            $scope.fieldSet = tempObj;
            $scope.disableUpdateOrgButton = true;
            $scope.disableDownloadOrgButton = false;
            $scope.disableContinueUpdateButton = false;

            /*********************************************/
            $scope.componentListConflict = [];
            $scope.IsErrorNotBS = false;
            $scope.Start = false;
            //$scope.PageSelectItems = false;
            $scope.SELECTAll = true;
            $scope.groupedItems = [];
            $scope.itemsPerPage = 20;
            $scope.pagedItems = [];
            $scope.currentPage = 0;
            $scope.CommitStart = false;

            $scope.conflictMetaOffSet = 0;
            $scope.conflictViewLimit = $scope.staticLimit;
            $scope.conflictOrderByColumn = 'changedOnLocal';
            $scope.conflictIsReverse = true;
            $scope.conflictdisableNextPrevious = false;

            $scope.notConflictMetaOffSet = 0;
            $scope.notConflictViewLimit = $scope.staticLimit;
            $scope.notConflictOrderByColumn = 'changedOnLocal';
            $scope.notConflictIsReverse = true;
            $scope.notConflictdisableNextPrevious = false;

            $scope.FirstStepItems = [];         //**
            //$scope.GoodMergeItems = [];         //**

            function FortDATA(param) {
                param = $('<div/>').html(param).text();
                return angular.fromJson(param);
            }

            $scope.Commit = function() {
                console.log('Commit');

                dataManager.FirstStepMerge(jsonComponentListConflict).then(
                  function(data) {
                          var D = FortDATA(data)
                          $scope.FirstStepItems = D;
                          if (angular.isArray($scope.FirstStepItems)) {
                              var mergeDATA = [];
                              console.log('IIII e-'+data)
                              for (var x = 0; x < $scope.FirstStepItems.length ; x++) {
                                  if (!$scope.FirstStepItems[x].IsLastVersion  && $scope.FirstStepItems[x].LastComponentHistoryATID != null) {
                                      $scope.FirstStepItems[x].AutoMergeStart = true;
                                      mergeDATA.push($scope.FirstStepItems[x]);
                                  }
                                  if ($scope.FirstStepItems[x].IsLastVersion  && $scope.FirstStepItems[x].LastComponentHistoryCRC32 == $scope.FirstStepItems[x].DeployedComponentHistoryCRC32) {
                                        $scope.FirstStepItems[x].AutoMergeStart = true;
                                        mergeDATA.push($scope.FirstStepItems[x]);
                                    }
                              }
                              if (mergeDATA.length > 0) {
                                  MergeService.startMerge(mergeDATA);
                                  $scope.monitorTheProcess();
                                  
                              }
                              
                          }
                      },
                        function (error) {
                          showErrorMessage(error.message);
                      }
                );
          }

            var stop;
            $scope.monitorTheProcess = function() {
                stop = $interval(function() {
                    var status = MergeService.getStatus();
                    console.log(status);
                    if (status != null && status.Finish) {
                        statusInfo(status.items);
                        $scope.stopFight();
                    } else {
                        if (status != null && status.items != null) {
                            statusInfo(status.items);
                        }
                    }
                }, 500);
                
            }
            function statusInfo(param) {
                for (var x = 0; x < $scope.FirstStepItems.length ; x++) {
                    var item = $scope.FirstStepItems[x];
                    if (param[item.ItemId] != null) {
                        item.AutoMergeFinish = true;
                        item.AutoMergeStatus = param[item.ItemId];
                    }
                }
            }
            
            $scope.stopFight = function() {
              if (angular.isDefined(stop)) {
                $interval.cancel(stop);
                stop = undefined;
              }
            };

            $scope.OpenPopUpInfo = function(item) {
                $scope.PopUp = {};
                $scope.PopUp.Info = item;
                ngDialog.open({
                    template:  'templatePopUpInfoId',
                    className: 'ngdialog-theme-default InfoPopUp',
                    scope: $scope
                });
            }

            $scope.OpenPopUpResult = function(item) {
                
            }

            $scope.getMergeInfo = function(param) {
                //console.log('param'+param);
                
                var MergeInfo = MergeService.getMergeFile(param.ItemId);

                if (!MergeInfo.CONFLICT && MergeInfo.LastComponentHistoryId != null && (MergeInfo.DeployedComponentHistoryId!= null || MergeInfo.IsIdentical || MergeInfo.IsManualMerge)) {
                    $scope.PopUp = {};
                    var temp = MergeInfo.mergeFile;
                    $scope.PopUp.Info = temp;
                    ngDialog.open({
                        template:  'templatePopUpMergeFileId',
                        className: 'ngdialog-theme-default InfoPopUp',
                        scope: $scope
                    });
                }
                /*else if (MergeInfo.inBranch && !MergeInfo.Deployed && MergeInfo.IsXML && MergeInfo.LastComponentHistoryATID != null && MergeInfo.AttachmentId != null && !MergeInfo.IsIdentical) {*/
                else if (MergeInfo.CONFLICT && MergeInfo.inBranch && MergeInfo.LastComponentHistoryATID != null && MergeInfo.AttachmentId != null && !MergeInfo.IsIdentical) {
                    
                    $scope.PopUp = {};
                    $scope.PopUp.base = MergeInfo.LastFile;
                    console.log('MergeInfo.IsManualMerge'+MergeInfo.IsManualMerge);
                    if (MergeInfo.IsManualMerge) {
                        $scope.PopUp.newfile = MergeInfo.mergeFile;
                    }
                    else {
                        $scope.PopUp.newfile = MergeInfo.MetaItemFile;
                    }
                    //console.log('$scope.PopUp.newfile'+$scope.PopUp.newfile);
                    $scope.PopUp.EtalonValue = '';
                    $scope.PopUp.ItemId = MergeInfo.ItemId;
                    $scope.PopUp.ManualMerge = function(xml) {
                        //console.log('xml'+xml);
                        MergeService.setMergeFile(MergeInfo.ItemId, xml);
                        param.IsManualMerge = true;
                        $scope.getStatusConflicts();
                        ngDialog.closeAll();
                    }
                    $scope.PopUp.closeManualMerge = function() {
                        ngDialog.closeAll();
                    }
                    if (MergeInfo.IsXML) {
                      ngDialog.open({
                          template:  'templatePopUpMergeXML',
                          className: 'ngdialog-theme-default MergeXML',
                          scope: $scope
                      });
                    }
                    else {
                      ngDialog.open({
                          template:  'templatePopUpMergeText',
                          className: 'ngdialog-theme-default MergeText',
                          scope: $scope
                      });
                    }
                    //templatePopUpMergeXML
                }
                console.log('MergeInfo'+MergeInfo);
                
            };

            $scope.getMapMergeFiles = function(orderVal) {
                mergeFilesMap = {};

                /*for (x = 0; x < $scope.GoodMergeItems.length; x++) {
                    var fileZip = new JSZip();
                    fileZip.file($scope.GoodMergeItems[x].Label,$scope.GoodMergeItems[x].mergeFile,{binary:true});
                    if ($scope.GoodMergeItems[x].MetaItemFileMeta != null) {
                        fileZip.file($scope.GoodMergeItems[x].Label+"-meta.xml",$scope.GoodMergeItems[x].MetaItemFileMeta,{binary:true});
                    }

                    var mergeFileZip = fileZip.generate({type:"base64",compression:"DEFLATE"});

                    mergeFilesMap[$scope.GoodMergeItems[x].LastComponentHistoryATID] = mergeFileZip;
                }*/
                for (x = 0; x < $scope.FirstStepItems.length; x++) {
                    var fileZip = new JSZip();
                    fileZip.file($scope.FirstStepItems[x].Label,$scope.FirstStepItems[x].mergeFile,{binary:true});
                    if ($scope.FirstStepItems[x].MetaItemFileMeta != null) {
                        fileZip.file($scope.FirstStepItems[x].Label+"-meta.xml",$scope.FirstStepItems[x].MetaItemFileMeta,{binary:true});
                    }

                    var mergeFileZip = fileZip.generate({type:"base64",compression:"DEFLATE"});

                    mergeFilesMap[$scope.FirstStepItems[x].LastComponentHistoryATID] = mergeFileZip;
                }
            }

            $scope.refreshOrderBy = function(orderVal) {
                $scope.metaOffSet = 0;
                $scope.viewLimit = $scope.metaOffSet + $scope.staticLimit;
                if(orderVal == $scope.orderByColumn)
                    $scope.isReverse = !$scope.isReverse;
                else
                {
                    $scope.isReverse = false;
                    $scope.orderByColumn = orderVal;
                }
            };
            
            //select option
                $scope.testItemList='';
                //$scope.runTestTemplates=[{id:1,name:"a"},{id:2,name:"b"},{id:3,name:"c"}]
                $scope.runTestTemplates= [];    
                $scope.changedValue = function(item) {
                    $scope.itemList = item.name;
                }   
            
            
            $scope.reRenderSecondPage = function() {

                $scope.$apply(function(){
                    $scope.showFirstPageBlock = false;
                    updateVersion = [];

                    $scope.componentList = [];
                    for(var i = 0; i < localUpdateCompList.length ; i++) {
                      if (localUpdateCompList[i].Status == 'Modified') {
                        $scope.componentListConflict.push(localUpdateCompList[i]);
                      }
                      else {
                        $scope.componentList.push(localUpdateCompList[i]); 
                      }
                      updateVersion.push(localUpdateCompList[i]);
                    }
                    /*$scope.componentList = localUpdateCompList;*/
                    $scope.conflictMetaOffSet = 0;
                    $scope.conflictViewLimit = $scope.staticLimit;
                    $scope.conflictOrderByColumn = 'changedOn';
                    $scope.conflictIsReverse = true;
                    $scope.conflictDisableNextPrevious = false;

                    $scope.orderByColumn = 'changedOn';
                    $scope.isReverse = true;
                    $scope.metaOffSet = 0;
                    $scope.totalRecords = 0;
                    $scope.disableNextPrevious = false;
                    $scope.viewLimit = $scope.staticLimit;
                    var tempObjNew = {};
                    tempObjNew['compName'] = 'Component Name';
                    tempObjNew['compType'] = 'Component Type';
                    tempObjNew['version'] = 'Version';
                    tempObjNew['changedBy'] = 'Changed By';
                    //tempObjNew['changedOn'] = 'Changed On';
                    tempObjNew['changedOnLocal'] = 'Changed On';
                    tempObjNew['committedBy'] = 'Committed By'; 
                    //tempObjNew['committedOn'] = 'Committed On';
                    tempObjNew['committedOnLocal'] = 'Committed On';
                    tempObjNew['Status'] = 'Status'; 
                    $scope.fieldSet = tempObjNew;
                    $scope.showSecondPageBlock = true;
                    
                });
                
            };
            
            $scope.getStatusConflicts = function() {
                $scope.disableContinueUpdateButton = false;
                //var tempFirstStepItems = [];
                for (x = 0; x < $scope.FirstStepItems.length; x++) {
                    if ($scope.FirstStepItems[x].CONFLICT == true) {
                        $scope.disableContinueUpdateButton = true;

                        //tempFirstStepItems.push($scope.FirstStepItems[x])
                    }
                    else {
                        //if ($scope.FirstStepItems[x].DeployFile ==  $scope.FirstStepItems[x].MetaItemFile) {
// Item.DeployedComponentHistoryCRC32 == JSON.parse(Item.CRC32)
                        //}
                        //else {
                            //$scope.GoodMergeItems.push($scope.FirstStepItems[x]); 
                        //}
                    }
                }
                //$scope.FirstStepItems = tempFirstStepItems;
            }

            $scope.showFirst = function() {
                $scope.metaOffSet = 0;
                $scope.viewLimit = $scope.staticLimit;
            };
            
            $scope.listPrevious = function() {
                $scope.metaOffSet = $scope.metaOffSet - $scope.staticLimit;
                if($scope.metaOffSet < 0)
                    $scope.metaOffSet = 0;
                $scope.viewLimit = $scope.metaOffSet + $scope.staticLimit;
            };
            
            $scope.listNext = function(tempTotal) {
                if(($scope.metaOffSet + $scope.staticLimit) < tempTotal)
                {
                    $scope.metaOffSet = $scope.metaOffSet + $scope.staticLimit;
                    $scope.viewLimit = $scope.metaOffSet + $scope.staticLimit;
                }
            };
            
            $scope.showLast = function(tempTotal) {
                $scope.metaOffSet = tempTotal - (tempTotal % $scope.staticLimit);
                if($scope.metaOffSet == tempTotal && $scope.metaOffSet != 0)
                {
                    $scope.metaOffSet = tempTotal - $scope.staticLimit;
                }
                $scope.viewLimit = $scope.metaOffSet + $scope.staticLimit;
            };
            
            $scope.reRenderRemoteChanges = function() {
                $scope.$apply(function(){
                    $scope.componentList = allCompsMap;
                });
            };
            
            
            $scope.disableContinueButton = function() {
                $scope.$apply(function(){
                    $scope.disableContinueUpdateButton = true;
                });
            };
            
            $scope.enableContinueButton = function() {
                $scope.$apply(function(){
                    $scope.disableContinueUpdateButton = false;
                });
            };
            
            $scope.disableDownload = function() {
                $scope.$apply(function(){
                              $scope.disableDownloadOrgButton = true;
                });
            };
            
            $scope.enableDownload = function() {
                $scope.$apply(function(){
                    $scope.disableDownloadOrgButton = false;
                });
            };
            
            $scope.enableUpdateOrg = function() {
                $scope.$apply(function() {
                       $scope.disableUpdateOrgButton = false;
                });
            };
            
            $scope.disableNextPreviousButton = function() {
                $scope.$apply(function() {
                       $scope.disableNextPrevious = true;
                });
            };
            
            $scope.disableUpdateOrg = function() {
                $scope.$apply(function() {
                       $scope.disableUpdateOrgButton = true;
                });
            };
            
            $scope.isPrevious = function() {
                if($scope.metaOffSet < 1) 
                    return true;
                else {
                    return false;
                }
            };
            
            $scope.isNext = function(tempTotal){
                if(tempTotal > $scope.metaOffSet+$scope.staticLimit){
                    return false;
                }
                else {
                    return true;
                }
            };
            
            $scope.totalPageCount = function(tempTotal){
                var totalPage = parseInt(tempTotal % $scope.staticLimit > 0 ? (tempTotal / $scope.staticLimit)+1 : (tempTotal / $scope.staticLimit));
                return totalPage;
                
            };
            
            $scope.currentPageNo = function(tempTotal){
                var currentPage = 1;
                if($scope.metaOffSet <  $scope.staticLimit)
                    currentPage =  1;
                else
                {
                    currentPage = Math.ceil($scope.metaOffSet / $scope.staticLimit)+1;
                }
                return currentPage;
            };

            //not conflict to commit
            $scope.notConflictRefreshOrderBy = function(orderVal) {
                $scope.notConflictMetaOffSet = 0;
                $scope.notConflictViewLimit = $scope.notConflictMetaOffSet + $scope.staticLimit;
                if(orderVal == $scope.notConflictOrderByColumn)
                    $scope.notConflictIsReverse = !$scope.notConflictIsReverse;
                else
                {
                    $scope.notConflictIsReverse = false;
                    $scope.notConflictOrderByColumn = orderVal;
                }
            };
            $scope.notConflictShowFirst = function() {
                $scope.notConflictMetaOffSet = 0;
                $scope.notConflictViewLimit = $scope.staticLimit;    
            };
            $scope.notConflictListPrevious = function() {
                $scope.notConflictMetaOffSet = $scope.notConflictMetaOffSet - $scope.staticLimit;
                if($scope.notConflictMetaOffSet < 0)
                    $scope.notConflictMetaOffSet = 0;
                $scope.notConflictViewLimit = $scope.notConflictMetaOffSet + $scope.staticLimit;
            };
            $scope.notConflictListNext = function(tempTotal) {
                if(($scope.notConflictMetaOffSet + $scope.staticLimit) < tempTotal)
                {
                    $scope.notConflictMetaOffSet = $scope.notConflictMetaOffSet + $scope.staticLimit;
                    $scope.notConflictViewLimit = $scope.notConflictMetaOffSet + $scope.staticLimit;
                }
            };
            $scope.notConflictShowLast = function(tempTotal) {
                $scope.notConflictMetaOffSet = tempTotal - (tempTotal % $scope.staticLimit);
                if($scope.notConflictMetaOffSet == tempTotal && $scope.notConflictMetaOffSet != 0)
                {
                    $scope.notConflictMetaOffSet = tempTotal - $scope.staticLimit;
                }
                $scope.notConflictViewLimit = $scope.notConflictMetaOffSet + $scope.staticLimit;
            };
            $scope.notConflictIsPrevious = function() {
                if($scope.notConflictMetaOffSet < 1) 
                    return true;
                else {
                    return false;
                }
            };
            $scope.notConflictIsNext = function(tempTotal){
                if(tempTotal > $scope.notConflictMetaOffSet+$scope.staticLimit){
                    return false;
                }
                else {
                    return true;
                }
            };

            $scope.notConflictCurrentPageNo = function(tempTotal){
                var currentPage = 1;
                if($scope.notConflictMetaOffSet <  $scope.staticLimit)
                    currentPage =  1;
                else
                {
                    currentPage = Math.ceil($scope.notConflictMetaOffSet / $scope.staticLimit)+1;
                }
                return currentPage;
            };

            /********************** conflict *******************************************/
            $scope.conflictRefreshOrderBy = function(orderVal) {
                $scope.conflictMetaOffSet = 0;
                $scope.conflictViewLimit = $scope.conflictMetaOffSet + $scope.staticLimit;
                if(orderVal == $scope.conflictOrderByColumn)
                    $scope.conflictIsReverse = !$scope.conflictIsReverse;
                else
                {
                    $scope.conflictIsReverse = false;
                    $scope.conflictOrderByColumn = orderVal;
                }
            };

            $scope.conflictShowFirst = function() {
                $scope.conflictMetaOffSet = 0;
                $scope.conflictViewLimit = $scope.staticLimit;
            };
            
            $scope.conflictListPrevious = function() {
                $scope.conflictMetaOffSet = $scope.conflictMetaOffSet - $scope.staticLimit;
                if($scope.conflictMetaOffSet < 0)
                    $scope.conflictMetaOffSet = 0;
                $scope.conflictViewLimit = $scope.conflictMetaOffSet + $scope.staticLimit;
            };
            
            $scope.conflictListNext = function(tempTotal) {
                if(($scope.conflictMetaOffSet + $scope.staticLimit) < tempTotal)
                {
                    $scope.conflictMetaOffSet = $scope.conflictMetaOffSet + $scope.staticLimit;
                    $scope.conflictViewLimit = $scope.conflictMetaOffSet + $scope.staticLimit;
                }
            };
            
            $scope.conflictShowLast = function(tempTotal) {
                $scope.conflictMetaOffSet = tempTotal - (tempTotal % $scope.staticLimit);
                if($scope.conflictMetaOffSet == tempTotal && $scope.conflictMetaOffSet != 0)
                {
                    $scope.conflictMetaOffSet = tempTotal - $scope.staticLimit;
                }
                $scope.conflictViewLimit = $scope.conflictMetaOffSet + $scope.staticLimit;
            };

            $scope.conflictDisableNextPreviousButton = function() {
                $scope.$apply(function() {
                       $scope.conflictDisableNextPrevious = true;
                });
            };

            $scope.conflictIsPrevious = function() {
                if($scope.conflictMetaOffSet < 1) 
                    return true;
                else {
                    return false;
                }
            };
            
            $scope.conflictIsNext = function(tempTotal){
                if(tempTotal > $scope.conflictMetaOffSet+$scope.staticLimit){
                    return false;
                }
                else {
                    return true;
                }
            };

            $scope.conflictCurrentPageNo = function(tempTotal){
                var currentPage = 1;
                if($scope.conflictMetaOffSet <  $scope.staticLimit)
                    currentPage =  1;
                else
                {
                    currentPage = Math.ceil($scope.conflictMetaOffSet / $scope.staticLimit)+1;
                }
                return currentPage;
            };


        });
        </script>
        <style>
          .MergeXML.ngdialog.ngdialog-theme-default .ngdialog-content {
            width: 95%;
            min-width: 850px;
          }
          .MergeText.ngdialog.ngdialog-theme-default .ngdialog-content {
            width: 95%;
            min-width: 850px;
          }
          .ngdialog.ngdialog-theme-default .ngdialog-content {
            min-width: 850px;
          }
          
          li {
            list-style-type: none;
          }
          .flex {
            display: -webkit-box;
             display: -webkit-flex;
             display: -ms-flexbox;
             display: flex;
          }
          
          tr {
            display: table-row;
            vertical-align: inherit;
            border-color: inherit;
          }
          .sf-inner-container pre {
            display: block; 
            padding: 0px; 
            margin: 0px;
            font-size: 12px;
            line-height: normal;
            color: #333;
            word-break: break-all;
            word-wrap: break-word;
            background-color: ;
            border-radius: 0px;
            border: ivory;
            height: 18px;
            background-color: white;
          }
          .iconnDiff {
            cursor: pointer;
            border: 1px solid #9C9C9C;
            /*padding: 2px;*/
            padding: 0px;
            border-radius: 3px;
            background-color: #DEDEDE;
          }
          .EmpyBlock {
            height: 18px;
          }
          .sf-inner-container .removeClass {
            background-color: #717ECD;
            min-width: 850px;
          }
          .sf-inner-container .addClass{
            background-color: #4EB1CB;
            min-width: 850px;
          }
          .sf-inner-container .editClass{
            background-color: #F9F2AD;
            min-width: 850px;
          }
          .sf-inner-container td, .sf-inner-container th {
            border: 0.1px solid #9C9C9C;
            padding: 3px;
            vertical-align: top;
          }
          
          .spinner {
            width: 50px;
            height: 40px;
            text-align: center;
            font-size: 10px;
            border: 0.1px solid #36a0fe;
            border-radius: 6px;
            width: 100%;
          }

          .spinner > div {
            background-color: #5E7AF7;
            height: 100%;
            width: 6px;
            display: inline-block;
             margin-left: 1px;
            -webkit-animation: sk-stretchdelay 1.2s infinite ease-in-out;
            animation: sk-stretchdelay 1.2s infinite ease-in-out;
          }
          
          .spinner .rect2 {
            -webkit-animation-delay: -1.1s;
            animation-delay: -1.1s;
          }
          
          .spinner .rect3 {
            -webkit-animation-delay: -1.0s;
            animation-delay: -1.0s;
          }
          
          .spinner .rect4 {
            -webkit-animation-delay: -0.9s;
            animation-delay: -0.9s;
          }
          
          .spinner .rect5 {
            -webkit-animation-delay: -0.8s;
            animation-delay: -0.8s;
          }
          
          .XMLinfo {
            border: 0.1px solid #D0D4D8;
            font-size: 14px;
            border-radius: 3px;
            min-width: 850px;
            width: 50%;
            margin-left: 20px;
            margin-top: -3px;
          }
          
          .XMLlabel {
              margin-right: 20px;
          }
          
          @-webkit-keyframes sk-stretchdelay {
            0%, 40%, 100% { -webkit-transform: scaleY(0.4) }  
            20% { -webkit-transform: scaleY(1.0) }
          }
          
          @keyframes sk-stretchdelay {
            0%, 40%, 100% { 
            transform: scaleY(0.4);
            -webkit-transform: scaleY(0.4);
            }  20% { 
            transform: scaleY(1.0);
            -webkit-transform: scaleY(1.0);
            }
          }
        </style>
</apex:page>
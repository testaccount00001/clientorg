<apex:page sidebar="false" controller="FL_LocalWorkspaceController" tabStyle="FL_Local_Workspace__tab" action="{!checkAuthentication}" doctype="html-5.0">
    <style>
        div .pagination {
            text-align: center;
        }
        [ng\:cloak], [ng-cloak], [data-ng-cloak], [x-ng-cloak], .ng-cloak, .x-ng-cloak {
          display: none !important;
        }
        .daysLabel{
            color: rgb(79, 74, 96);
            font-size: 11px;
        }
        span#filterLabelId-_help {
            margin-right: 24px;
        }
        td.filterheaderclass {
            padding-left: 15px;
        }
        th.filterheaderclass {
            padding-left: 15px;
        }
        label.filterLabelLogiclabel {
            color: rgb(79, 74, 96);
            font-size: 11px;
        }
        th.filterheaderclass {
            color: rgb(79, 74, 96);
            font-size: 11px;
        }
        .pbBody .bPageBlock .pbTitle {
            width: 100%;
        }
        .angmultiselectdiv {
            display: flex;
        }
        .angmultiselectdivbtn {
            align-self: center;
        }
        select.multipleSelectForComponentType {
            width: 190px;
        }
    </style>
    <apex:includeScript value="{!URLFOR($Resource.FL_FlosumJS, 'jszip-master/dist/jszip.js')}"/>
    <apex:includeScript value="{!URLFOR($Resource.FL_FlosumJS,'jszip-master/flosumsf/flosumsf1.6.3.js')}"/>
    <apex:includeScript value="{!URLFOR($Resource.FL_FlosumJS, 'jszip-master/angular/angular.min.js')}"/>
    <apex:includeScript value="{!$Resource.FL_X2JS}"/>

    <apex:stylesheet value="{!URLFOR($Resource.Merge, 'Merge/css/bootstrapSF.min.css')}" />
    <apex:stylesheet value="{!URLFOR($Resource.Merge, 'Merge/ngDialog/ngDialog.min.css')}" />
    <apex:stylesheet value="{!URLFOR($Resource.Merge, 'Merge/ngDialog/ngDialog-theme-default.css')}" />
    <apex:stylesheet value="{!URLFOR($Resource.Merge, 'Merge/ngDialog/ngDialog-theme-plain.min.css')}" />
    
    <apex:includeScript value="{!URLFOR($Resource.Merge, 'Merge/jquery-2.1.4.min.js')}"/>
    <apex:includeScript value="{!URLFOR($Resource.Merge, 'Merge/jquery-ui.js')}"/>
    <apex:includeScript value="{!URLFOR($Resource.Merge, 'Merge/ngDialog/ngDialog.min.js')}"/>
    <apex:includeScript value="{!URLFOR($Resource.Merge, 'Merge/diff.js')}"/>
    <apex:includeScript value="{!URLFOR($Resource.Merge, 'Merge/xml2json.js')}"/>
    <apex:includeScript value="{!URLFOR($Resource.Merge, 'Merge/angular-base64.min.js')}"/>
    <apex:includeScript value="{!URLFOR($Resource.Merge, 'Merge/deep-diff-0.3.3.min.js')}"/>
    <apex:includeScript value="{!URLFOR($Resource.Merge, 'Merge/diff_match_patch.js')}"/>
    <c:FL_Wait />
    <apex:includeScript value="{!URLFOR($Resource.FL_Moment, 'Moment/moment.js')}"/>
    <apex:includeScript value="{!URLFOR($Resource.FL_Moment, 'Moment/moment-timezone-with-data.js')}"/>
    <apex:pagemessages id="msg"/>
    <apex:form rendered="{!isAuthSuccessful}">
        <div ng-app="localworkspace" >
            <div ng-controller ="RetrieveChangesController" id="angularControllerId">
                <div class="ng-cloak">
                    <script type="text/ng-template" id="templatePopUpMergeXML" >
                    <!-- <meta http-equiv="Content-Type" content="text/html; charset=windows-1251" > -->
                        <div class="sf-inner-container" style="width: 95%;">
                            <div style="text-align: center; width: 95%;">
                                <button type="button" class="btn btn-warning" ng-click="PopUp.closeManualMerge()">Cancel</button>
                                <button type="button" style="background-color: #2A94D6;" class="btn btn-success" ng-click="PopUp.ManualMerge(PopUp.EtalonValue, PopUp.ItemId)">Apply Changes</button>
                            </div>
                            <div><merge-xml sourse="{{PopUp.base}}" target="{{PopUp.newfile}}" file="PopUp.EtalonValue" xml="true"/></div>
                            <div style="text-align: center; width: 95%;">
                                <button type="button" class="btn btn-warning" ng-click="PopUp.closeManualMerge()">Cancel</button>
                                <button type="button" style="background-color: #2A94D6;" class="btn btn-success" ng-click="PopUp.ManualMerge(PopUp.EtalonValue, PopUp.ItemId)">Apply Changes</button>
                            </div>
                            
                        </div>
                    <!-- </meta> -->
                    </script>

                    <script type="text/ng-template" id="templatePopUpMergeText">
                        <div class="sf-inner-container" style="width: 95%;">
                            <div style="text-align: center; width: 95%;">
                                <button type="button" class="btn btn-warning" ng-click="PopUp.closeManualMerge()">Cancel</button>
                                <button type="button" style="background-color: #2A94D6;" class="btn btn-success" ng-click="PopUp.ManualMerge(PopUp.EtalonValue, PopUp.ItemId)">Apply Changes</button>
                            </div>
                            <div><mergeinfo sourse="{{PopUp.base}}" target="{{PopUp.newfile}}" file="PopUp.EtalonValue" /></div>
                            <div style="text-align: center; width: 95%;">
                                <button type="button" class="btn btn-warning" ng-click="PopUp.closeManualMerge()">Cancel</button>
                                <button type="button" style="background-color: #2A94D6;" class="btn btn-success" ng-click="PopUp.ManualMerge(PopUp.EtalonValue, PopUp.ItemId)">Apply Changes</button>
                            </div>
                            
                        </div>
                    </script>
                    
                    <script type="text/ng-template" id="templatePopUpMergeFileId">
                        <div class="sf-inner-container" style="width: 95%;">
                            {{PopUp.Info}}
                        </div>
                    </script>
                    <script type="text/ng-template" id="templatePopUpInfoId">
                        <div class="sf-inner-container" style="width: 95%;">
                            <div class="form-group">
                                <label for="TaskWeight">Component Type</label>
                                {{PopUp.Info.ComponentType}}
                            </div>
                            <div class="form-group">
                                <label for="TaskWeight">API Name: </label>
                                {{PopUp.Info.APIName}}
                            </div>
                            <div class="form-group">
                                <label for="TaskWeight">Label: </label>
                                {{PopUp.Info.Label}}
                            </div>
                                    
                            <div class="form-group">
                                <label for="TaskWeight">Last Component History Id In Branch: </label>
                                <a href="/{{PopUp.Info.LastComponentHistoryId}}" target="_blank">{{PopUp.Info.LastComponentHistoryId}}</a>
                            </div>
                            <div class="form-group">
                                <label for="TaskWeight">Last Component History in Branch CRC32: </label>
                                {{PopUp.Info.LastComponentHistoryCRC32}}
                            </div>
                            <div class="form-group">
                                <label for="TaskWeight">Last Component History Version in Branch: </label>
                                {{PopUp.Info.LastComponentHistoryVersion}}
                            </div>
                            <div class="form-group">
                                <label for="TaskWeight">Last Component History Attachment ID: </label>
                                <a href="/{{PopUp.Info.LastComponentHistoryATID}}" target="_blank">{{PopUp.Info.LastComponentHistoryATID}}</a>
                            </div>
                            <div class="form-group">
                                <label for="TaskWeight">Deployed: </label>
                                {{PopUp.Info.Deployed}}
                            </div>
                            <div class="form-group">
                                <label for="TaskWeight">Last Date Deployed Component History: </label>
                                {{PopUp.Info.DeployedComponentHistoryLastDate}}
                            </div>
                            <div class="form-group">
                                <label for="TaskWeight">Deployed Component History Id: </label>
                                <a href="/{{PopUp.Info.DeployedComponentHistoryId}}" target="_blank">{{PopUp.Info.DeployedComponentHistoryId}}</a>
                            </div>
                            <div class="form-group">
                                <label for="TaskWeight">Deployed Component History CRC32: </label>
                                {{PopUp.Info.DeployedComponentHistoryCRC32}}
                            </div>
                            <div class="form-group">
                                <label for="TaskWeight">Deployed Component History Version: </label>
                                {{PopUp.Info.DeployedComponentHistoryVersion}}
                            </div>
                            <div class="form-group">
                                <label for="TaskWeight">Deployed Component History Attachment ID: </label>
                                <a href="/{{PopUp.Info.DeployedComponentHistoryATID}}" target="_blank">{{PopUp.Info.DeployedComponentHistoryATID}}</a>
                            </div>
                            
                        </div>
                    </script>
                    <fieldset ng-disabled="disableUi">
                        <apex:pageBlock html-ng-show="CommitStep == 1">
                            <apex:pageBlockbuttons location="top">
                                <apex:commandbutton value="{!$Label.FL_Retrieve_Changes_from_Local_Org}" onClick="show();" action="{!listMetadataItems}" reRender="msg"  html-ng-disabled="disableRetrieveChangesButton" onComplete="listMetadataItems('{!filterMiliSeconds}',{!IsRetrieveStandard},{!isProcessSuccessful})"/>
                               
                                <apex:commandbutton value="{!$Label.FL_Push_to_Remote_Repository}" reRender="none" html-ng-click="startRetrievalForAllSelectedForPush();" onClick="return false;" html-ng-disabled="disablePushButton"/>
                            </apex:pageBlockbuttons>
                            <apex:pageBlockSection >
                                <apex:pageBlockSectionItem >
                                    <apex:outputLabel value="Branch"/>
                                    <apex:outputText value="{!branchName}"/>
                                </apex:pageBlockSectionItem>
                            </apex:pageBlockSection>
                            <apex:pageBlockSection html-ng-show="!disableRetrieveChangesButton" columns="1">
                                <apex:pageBlockSectionItem >
                                    <apex:outputLabel value="Retrieve changes in the last"/>
                                    <apex:outputPanel ><apex:input label="Retrieve changes in the last" value="{!lastModifiedInDays}" type="number" id="afterDateToFilter" html-min="0" required="true" html-max="3650" styleClass="disableitem"/><apex:outputLabel styleClass="daysLabel" value="days"/></apex:outputPanel>
                                </apex:pageBlockSectionItem>
                                <apex:pageBlockSectionItem >
                                    <apex:outputLabel value="Retrieve standard components"/>
                                    <apex:inputCheckbox value="{!IsRetrieveStandard}"/>
                                </apex:pageBlockSectionItem>
<!--                                 <apex:PageBlockSectionItem > -->
                                   
<!--                                     <apex:outputPanel styleClass="angmultiselectdiv"> -->
<!--                                         <div> -->
<!--                                             <apex:outputLabel value="Available Metadata" styleClass="daysLabel"/><br/> -->
<!--                                             <select class="multipleSelectForComponentType" ng-model="leftSelected" multiple="true" size="20"> -->
<!--                                                 <option ng-repeat="meta in availableOptions" value="{{meta}}">{{meta}}</option> -->
<!--                                             </select> -->
<!--                                         </div> -->
<!--                                         <div class="angmultiselectdivbtn"> -->
<!--                                             <apex:outputLink html-ng-click="addToRight(leftSelected);"> -->
<!--                                                 <apex:image value="/s.gif" alt="Add" styleClass="rightArrowIcon" title="Add" /> -->
<!--                                             </apex:outputLink><br/> -->
<!--                                             <apex:outputLink html-ng-click="removeFromRight(rightSelected);"> -->
<!--                                                 <apex:image value="/s.gif" alt="Remove" styleClass="leftArrowIcon" title="Remove" /> -->
<!--                                             </apex:outputLink> -->
<!--                                         </div> -->
<!--                                         <div> -->
<!--                                             <apex:outputLabel value="Selected Metadata" styleClass="daysLabel"/><br/> -->
<!--                                             <select class="multipleSelectForComponentType" ng-model="rightSelected" multiple="true" size="20"> -->
<!--                                                 <option ng-repeat="meta in selectedOptions" value="{{meta}}">{{meta}}</option> -->
<!--                                             </select> -->
<!--                                         </div> -->
<!--                                     </apex:outputPanel> -->
<!--                                 </apex:PageBlockSectionItem> -->
                                <apex:pageBlockSectionItem >
                                    <apex:outputPanel >
                                        <table ng-show="filterList.length > 0">
                                            <thead>
                                                <tr>
                                                    <th class="filterheaderclass"></th>
                                                    <th class="filterheaderclass">Field</th>
                                                    <th class="filterheaderclass">Operator</th>
                                                    <th class="filterheaderclass">Value</th>
                                                </tr>
                                            </thead>
                                            <tbody>
                                                <tr ng-repeat="filterRow in filterList">
                                                    <td class="filterheaderclass">{{ $index+1 +'.'}}</td>
                                                    <td class="filterheaderclass">
                                                        <select ng-model="filterRow.field">
                                                            <option value="{{''}}">--None--</option>
                                                            <option ng-repeat="(key, value) in fieldList" value="{{key}}">{{value}}</option>
                                                        </select>
                                                    </td>
                                                    <td class="filterheaderclass">
                                                        <select ng-model="filterRow.operator">
                                                            <option value="{{''}}">--None--</option>
                                                            <option ng-repeat="operatorOne in compareList" value="{{operatorOne}}">{{operatorOne}}</option>
                                                        </select>
                                                    </td>
                                                    <td class="filterheaderclass">
                                                        <input type="text" id="jstextbox" ng-model="filterRow.value" class="tagsclass" filterIndex="{{$index}}" size="50"/>
                                                    </td>
                                                    <td class="filterheaderclass" ng-show="filterRow.field == 'type' || filterRow.field == 'lastModifiedByName' || filterRow.field == 'createdByName'">
                                                        <a ng-click="createLookupLink(filterRow.field,$index,filterRow.value);">
                                                            <img src="/s.gif" alt="Org Lookup (New Window)" class="lookupIcon" onblur="this.className = 'lookupIcon';" 
                                                            onfocus="this.className = 'lookupIconOn';" onmouseout="this.className = 'lookupIcon';this.className = 'lookupIcon';" 
                                                            onmouseover="this.className = 'lookupIconOn';this.className = 'lookupIconOn';"/>
                                                        </a>
                                                    </td>
                                                    <td class="filterheaderclass" ng-show="!enableFilterLogic">
                                                    AND
                                                    </td>
                                                </tr>
                                            </tbody>
                                        </table>
                                    </apex:outputPanel>
                                </apex:pageBlockSectionItem>
                                <apex:pageBlockSectionItem >
                                    <a id="link-2" href="" ng-click="addRowToSearch();">Add Row</a>
                                </apex:pageBlockSectionItem>
                                <apex:pageBlockSectionItem >
                                    <apex:outputPanel >
                                        <a id="link-2" href="" ng-click="enableFilterLogic = true" ng-show="!enableFilterLogic">Add Filter Logic...</a>
                                        <a id="link-2" href="" ng-click="enableFilterLogic = false" ng-show="enableFilterLogic">Clear Filter Logic</a>
                                    </apex:outputPanel>
                                </apex:pageBlockSectionItem>
                                <apex:pageBlockSectionItem html-ng-show="enableFilterLogic">
                                    <apex:outputPanel >
                                        <apex:outputLabel value="Filter Logic" id="filterLabelId" styleClass="filterLabelLogiclabel"/>
                                        <span class="helpButton" id="filterLabelId-_help"><img src="/s.gif" alt="" class="helpOrb" title=""/><script>sfdcPage.setHelp('filterLabelId', 'Example:- <br>1. (1 AND 2) OR 3,<br>2. 3 OR (1 AND 2).');</script></span>
                                        <apex:inputText html-ng-model="filterCondition" size="100"/>
                                    </apex:outputPanel>
                                </apex:pageBlockSectionItem>
                            </apex:pageBlockSection>
                            <apex:pageBlockSection html-ng-show="metadataTypeOptions.length > 0" columns="1">
                                <apex:PageBlockSectionItem >
                                    <apex:outputLabel value="Component Type"/>
                                    <select ng-model="selectedMetadataType" ng-click="showFirst();">
                                        <option value="{{''}}">All</option>
                                        <option ng-repeat="meta in metadataTypeOptions" value="{{meta}}">{{meta}}</option>
                                    </select>
                                </apex:PageBlockSectionItem>
                            </apex:pageBlockSection>
                            <apex:pageBlockSection html-ng-show="componentList.length > 0" columns="1">
                                <div>
                                    <apex:pageBlockSection columns="1">
                                        <table ng-show="componentList.length > 0" class="list">
                                            <thead>
                                                <tr class="headerRow">
                                                    <th>No.</th>
                                                    <th><input type="checkbox" ng-click="checkItemAll(isAllChecked,(componentList | filter:filterForSearch | orderBy: orderByColumn :isReverse | limitTo: viewLimit),metaOffSet);" class="psli" ng-model="isAllChecked" >&nbsp;</input></th>
                                                    <th ng-repeat = "(key, value) in fieldSet">
                                                        <a ng-click="refreshOrderBy(key)">{{ orderByColumn == key ? isReverse ? value+' ▼' : value+' ▲' : value }}</a>
                                                    </th>
                                                </tr>
                                            </thead>
                                            <tbody>
                                                <tr ng-repeat = "meta in componentList | filter:filterForSearch | orderBy: orderByColumn :isReverse | limitTo: viewLimit" ng-if="$index >= metaOffSet" class="dataRow"
                                                onmouseover="if (window.hiOn){hiOn(this);} " onmouseout="if (window.hiOff){hiOff(this);} ">
                                                    <td>{{ $index+1 }}</td>
                                                    <td><input type="checkbox" class="sli" ng-click="checkUnCheck((componentList | filter:filterForSearch | orderBy: orderByColumn :isReverse | limitTo: viewLimit),metaOffSet);" ng-model="meta.checked"/></td>
                                                    <td ng-repeat = "(key, value) in fieldSet">
                                                        {{ meta[key == 'lastModifiedDate'? 'changedOn' : key] }}
                                                    </td>
                                                 </tr>
                                            </tbody>
                                        </table>
                                    </apex:pageBlockSection>
                                    <apex:outputPanel html-ng-show="componentList.length > 0" styleClass="pagination" layout="block" style="text-align: center;">
                                        <apex:commandbutton html-ng-click="showFirst();" onClick="return false;" value="First" reRender="none" html-ng-disabled="isPrevious();"/>
                                        <apex:commandbutton html-ng-click="listPrevious();" onClick="return false;" value="Previous" reRender="none" html-ng-disabled="isPrevious();"/>
                                        Total {{(componentList|filter:filterForSearch).length}} components, Page {{currentPageNo((componentList|filter:filterForSearch).length)}} of {{totalPageCount((componentList|filter:filterForSearch).length)}}
                                        <apex:commandbutton html-ng-click="listNext((componentList|filter:filterForSearch).length);" onClick="return false;" value="Next" reRender="none" html-ng-disabled="isNext((componentList | filter:filterForSearch).length);"/>
                                        <apex:commandbutton html-ng-click="showLast((componentList|filter:filterForSearch).length);" onClick="return false;" value="Last" reRender="none" html-ng-disabled="isNext((componentList | filter:filterForSearch).length);"/>
                                    </apex:outputPanel>
                                </div>
                            </apex:pageBlockSection>
                        </apex:pageBlock>
                        <apex:pageBlock html-ng-show="CommitStep == 2" title="Conflict Resolution">
                            <apex:pageBlockbuttons location="top">
                                <apex:commandbutton value="{!$Label.FL_Commit_to_Remote_Repository}" reRender="none" html-ng-click="createSyncRecord();" onClick="return false;" html-ng-disabled="disableCommitButton"/>
                            </apex:pageBlockbuttons>
                            <apex:pageBlockSection columns="1">
                                <apex:pageBlockSectionItem >
                                    <apex:outputLabel value="Branch"/>
                                    <apex:outputText value="{!branchName}"/>
                                </apex:pageBlockSectionItem>
                                <apex:pageBlockSectionItem >
                                    <apex:outputLabel value="Sync Name"/>
                                    <apex:inputText value="{!syncName}"/>
                                </apex:pageBlockSectionItem>
                            </apex:pageBlockSection>

                            <!-- <apex:pageBlock title="Components that are safe to commit"> -->
                            <apex:pageBlock title="New Components">
                                <!-- <p>Components which have not been updated in Repository since the last upload.</p> -->
                                <p>This section shows the new components in the local org, but not in the Remote Repository.</p>
                                <!-- <div class="g-container sf-inner-container"> -->
                                    <apex:pageBlockSection columns="1" >
                                        <table ng-show="safeToCommitLi.length > 0" class="list">
                                            <thead>
                                                <tr class="headerRow">
                                                    <th>No.</th>
                                                    <th ng-repeat = "(key, value) in commitFieldSet">
                                                        <a ng-click="safeRefreshOrderBy(key)">{{ safeOrderByColumn == key ? safeIsReverse ? value+' ▼' : value+' ▲' : value }}</a>
                                                    </th>
                                                </tr>
                                            </thead>
                                            <tbody>
                                                <tr ng-repeat = "meta in safeToCommitLi | orderBy: safeOrderByColumn : safeIsReverse | limitTo: safeViewLimit" ng-if="$index >= safeMetaOffSet" class="dataRow"
                                                onmouseover="if (window.hiOn){hiOn(this);} " onmouseout="if (window.hiOff){hiOff(this);} ">
                                                    <td>{{ $index+1 }}</td>
                                                    <td ng-repeat = "(key, value) in commitFieldSet">
                                                        {{ meta[key] }}
                                                    </td>
                                                </tr>
                                            </tbody>
                                        </table>
                                    </apex:pageBlockSection>
                                    <apex:outputPanel html-ng-show="safeToCommitLi.length > 0" styleClass="pagination" layout="block" style="text-align: center;">
                                        <apex:commandbutton html-ng-click="safeShowFirst();" onClick="return false;" value="First" reRender="none" html-ng-disabled="safeIsPrevious();"/>
                                        <apex:commandbutton html-ng-click="safeListPrevious();" onClick="return false;" value="Previous" reRender="none" html-ng-disabled="safeIsPrevious();"/>
                                        Total {{(safeToCommitLi).length}} components, Page {{safeCurrentPageNo((safeToCommitLi).length)}} of {{safeTotalPageCount((safeToCommitLi).length)}}
                                        <apex:commandbutton html-ng-click="safeListNext((safeToCommitLi).length);" onClick="return false;" value="Next" reRender="none" html-ng-disabled="safeIsNext((safeToCommitLi).length);"/>
                                        <apex:commandbutton html-ng-click="safeShowLast((safeToCommitLi).length);" onClick="return false;" value="Last" reRender="none" html-ng-disabled="safeIsNext((safeToCommitLi).length);"/>
                                    </apex:outputPanel>
                                <!-- </div> -->
                            </apex:pageBlock>
                            
                            <!-- <apex:pageBlock title="Components which have updated in Repository, but there is no conflict">
                                <p>These components will be automatically merged.</p>
                                <apex:pageBlockSection columns="1">
                                    <table ng-show="GoodMergeItems.length > 0" class="list">
                                        <thead>
                                            <tr class="headerRow">
                                                <th>No.</th>
                                                <th class="name">Name&nbsp;</th>
                                                <th class="description">ComponentType&nbsp;</th>
                                                <th class="Label">Label&nbsp;</th>
                                                <th class="Label">Deployed&nbsp;</th>
                                                <th class="Label">In Repository&nbsp;</th>
                                                <th class="Label">Is Last Version&nbsp;</th>
                                            </tr>
                                        </thead>
                                        <tbody>
                                            <tr ng-repeat="item in GoodMergeItems ">
                                                <td>{{ $index+1 }}</td>
                                                <td>{{item.APIName}}</td>
                                                <td>{{item.ComponentType}}</td>
                                                <td>{{item.Label}}</td>
                                                <td>
                                                    <span ng-if="item.Deployed"><img src="/img/checkbox_checked.gif" alt="Checked" width="21" height="16" class="checkImg" title="Checked"/></span>
                                                    <span ng-if="!item.Deployed"><img src="/img/checkbox_unchecked.gif" alt="Not Checked" width="21" height="16" class="checkImg"  title="Not Checked"/></span>
                                                </td>
                                                <td>
                                                    <span ng-if="item.inBranch"><img src="/img/checkbox_checked.gif" alt="Checked" width="21" height="16" class="checkImg" title="Checked"/></span>
                                                    <span ng-if="!item.inBranch"><img src="/img/checkbox_unchecked.gif" alt="Not Checked" width="21" height="16" class="checkImg"  title="Not Checked"/></span>
                                                </td>
                                                <td>
                                                    <span ng-if="item.IsLastVersion"><img src="/img/checkbox_checked.gif" alt="Checked" width="21" height="16" class="checkImg" title="Checked"/></span>
                                                    <span ng-if="!item.IsLastVersion"><img src="/img/checkbox_unchecked.gif" alt="Not Checked" width="21" height="16" class="checkImg"  title="Not Checked"/></span>
                                                </td> -->

                                                <!-- <td style="text-align: center;">
                                                    
                                                    <span style="cursor: pointer;" ng-click="getMergeInfo(item)" ><img width="80" height="20" src="{!URLFOR($Resource.Merge,'Merge/image/conflict.png')}"/></span>
                                                    
                                                    <span ng-show=""></span>
                                                </td> -->
                                            <!-- </tr>
                                        </tbody>
                                    </table>
                                </apex:pageBlockSection>
                                <apex:outputPanel html-ng-show="GoodMergeItems.length > 0" styleClass="pagination" layout="block" style="text-align: center;">
                                    <apex:commandbutton html-ng-click="notConflictShowFirst();" onClick="return false;" value="First" reRender="none" html-ng-disabled="notConflictIsPrevious();"/>
                                    <apex:commandbutton html-ng-click="notConflictListPrevious();" onClick="return false;" value="Previous" reRender="none" html-ng-disabled="notConflictIsPrevious();"/>
                                    Total {{(GoodMergeItems).length}} components, Page {{notConflictCurrentPageNo((GoodMergeItems).length)}} of {{notConflictTotalPageCount((GoodMergeItems).length)}}
                                    <apex:commandbutton html-ng-click="notConflictListNext((GoodMergeItems).length);" onClick="return false;" value="Next" reRender="none" html-ng-disabled="notConflictIsNext((GoodMergeItems).length);"/>
                                    <apex:commandbutton html-ng-click="notConflictShowLast((GoodMergeItems).length);" onClick="return false;" value="Last" reRender="none" html-ng-disabled="notConflictIsNext((GoodMergeItems).length);"/>
                                </apex:outputPanel>
                            </apex:pageBlock> -->
                           
                            <!-- <apex:pageBlock title="Components which have a conflict"> -->
                            <apex:pageBlock title="Modified Components">
                                <!-- <p>These components cannot be automatically merged since the same line or XML segment has been updated in the local sandbox and the Repository.</p> -->
                                <p>This section shows the components which exist in both the local org and remote repository but have been modified in the local org.</p>
                                <apex:pageBlockSection columns="1">
                                    <table ng-show="FirstStepItems.length > 0" class="list">
                                        <thead>
                                            <tr class="headerRow">
                                                <th>No.</th>
                                                <th class="name">Name&nbsp;</th>
                                                <th class="description">ComponentType&nbsp;</th>
                                                <th class="Label">Label&nbsp;</th>
                                                <th class="Label">Deployed&nbsp;</th>
                                                <th class="Label">In Repository&nbsp;</th>
                                                <th class="Label">Is Last Version&nbsp;</th>
                                                <!-- <th class="Label">Info&nbsp;</th> -->
                                                <th class="Label" style="text-align: center;">Conflict&nbsp;</th>
                                            </tr>
                                        </thead>
                                        <tbody>
                                            <tr ng-repeat="item in FirstStepItems ">
                                                <td>{{ $index+1 }}</td>
                                                <td>{{item.APIName}}</td>
                                                <td>{{item.ComponentType}}</td>
                                                <td>{{item.Label}}</td>
                                                <td>
                                                    <span ng-if="item.Deployed"><img src="/img/checkbox_checked.gif" alt="Checked" width="21" height="16" class="checkImg" title="Checked"/></span>
                                                    <span ng-if="!item.Deployed"><img src="/img/checkbox_unchecked.gif" alt="Not Checked" width="21" height="16" class="checkImg"  title="Not Checked"/></span>
                                                    
                                                </td>
                                                <td>
                                                    <span ng-if="item.inBranch"><img src="/img/checkbox_checked.gif" alt="Checked" width="21" height="16" class="checkImg" title="Checked"/></span>
                                                    <span ng-if="!item.inBranch"><img src="/img/checkbox_unchecked.gif" alt="Not Checked" width="21" height="16" class="checkImg"  title="Not Checked"/></span>
                                                </td>
                                                <td>
                                                    <span ng-if="item.IsLastVersion"><img src="/img/checkbox_checked.gif" alt="Checked" width="21" height="16" class="checkImg" title="Checked"/></span>
                                                    <span ng-if="!item.IsLastVersion"><img src="/img/checkbox_unchecked.gif" alt="Not Checked" width="21" height="16" class="checkImg"  title="Not Checked"/></span>
                                                </td>
                                                
                                                <!-- <td><button  style="" type="button"  ng-click="OpenPopUpInfo(item)" class="btn btn-success btn-xs">Info Item</button></td> -->
                                                
                                                <td style="text-align: center;">
                                                    <span ng-show="item.AutoMergeStart && !item.AutoMergeFinish"><img width="20" height="20" src="{!URLFOR($Resource.Merge,'Merge/image/animatedEllipse.gif')}"/></span>
                                                    
                                                    <span style="cursor: pointer;" ng-click="getMergeInfo(item)" ng-show="item.AutoMergeFinish && item.AutoMergeStatus && !item.IsManualMerge"><img width="80" height="20" src="{!URLFOR($Resource.Merge,'Merge/image/conflict.png')}"/></span>
                                                    <span style="cursor: pointer;" ng-click="getMergeInfo(item)" ng-show="item.AutoMergeFinish && (!item.AutoMergeStatus || item.IsManualMerge)"><img width="20" height="20" src="{!URLFOR($Resource.Merge,'Merge/image/merge-128.png')}"/></span>
                                                    
                                                    <span ng-show=""></span>
                                                </td>
                                                
                                                
                                            </tr>
                                        </tbody>
                                    </table>
                                </apex:pageBlockSection>
                                <apex:outputPanel html-ng-show="FirstStepItems.length > 0" styleClass="pagination" layout="block" style="text-align: center;">
                                    <apex:commandbutton html-ng-click="conflictShowFirst();" onClick="return false;" value="First" reRender="none" html-ng-disabled="conflictIsPrevious();"/>
                                    <apex:commandbutton html-ng-click="conflictListPrevious();" onClick="return false;" value="Previous" reRender="none" html-ng-disabled="conflictIsPrevious();"/>
                                    Total {{(FirstStepItems).length}} components, Page {{conflictCurrentPageNo((FirstStepItems).length)}} of {{conflictTotalPageCount((FirstStepItems).length)}}
                                    <apex:commandbutton html-ng-click="conflictListNext((FirstStepItems).length);" onClick="return false;" value="Next" reRender="none" html-ng-disabled="conflictIsNext((FirstStepItems).length);"/>
                                    <apex:commandbutton html-ng-click="conflictShowLast((FirstStepItems).length);" onClick="return false;" value="Last" reRender="none" html-ng-disabled="conflictIsNext((FirstStepItems).length);"/>
                                </apex:outputPanel>
                            </apex:pageBlock>

                            <!-- <apex:pageBlock title="Components that will not be committed"> -->
                            <apex:pageBlock title="Already Updated Components">
                                <!-- <p>The same version of the component has been found in the repository, hence will not be committed.</p> -->
                                <p>This section shows the components which already exist in the remote repository.</p>
                                <apex:pageBlockSection columns="1">
                                    <table ng-show="notToCommitLi.length > 0" class="list">
                                        <thead>
                                            <tr class="headerRow">
                                                <th>No.</th>
                                                <th ng-repeat = "(key, value) in notToCommitFieldSet">
                                                    <a ng-click="notRefreshOrderBy(key)">{{ notOrderByColumn == key ? notIsReverse ? value+' ▼' : value+' ▲' : value }}</a>
                                                </th>
                                            </tr>
                                        </thead>
                                        <tbody>
                                            <tr ng-repeat = "meta in notToCommitLi | orderBy: notOrderByColumn : notIsReverse | limitTo: notViewLimit" ng-if="$index >= notMetaOffSet" class="dataRow"
                                            onmouseover="if (window.hiOn){hiOn(this);} " onmouseout="if (window.hiOff){hiOff(this);} ">
                                                <td>{{ $index+1 }}</td>
                                                <td ng-repeat = "(key, value) in notToCommitFieldSet">
                                                    {{ meta[key] }}
                                                </td>
                                            </tr>
                                        </tbody>
                                    </table>
                                </apex:pageBlockSection>
                                <apex:outputPanel html-ng-show="notToCommitLi.length > 0" styleClass="pagination" layout="block" style="text-align: center;">
                                    <apex:commandbutton html-ng-click="notShowFirst();" onClick="return false;" value="First" reRender="none" html-ng-disabled="notIsPrevious();"/>
                                    <apex:commandbutton html-ng-click="notListPrevious();" onClick="return false;" value="Previous" reRender="none" html-ng-disabled="notIsPrevious();"/>
                                    Total {{(notToCommitLi).length}} components, Page {{notCurrentPageNo((notToCommitLi).length)}} of {{notTotalPageCount((notToCommitLi).length)}}
                                    <apex:commandbutton html-ng-click="notListNext((notToCommitLi).length);" onClick="return false;" value="Next" reRender="none" html-ng-disabled="notIsNext((notToCommitLi).length);"/>
                                    <apex:commandbutton html-ng-click="notShowLast((notToCommitLi).length);" onClick="return false;" value="Last" reRender="none" html-ng-disabled="notIsNext((notToCommitLi).length);"/>
                                </apex:outputPanel>
                            </apex:pageBlock>
                        </apex:pageBlock>
                    </fieldset>
                </div>
            </div>
        </div>
        <apex:actionfunction name="createTempRecordsForCommit" action="{!createTempRecordsForCommit}" rerender="none" oncomplete="checkExceptionOnComplete('{!logId}','{!exceptionMessage}');">
            <apex:param assignTo="{!commitStr}" value="" name="commitStr"/>
        </apex:actionfunction>
        <apex:actionfunction name="createLog" action="{!createLog}" rerender="none" oncomplete="createRequestForRetrieval('{!logId}','{!exceptionMessage}');"/>
        <apex:actionfunction name="createSyncLog" action="{!createSyncLog}" rerender="none" oncomplete="handleSync('{!syncId}','{!exceptionMessage}');"/>
        <apex:actionfunction name="finishCommit" action="{!finishCommit}" rerender="none"/>
    </apex:form>
    <script>
        Visualforce.remoting.timeout = 120000;
        String.prototype.endsWith = function(pattern) {
            var d = this.length - pattern.length;
            return d >= 0 && this.lastIndexOf(pattern) === d;
        };
        String.prototype.trunc = String.prototype.trunc ||
              function(n){
                  return (this.length > n) ? this.substr(0,n-1)+'...' : this.substr(0);
              };
        Number.prototype.trunc = Number.prototype.trunc ||
              function(n){
                  return this.toString();
              };

        var localUser = '{!localUser}';
        var supportedTypes = '{!supportedTypes}';
        var supportedTypesForCurrentOrg = [];
        var flosumsf = jsforce;
        var selfConn;
        var filterValue;
        var retrieveStandardComponent = false;
        var apiVersion = {!localApiVersion};
        var normalZip = new JSZip();
        var logId;
        var syncId;
        var filterId;
        var processedFolderMap = {};
        
        var permissionMap = {};
        permissionMap['CustomObject'] = ['*'];
        permissionMap['ApexClass'] = ['*'];
        permissionMap['ApexPage'] = ['*'];
        permissionMap['Layout'] = ['*'];
        permissionMap['CustomTab'] = ['*'];
        permissionMap['CustomApplication'] = ['*'];
        permissionMap['ExternalDataSource'] = ['*'];
        permissionMap['CustomPermission'] = ['*'];
        
        var manageableStateToRetrieve = {};
        manageableStateToRetrieve['released'] = 'released';
        manageableStateToRetrieve['unmanaged'] = 'unmanaged';
        manageableStateToRetrieve['beta'] = 'beta';
        manageableStateToRetrieve[undefined] = 'undefined';
        
        var typeToFolderMap = {};
        typeToFolderMap['Document'] = 'DocumentFolder';
        typeToFolderMap['Dashboard'] = 'DashboardFolder';
        typeToFolderMap['Report'] = 'ReportFolder';
        typeToFolderMap['EmailTemplate'] = 'EmailFolder';
        
        var folderToTypeMap = {};
        folderToTypeMap['DocumentFolder'] = 'Document';
        folderToTypeMap['DashboardFolder'] = 'Dashboard';
        folderToTypeMap['ReportFolder'] = 'Report';
        folderToTypeMap['EmailFolder'] = 'EmailTemplate';
        
        var bundleTypes = {};
        bundleTypes['AuraDefinitionBundle'] = 'AuraDefinitionBundle';
        
        var mmap = {};
        mmap['CustomLabel'] = true;
        mmap['CustomField'] = true;
        mmap['CompactLayout'] = true;
        mmap['WebLink'] = true;
        mmap['RecordType'] = true;
        mmap['ListView'] = true;
        mmap['FieldSet'] = true;
        mmap['AssignmentRule'] = true;
        mmap['AutoResponseRule'] = true;
        mmap['ValidationRule'] = true;
        mmap['WorkflowTask'] = true;
        mmap['WorkflowOutboundMessage'] = true;
        mmap['WorkflowFieldUpdate'] = true;
        mmap['WorkflowAlert'] = true;
        mmap['WorkflowRule'] = true;
        mmap['SharingOwnerRule'] = true;
        mmap['SharingCriteriaRule'] = true;
        mmap['BusinessProcess'] = true;
        mmap['SharingReason'] = true;
        mmap['EscalationRule'] = true;
        mmap['MatchingRule'] = true;
        
        var filteredMetaItems = {};
        
        var requestMetaTypeLi = [];
        var requestIndex = 0;
        var firstLimit = 3000;
        
        var currentRequestLi = [];
        var currentRequestIndex = 0;
        var AsyncIdMap = {};
        var AsyncIdsLi = [];
        var AsyncIdsIndex = 0;
        var RemainingAsyncIdLi = [];
        
        var remainingTypesMap = {};
        var fileMap = {};
        
        var differentRetrievalMap = {};
        differentRetrievalMap['Document'] = 'Document';
        differentRetrievalMap['Dashboard'] = 'Dashboard';
        differentRetrievalMap['Report'] = 'Report';
        differentRetrievalMap['EmailTemplate'] = 'EmailTemplate';
        differentRetrievalMap['Flow'] = 'Flow';
        differentRetrievalMap['CustomField'] = 'CustomField';
        differentRetrievalMap['SharingOwnerRule'] = 'SharingOwnerRule';
        differentRetrievalMap['SharingCriteriaRule'] = 'SharingCriteriaRule';
        
        var customObjectTranslationsInfoSet = ['CustomField','QuickAction','RecordType','SharingReason','ValidationRule','WebLink','WorkflowTask','Layout'];
        var translationsInfoSet = ['CustomApplication','CustomLabels','CustomPageWebLink','CustomTab','QuickAction','ReportType','Scontrol'];
        
        var visibleStateConditionStr = '';
        var visibleStateMainFilterList = [];
        var visibleStateEnableFilterLogic = [];

        var beforOpenMainTag = '';
        var openMainTag = '';
        var betweenMainTag = '';        
        var closeMainTag = '';
        
        function setFilterFromLookup(filterIndex,fieldType,selectedItems)
        {
            angular.element(document.getElementById('angularControllerId')).scope().setFilterRow(filterIndex,fieldType,selectedItems);
        }
        
        function convertGMTToLocalTime(gmtTime)
        {
            try
            {
                var localZoneStr = '{!localZoneStr}';
                var localTime  = moment.utc(gmtTime);
                return localTime.tz(localZoneStr).format('YYYY-MM-DD HH:mm:ss');
            }
            catch(ex)
            {
                return gmtTime;
            }
        }

        var myApp = angular.module("localworkspace", ['ngDialog', 'base64']);
        //directive merge xml
        var objectcollectionTemplate = '<div ng-style="getColor()">'+
                                            /*'<meta http-equiv="Content-Type" content="text/html; charset=utf-8" >'+*/
                                            '<span ng-if="isObject">'+
                                                 '<table style="border:1px solid black;">'+
                                                    '<tbody>'+
                                                        //'<tr ng-repeat="(key, member) in object">'+
                                                        '<tr ng-repeat="(key, member) in object track by $index">'+
                                                            '<td style="height: 28px; border-top: 1px solid #9C9C9C; border-bottom: 1px solid #9C9C9C; border-left: 1px solid #9C9C9C; border-right: 1px solid #9C9C9C">'+
                                                                /*'<strong escape="false">{} {{key}} {{memberInfo(member)}}</strong>'+*/
                                                                '<strong>{{key.trunc(15)}} {{memberInfo(member)}}</strong>'+
                                                            '</td>'+
                                                            '<td style="border-top: 1px solid #9C9C9C; border-bottom: 1px solid #9C9C9C; border-left: 1px solid #9C9C9C; border-right: 1px solid #9C9C9C">'+
                                                                '<member  member="member" setinfo="setinfo"></member>'+
                                                            '</td>'+
                                                        '</tr>'+
                                                    '</tbody>'+
                                                '</table>'+
                                            '</span>'+
                                            /*'</meta>'+*/
                                            
                                            '<span ng-if="isValue">'+
                                                '<span ng-if="object.DiffType == VALUE_UNCHANGED">{{object.NewData}}</span>' + 
                                                '<span ng-if="object.DiffType != VALUE_UNCHANGED && IsBase"  style="background-color:#717ECD; color:#F0F1F2;">{{object.OldData}}</span>' + 
                                                '<span ng-if="object.DiffType != VALUE_UNCHANGED && !IsBase"  style="background-color:#4EB1CB; color:#F0F1F2;">{{object.DiffViewValue}}</span>' +
                                                '<span ng-if="object.DiffType != VALUE_UNCHANGED && !IsBase && object.DiffType != VALUE_DELETED && !object.DiffAction"  class="iconnDiff glyphicon glyphicon-triangle-left" style="top: 0px;margin-left: 2px;"  ng-click="edit(object, false)"></span>'+
                                                '<span ng-if="object.DiffType != VALUE_UNCHANGED && !IsBase && object.DiffType != VALUE_DELETED && object.DiffAction"  class="iconnDiff glyphicon glyphicon-triangle-right" style="top: 0px;margin-left: 2px;"  ng-click="edit(object, false)"></span>'+
                                                '<span ng-if="object.DiffType != VALUE_UNCHANGED && IsBase && object.DiffType != VALUE_CREATED && !object.DiffAction"  class="iconnDiff glyphicon glyphicon-triangle-right" style="top: 0px;margin-left: 2px;"  ng-click="edit(object, true)"></span>'+
                                                '<span ng-if="object.DiffType != VALUE_UNCHANGED && IsBase && object.DiffType != VALUE_CREATED && object.DiffAction"  class="iconnDiff glyphicon glyphicon-triangle-left" style="top: 0px;margin-left: 2px;"  ng-click="edit(object, true)"></span>'+
                                            '</span>'+
                                            '<span ng-if="isArray">'+
                                                 '<span ng-if="IsArrayText">'+
                                                    '<table style="border:1px solid black;">'+
                                                        '<tbody >'+
                                                            '<tr style="background-color: #FBFFB7;">'+
                                                                '<td> '+
                                                                '</td>'+
                                                                '<td><strong>Text</strong>'+
                                                                '</td>'+
                                                            '</tr>'+
                                                            '<tr ng-repeat="(key, member) in object">'+
                                                            //'<tr ng-repeat="(key, member) in object track by $index">'+
                                                                '<td style="background-color: #FBFFB7;">'+
                                                                    '<strong>{{key}}</strong>'+
                                                                '</td>'+
                                                                '<td >'+
                                                                    '<member  member="member" setinfo="setinfo"></member>'+
                                                                '</td>'+
                                                            '</tr>'+
                                                        '</tbody>'+
                                                    '</table>'+
                                                 '</span>'+
                                                 '<span ng-if="!IsArrayText">'+
                                                    '<table style="border:1px solid black;">'+
                                                        '<tbody >'+
                                                            '<tr style="background-color: #FBFFB7;">'+
                                                                '<td ng-repeat="keyQ in keys"><strong>{{keyQ}}</strong>'+
                                                                '</td>'+
                                                            '</tr>'+
                                                            '<tr ng-repeat="(key, member) in object">'+
                                                            //'<tr ng-repeat="(key, member) in object track by $index">'+
                                                                '<td ng-repeat="keyQ in keys" ng-style="CheckStyle(keyQ)" class="contColor">'+
                                                                    '<span  ng-if="!CheckKey(keyQ)">'+
                                                                        '<strong>{{key}}</strong>'+
                                                                     '</span>'+
                                                                     '<span ng-if="CheckKey(keyQ)">'+
                                                                        '<member  member="member[keyQ]" setinfo="setinfo"></member>'+
                                                                     '</span>'+
                                                                '</td>'+
                                                                
                                                            '</tr>'+
                                                        '</tbody>'+
                                                    '</table>'+
                                                 '</span>'+
                                            '</span>'+
                                        '</div>';
        myApp.directive('objectcollection', function ($compile) {
            return {
                restrict: "E",
                //replace: true,
                scope: {
                    object: '=',
                    setinfo: '='
                },
                template:   objectcollectionTemplate,
                link: function (scope, element, attrs) {
                    var el = $(element);
                    var cont = el.parents(".contColor");
                    var colorCont = null;
                    if (cont.length > 0) {
                        colorCont = $(cont[0]);
                    }
                    var inf = el.parents("#BASE");
                    scope.IsBase = false;
                    if (inf.length > 0) {
                        scope.IsBase = true;
                    }
                    scope.VALUE_CREATED= 'created';
                    scope.VALUE_UPDATED= 'updated';
                    scope.VALUE_DELETED= 'deleted';
                    scope.VALUE_UNCHANGED= 'unchanged';
                    scope.isObject = false;
                    scope.isArray = false;
                    scope.isValue = false;
                    
                    
                    scope.getColor = function() {
                        if (scope.isValue) {
                        }
                        else if (!scope.isArray && !scope.isObject) {
                            //colorCont.css('background-color','#CECCCC');
                        }
                        return {};
                    }
                    scope.memberInfo = function(mm) {
                        if (angular.isObject(mm) && mm.DiffType == null) {
                            var checkMassive = true;
                            var index = 0;
                            for (var key in mm) {
                                if (!angular.isNumber(parseInt(key)) || isNaN(parseInt(key))) {
                                    checkMassive = false;
                                }
                                else {
                                    index ++;
                                }
                            }
                            if (checkMassive) {
                                return '(' + index + ')';
                            }
                            
                        }
                        return '';
                    }
                    scope.edit = function(obj, check) {
                        console.log(obj);
                        if (check) {
                            if (obj.DiffAction) {
                                obj.DiffViewValue = obj.NewData;
                                obj.DiffAction = false;
                            }
                            else {
                                obj.DiffViewValue = obj.OldData;
                                obj.DiffAction = true;
                            }
                            
                        }
                        else {
                            if (obj.DiffAction) {
                                obj.DiffViewValue = obj.NewData;
                                obj.DiffAction = false;
                            }
                            else {
                                obj.DiffViewValue = obj.OldData;
                                obj.DiffAction = true;
                            }
                            
                        }
                        scope.setinfo();
                    }
                    if (angular.isObject(scope.object) && scope.object.DiffType == null) {
                        var checkMassive = true;
                        for (var key in scope.object) {
                            if (!angular.isNumber(parseInt(key)) || isNaN(parseInt(key))) {
                                checkMassive = false;
                            }
                        }
                        if (checkMassive) {
                            scope.isArray = true;
                        }
                        else {
                            scope.isObject = true;
                        }
                    }
                    else if (angular.isArray(scope.object) ) {
                        scope.isArray = true;
                    }
                    else if (typeof scope.object != "undefined"){
                        scope.isValue = true;
                    }
                    scope.keys =[];
                    scope.keys.push('');
                    scope.IsArrayText = true;
                    scope.CheckKey = function(param) {
                        if (param == '') {
                            return false;
                        }
                        else {
                            return true;
                        }
                    }
                    scope.CheckStyle = function(param) {
                        if (param == '') {
                            return {'background-color': '#FBFFB7'};
                        }
                        else {
                            return {};
                        }
                    }
                    
                    if (scope.isArray) {
                        for (var key in scope.object) {
                            var obj = scope.object[key];
                            if (angular.isObject(obj) && obj.DiffType == null) {
                                scope.IsArrayText = false;
                                for (var key in obj) {
                                    if ($.inArray( key, scope.keys)  == -1 && key != '$$hashKey') {
                                        scope.keys.push(key);
                                    }
                                }
                            }
                        }
                        
                    }
                }
            }
        })

        myApp.directive('member', function ($compile) {
            return {
                restrict: "E",
                scope: {
                    member: '=',
                    setinfo: '='
                },
                template:   '<div></div>',
                link: function (scope, element, attrs) {
                    scope.VALUE_CREATED= 'created';
                    scope.VALUE_UPDATED= 'updated';
                    scope.VALUE_DELETED= 'deleted';
                    scope.VALUE_UNCHANGED= 'unchanged';
                    
                    
                    scope.memberNew;
                    var IsObject = false;
                    if (angular.isArray(scope.member)) {
                        scope.memberNew = [];
                    }
                    else if (angular.isObject(scope.member)) {
                        scope.memberNew = {};
                    }

                    if ((angular.isArray(scope.member) || angular.isObject(scope.member)) && scope.member.DiffType == null) {
                        var IsAdd = false;
                        for (var key in scope.member) {
                            var Obj  = scope.member[key];
                            if (Obj.DiffType != null && Obj.DiffType != this.VALUE_UNCHANGED) {
                                scope.memberNew[key] = Obj;
                                IsAdd = true;
                            }
                            else {
                                var check1 = checkView(Obj);
                                if (check1) {
                                    scope.memberNew[key] = Obj;
                                    IsAdd = true;
                                }
                            }
                            
                        }
                        if (IsAdd) {
                            element.append("<objectcollection object='memberNew' setinfo='setinfo'></objectcollection>"); 
                            $compile(element.contents())(scope);
                        }
                        
                        
                    }
                    else {
                        element.append("<objectcollection object='member' setinfo='setinfo'></objectcollection>"); 
                        $compile(element.contents())(scope);
                    }
                    
                    function checkView(members) {
                        var returnInfo = false; 
                        for (var key in members) {
                            var on = members[key];
                            if ((angular.isArray(on) || angular.isObject(on)) && on.DiffType == null) {
                                var ch = checkView(on);
                                if (ch) {
                                    returnInfo = true;
                                }
                            }
                            else if (on != null && on.DiffType != null && on.DiffType != 'unchanged') {
                                returnInfo = true;
                            }
                        }
                        return returnInfo;
                    }
                    
                }
            }
        })

        var mergeinfoTemplate = '<div ng-show="!Show">'+
                                    '<div class="spinner">'+
                                      '<div class="rect1"></div>'+
                                      '<div class="rect2"></div>'+
                                      '<div class="rect3"></div>'+
                                      '<div class="rect4"></div>'+
                                      '<div class="rect5"></div>'+
                                    '</div>'+
                                '</div>'+
                                '<div ng-show="table.length > 0 && Show">'+
                                    '<div >'+
                                        /*'<div style="width: 48%;float: left;border: 1px solid #36a0fe;;border-radius: 6px;padding: 5px;text-align: center;background-color: #36a0fe; position">'+
                                            '<strong>Source File</strong>'+
                                        '</div>'+
                                        '<div style="float: left;width: 4%;height: 12px;"></div>'+
                                        '<div style="width: 48%;float: left;border: 1px solid #13FF00;border-radius: 6px;padding: 5px;text-align: center;background-color: #13FF00;">'+
                                            '<strong>Target File</strong>'+
                                        '</div>'+*/
                                        '<div style="width: 48%;float: left; padding: 5px;text-align: center; position">'+
                                            '<strong>Source File</strong>'+
                                        '</div>'+
                                        '<div style="float: left;width: 4%;height: 12px;"></div>'+
                                        '<div style="width: 48%;float: left; padding: 5px;text-align: center;">'+
                                            '<strong>Target File</strong>'+
                                        '</div>'+
                                    '</div>'+
                                    '<div >'+
                                        '<div style="width: 50%; float: left;">'+
                                            /*'<div class="BASE" style="overflow: scroll;height: 600px;  border: 1px solid #9C9C9C; border-radius: 6px; padding: 5px; margin-right: 23px;">'+*/
                                            '<div class="BASE" style="overflow-x: scroll; border: 1px solid #9C9C9C; border-radius: 6px; padding: 5px; margin-right: 23px;">'+
                                                '<table style="border:1px solid black;">'+
                                                    '<tbody id="display">'+
                                                        '<tr ng-repeat="line in table" style="height: 27px;">'+
                                                            '<td style="border-top: 1px solid #9C9C9C; border-bottom: 1px solid #9C9C9C; border-left: 1px solid #9C9C9C; border-right: 1px solid #9C9C9C">'+
                                                                '{{line.indexBase}}'+
                                                            '</td>'+
                                                            '<td style="border-top: 1px solid #9C9C9C; border-bottom: 1px solid #9C9C9C; border-left: 1px solid #9C9C9C; border-right: 1px solid #9C9C9C">'+
                                                                '<pre class="{{line.BaseClass}}" >{{line.valueBase}}</pre>'+
                                                            '</td>'+
                                                        '</tr>'+
                                                    '</tbody>'+
                                                '</table>'+
                                            '</div>'+
                                        '</div>'+

                                        '<div style="width: 46px;float: left; margin-left: -23px; padding-top: 6px;">'+
                                            /*'<table  style="height: 600px;"" >'+*/
                                            '<table style="border:1px solid black;">'+
                                                '<tbody id="displayA">'+
                                                    '<tr ng-repeat="line in table" style="height: 27px;">'+
                                                        '<td style="border-top: 1px solid #9C9C9C; border-bottom: 1px solid #9C9C9C; border-left: 1px solid #9C9C9C; border-right: 1px solid #9C9C9C" ng-show="line.removed && line.Button">'+
                                                            '<span ng-show="!line.edit" class="iconnDiff glyphicon glyphicon-plus" ng-click="remove(line)"></span>'+
                                                            '<span ng-show="line.edit" class="iconnDiff glyphicon glyphicon-fast-backward" ng-click="removeBack(line)"></span>'+
                                                        '</td>'+
                                                        '<td style="width: 23px; border-top: 1px solid #9C9C9C; border-bottom: 1px solid #9C9C9C; border-left: 1px solid #9C9C9C; border-right: 1px solid #9C9C9C" ng-show="!line.removed">'+
                                                            '<div class="EmpyBlock"></div>'+
                                                        '</td>'+
                                                        '<td style="border-top: 1px solid #9C9C9C; border-bottom: 1px solid #9C9C9C; border-left: 1px solid #9C9C9C; border-right: 1px solid #9C9C9C" ng-show="line.add && line.Button">'+
                                                            '<span ng-show="!line.edit" class="iconnDiff glyphicon glyphicon-minus" ng-click="add(line)"></span>'+
                                                            '<span ng-show="line.edit" class="iconnDiff glyphicon glyphicon-fast-forward" ng-click="addBack(line)"></span>'+
                                                        '</td>'+
                                                        '<td style="width: 23px; border-top: 1px solid #9C9C9C; border-bottom: 1px solid #9C9C9C; border-left: 1px solid #9C9C9C; border-right: 1px solid #9C9C9C" ng-show="!line.add">'+
                                                            '<div class="EmpyBlock"></div>'+
                                                        '</td>'+
                                                    '</tr>'+
                                                 '</tbody>'+
                                            '</table>'+
                                        '</div>'+
                                        
                                        '<div style="width: 50%; float: right; margin-left: -23px;">'+
                                            /*'<div class="NEW" style="overflow: scroll;height: 600px;  border: 1px solid #9C9C9C; border-radius: 6px; padding: 5px; margin-left: 23px;">'+*/
                                            '<div class="NEW" style="overflow-x: scroll; border: 1px solid #9C9C9C; border-radius: 6px; padding: 5px; margin-left: 23px;">'+
                                                '<table style="border:1px solid black;">'+
                                                    '<tbody id="display2">'+
                                                        '<tr ng-repeat="line in table" style="height: 27px;">'+
                                                            '<td style="border-top: 1px solid #9C9C9C; border-bottom: 1px solid #9C9C9C; border-left: 1px solid #9C9C9C; border-right: 1px solid #9C9C9C">'+
                                                                '{{line.indexNew}}'+
                                                            '</td>'+
                                                            '<td style="border-top: 1px solid #9C9C9C; border-bottom: 1px solid #9C9C9C; border-left: 1px solid #9C9C9C; border-right: 1px solid #9C9C9C">'+
                                                                '<pre class="{{line.NewClass}}" >{{line.valueNew}}</pre>'+
                                                            '</td>'+
                                                        '</tr>'+
                                                    '</tbody>'+
                                                '</table>'+
                                            '</div>'+
                                        '</div>'+
                                    '</div>'+
                                '</div>';
        myApp.directive("mergeinfo", [function () {
            return {
                scope: {
                    sourse: '@',
                    target: '@',
                    file: "="
                },
                restrict: 'E',
                template: mergeinfoTemplate,
                link: function (scope, element, attributes, ngModelController) {
                    console.log(scope);
                    console.log(ngModelController);
                    var BaseElement = $(element).find(".BASE");
                    var NewElement = $(element).find(".NEW");
                    console.log(BaseElement);
                    scope.Show = false;
                    scope.start = false;
                    scope.table = [];
                    scope.returnValue = '';
                    BaseElement.scroll(function(event){
                        if (event.type == 'scroll') {
                            var inf = event.currentTarget.scrollLeft;
                            NewElement.scrollLeft(inf);
                           /* var infV = event.currentTarget.scrollTop;
                            NewElement.scrollTop(infV);*/
                        }
                    })
                    NewElement.scroll(function(event){
                        if (event.type == 'scroll') {
                            var inf = event.currentTarget.scrollLeft;
                            BaseElement.scrollLeft(inf);
                            /*var infV = event.currentTarget.scrollTop;
                            BaseElement.scrollTop(infV);*/
                        }
                    })
                    scope.$watch('sourse', function(newValue, oldValue) {
                      if (scope.sourse != null && scope.sourse != '' && scope.start) {
                          getViewText();
                      }
                      else if (scope.sourse != null && scope.sourse != '' && !scope.start) {
                        scope.start = true;
                      }
                    });
                    scope.$watch('target', function(newValue, oldValue) {
                      if (scope.target != null && scope.target != '' && scope.start) {
                          getViewText();
                      }
                      else if (scope.target != null && scope.target != '' && !scope.start) {
                        scope.start = true;
                      }
                    });
                    
                    scope.add = function(line) {
                        for (var x= line.index -1; x< scope.table.length ; x++) {
                            if (scope.table[x].add) {
                                scope.table[x].edit = true;
                                scope.table[x].valueNew = '';
                                scope.table[x].BaseClass = 'editClass';
                                scope.table[x].NewClass = 'editClass';
                            }
                            else {
                                break;
                            }
                        }
                        scope.getReturnModel();
                        
                        
                    }
                    
                    scope.addBack = function(line) {
                        for (var x= line.index -1; x< scope.table.length ; x++) {
                            if (scope.table[x].add) {
                                scope.table[x].edit = false;
                                scope.table[x].valueNew = scope.table[x].NewBackup;
                                scope.table[x].BaseClass = '';
                                scope.table[x].NewClass = 'addClass';
                            }
                            else {
                                break;
                            }
                        }
                        scope.getReturnModel();
                        
                        
                    }
                    
                    scope.remove = function(line) {
                        for (var x= line.index-1; x< scope.table.length ; x++) {
                            if (scope.table[x].removed) {
                                scope.table[x].edit = true;
                                scope.table[x].valueNew = scope.table[x].valueBase;
                                scope.table[x].BaseClass = 'editClass';
                                scope.table[x].NewClass = 'editClass';
                            }
                            else {
                                break;
                            }
                        }
                        scope.getReturnModel();
                        
                    }
                    
                    scope.removeBack = function(line) {
                        for (var x= line.index -1; x< scope.table.length ; x++) {
                            if (scope.table[x].removed) {
                                scope.table[x].edit = false;
                                scope.table[x].valueNew = '';
                                scope.table[x].BaseClass = 'removeClass';
                                scope.table[x].NewClass = '';
                            }
                            else {
                                break;
                            }
                        }
                        scope.getReturnModel();
                        
                    }
                    
                    scope.getReturnModel = function () {
                        var returnST = '';
                        for (var x= 0; x< scope.table.length ; x++) {
                            var line = scope.table[x];
                            if (line.removed && line.edit || line.add && !line.edit || !line.removed && !line.add) {
                                returnST += line.valueNew + '\n';
                            }
                        }
                        scope.file = returnST;
                        
                        
                    }
                    
                    function getViewText() {
                        scope.table = [];
                        var diff = JsDiff.diffLines(scope.sourse, scope.target);
                        
                        var indexBase = 1;
                        var indexNew = 1;
                        var index = 1;
                        diff.forEach(function(part){
                            var lin = part.value.split('\n');
                            var color = part.added ? '#4EB1CB' :
                            part.removed ? '#717ECD' : 'white';
                            var ButtonCheck = false;
                            for (var x=0; x< lin.length; x++) {
                                if (x == (lin.length -1) && lin[x] == '') {
                                    continue;
                                }
                                var Line = {};
                                Line.index = index;
                                Line.edit = false;
                                
                                index++;
                                if (part.added) {
                                    Line.indexBase = '';
                                    Line.indexNew = indexNew;
                                    Line.valueBase = '';
                                    Line.valueNew = lin[x] == '' ? '': lin[x];
                                    Line.NewBackup = lin[x] == '' ? '': lin[x];
                                    Line.add = true;
                                    Line.NewClass = 'addClass'
                                    if (!ButtonCheck) {
                                        Line.Button = true;
                                        ButtonCheck = true;
                                    }
                                    else {
                                        Line.Button = false;
                                    }
                                    Line.color = color;
                                    Line.removed = false;
                                    indexNew++;
                                }
                                else if (part.removed) {
                                    Line.indexBase = indexBase;
                                    Line.indexNew = '';
                                    Line.valueBase = lin[x] == '' ? '': lin[x];
                                    Line.valueNew = '';
                                    Line.add = false;
                                    if (!ButtonCheck) {
                                        Line.Button = true;
                                        ButtonCheck = true;
                                    }
                                    else {
                                        Line.Button = false;
                                        
                                    }
                                    Line.color = color;
                                    Line.removed = true;
                                    Line.BaseClass = 'removeClass'
                                    indexBase++;
                                }
                                else {
                                    Line.indexBase = indexBase;
                                    Line.indexNew = indexNew;
                                    Line.valueBase = lin[x] != '' ? lin[x]: '';
                                    Line.valueNew = lin[x] != '' ? lin[x]: '';
                                    Line.add = false;
                                    Line.color = color;
                                    Line.removed = false;
                                    indexBase++;
                                    indexNew++;
                                }
                                scope.table.push(Line);
                            }
                       });
                       scope.Show = true;
                       console.log(scope.table);
                       scope.getReturnModel();
                    }
                    
                }
            }
        }]);
        
        var mergeXmlTemplate = '<div ng-show="!Show">'+
                                    '<div class="spinner">'+
                                      '<div class="rect1"></div>'+
                                      '<div class="rect2"></div>'+
                                      '<div class="rect3"></div>'+
                                      '<div class="rect4"></div>'+
                                      '<div class="rect5"></div>'+
                                    '</div>'+
                                '</div>'+
                                '<div ng-show="Show">'+
                                    '<div >'+
                                        /*'<div style="width: 49%;float: left;border: 2px solid #36a0fe;;border-radius: 6px;padding: 5px;text-align: center;background-color: #36a0fe;">'+
                                            '<strong>Source File</strong>'+
                                        '</div>'+
                                        '<div style="width: 49%;float: left;border: 2px solid #13FF00;border-radius: 6px;padding: 5px;text-align: center;background-color: #13FF00;">'+
                                            '<strong>Target File</strong>'+
                                        '</div>'+*/
                                        '<div style="width: 49%;float: left; padding: 5px;text-align: center;">'+
                                            '<strong>Source File</strong>'+
                                        '</div>'+
                                        '<div style="width: 49%;float: left; padding: 5px;text-align: center;">'+
                                            '<strong>Target File</strong>'+
                                        '</div>'+
                                    '</div>'+                       
                                    '<div >'+
                                        '<div id="BASE" style="width: 49%; height: 600px; overflow: scroll;float: left;border: 2px solid #9C9C9C;border-radius: 6px;padding: 5px;">'+
                                            '<table style="border:1px solid black;">'+
                                                '<tbody id="display">'+
                                                    '<tr ng-repeat="(key, member) in diffXML">'+
                                                        '<td style="height: 28px; border-top: 1px solid #9C9C9C; border-bottom: 1px solid #9C9C9C; border-left: 1px solid #9C9C9C; border-right: 1px solid #9C9C9C">'+
                                                            /*'{} {{key}}'+*/
                                                            '{{key}}'+
                                                        '</td>'+
                                                        '<td style="height: 28px; border-top: 1px solid #9C9C9C; border-bottom: 1px solid #9C9C9C; border-left: 1px solid #9C9C9C; border-right: 1px solid #9C9C9C">'+
                                                            '<member  member="member" setinfo="setinfo"></member>'+
                                                        '</td>'+
                                                    '</tr>'+
                                                '</tbody>'+
                                            '</table>'+
                                        '</div>'+
                                        '<div id="NEW" style="width: 49%; height: 600px; overflow: scroll;border: 2px solid #9C9C9C;border-radius: 6px;padding: 5px;">'+
                                            '<table style="border:1px solid black;">'+
                                                '<tbody id="display2">'+
                                                    '<tr ng-repeat="(key, member) in diffXML">'+
                                                        '<td style="height: 28px; border-top: 1px solid #9C9C9C; border-bottom: 1px solid #9C9C9C; border-left: 1px solid #9C9C9C; border-right: 1px solid #9C9C9C">'+
                                                            /*'{} {{key}}'+*/
                                                            '{{key}}'+
                                                        '</td>'+
                                                        '<td style="height: 28px; border-top: 1px solid #9C9C9C; border-bottom: 1px solid #9C9C9C; border-left: 1px solid #9C9C9C; border-right: 1px solid #9C9C9C">'+
                                                            '<member  member="member" setinfo="setinfo"></member>'+
                                                        '</td>'+
                                                    '</tr>'+
                                                '</tbody>'+
                                            '</table>'+
                                        '</div>'+
                                    '</div>'+
                                '</div>';
        myApp.directive("mergeXml", [function () {
            return {
                scope: {
                    sourse: '@',
                    target: '@',
                    file: "="
                },
                restrict: 'E',
                template: mergeXmlTemplate,
                link: function (scope, element, attributes, ngModelController) {
                    
                    console.log(scope);
                    console.log(ngModelController);
                    var BaseElement = $(element).find("#BASE");
                    var NewElement = $(element).find("#NEW");
                    scope.Show = false;
                    
                    scope.start = false;
                    scope.returnValue = '';
                    BaseElement.scroll(function(event){
                        if (event.type == 'scroll') {
                            var inf = event.currentTarget.scrollLeft;                            
                            NewElement.scrollLeft(inf);
                            var infV = event.currentTarget.scrollTop;
                            NewElement.scrollTop(infV);
                        }
                        
                    })
                    NewElement.scroll(function(event){
                        if (event.type == 'scroll') {
                            var inf = event.currentTarget.scrollLeft;
                            BaseElement.scrollLeft(inf);
                            var infV = event.currentTarget.scrollTop;
                            BaseElement.scrollTop(infV);
                        }
                    })
                    scope.$watch('sourse', function(newValue, oldValue) {
                      console.log('sourse');
                        if (scope.sourse != null && scope.sourse != '' && scope.start) {
                          getView();
                      }
                      else if (scope.sourse != null && scope.sourse != '' && !scope.start) {
                        scope.start = true;
                      }
                    });
                    scope.$watch('target', function(newValue, oldValue) {
                      console.log('target');
                        if (scope.target != null && scope.target != '' && scope.start) {
                          getView();
                      }
                      else if (scope.target != null && scope.target != '' && !scope.start) {
                        scope.start = true;
                      }
                    });
                    
                    
                    scope.setinfo = function() {
                        console.log('setinfo');
                        console.log(scope.diffXML);
                        var newObject = cleaningObject.getObject(scope.diffXML);
                        console.log(newObject);
                        var x2js = new X2JS();
                        var returnXML = x2js.json2xml_str(newObject);
                        scope.file = returnXML;
                        
                    }
                    var cleaningObject = function() {
                        return {
                            VALUE_CREATED: 'created',
                            VALUE_UPDATED: 'updated',
                            VALUE_DELETED: 'deleted',
                            VALUE_UNCHANGED: 'unchanged',
                            getObject: function(obj) {
                                if (this.isObject(obj) && obj.DiffType != null) {
                                    return obj.DiffViewValue;
                                    
                                    
                                }

                                if (this.isFunction(obj)) {
                                    console.log(obj);
                                    throw 'Invalid argument!!!. Function given, object expected.';
                                }
                                
                                var diff;
                                if ((this.isObject(obj) || this.isArray(obj)) && obj.DiffType == null) {
                                    var checkMassive = true;
                                    for (var key in obj) {
                                        if (!angular.isNumber(parseInt(key)) || isNaN(parseInt(key))) {
                                            checkMassive = false;
                                        }
                                    }
                                    if (checkMassive) {
                                        diff = [];
                                        for (var key in obj) {
                                            console.log('checkMassive - ' + key);
                                            if (key != '__proto__') {
                                                var ob = this.getObject(obj[key]);  
                                                if (this.isAdd(ob)) {
                                                    diff.push(ob);
                                                }
                                            }
                                        }
                                    }
                                    else {
                                        diff = {};
                                        for (var key in obj) {

                                            if (key != '__proto__' && key != 'remove') {
                                                console.log('checkNotMassive - ' + key);
                                                console.log(obj[key]);
                                                var ob = this.getObject(obj[key]);
                                                if (this.isAdd(ob)) {
                                                    diff[key] = ob;
                                                }
                                            }
                                        }
                                    }
                                }
                                return diff;
                            },
                            isAdd: function(obj) {
                                var checkAdd = true;
                                if (obj != null && 'undefined' != typeof(obj)){
                                }
                                else {
                                    checkAdd = false;
                                }
                                if (this.isArray(obj) && obj.length == 0) {
                                    checkAdd = false;
                                }
                                if (this.isObject(obj)) {
                                    var index = 0;
                                    for (var key in obj) {
                                        index ++;
                                    }
                                    if (index == 0) {
                                        checkAdd = false;
                                    }
                                }
                                return checkAdd;
                            },
                            isFunction: function(obj) {
                                return {}.toString.apply(obj) === '[object Function]';
                            },
                            isArray: function(obj) {
                                return {}.toString.apply(obj) === '[object Array]';
                            },
                            isObject: function(obj) {
                                return {}.toString.apply(obj) === '[object Object]';
                            },
                            isValue: function(obj) {
                                return !this.isObject(obj) && !this.isArray(obj);
                            }
                        }
                    }();
                    
                    scope.getReturnModel = function () {
                        var returnST = '';
                        for (var x= 0; x< scope.table.length ; x++) {
                            var line = scope.table[x];
                            if (line.removed && line.edit || line.add && !line.edit || !line.removed && !line.add) {
                                returnST += line.valueNew + '\n';
                            }
                        }
                        scope.file = returnST;
                        
                        
                    }
                    
                    function getView() {
                        var StartDate = new Date();
                        var VStartDate = StartDate.getTime();
                        console.log('Start = ' + StartDate);
                        var x2js = new X2JS();

                        // console.log(scope.target);
                        // var sourseObj = x2js.xml_str2json( scope.sourse );
                        // var targetObj = x2js.xml_str2json( scope.target );
                        // console.log(sourseObj);
                        // console.log(targetObj);

                        //console.log(scope.sourse);
                        //console.log(scope.target);

                        beforOpenMainTag = '';
                        openMainTag = '';
                        betweenMainTag = '';
                        closeMainTag = '';
                        deleteMainTag(scope.sourse);
                        console.log('beforOpenMainTag-' + beforOpenMainTag);
                        console.log('openMainTag-'+openMainTag);
                        console.log('betweenMainTag-'+betweenMainTag);
                        console.log('closeMainTag-'+closeMainTag);
                        //var sourseObj = x2js.xml_str2json( scope.sourse );
                        var sourseObj;
                        var targetObj;

                        if (openMainTag != '' && closeMainTag != '') {
                            sourseObj = x2js.xml_str2json( '<xml>'+betweenMainTag+'</xml>' );

                            beforOpenMainTag = '';
                            openMainTag = '';
                            betweenMainTag = '';        
                            closeMainTag = '';

                            deleteMainTag(scope.target);
                            if (openMainTag != '' && closeMainTag != '') {
                                //var targetObj = x2js.xml_str2json( scope.target );
                                targetObj = x2js.xml_str2json( '<xml>'+betweenMainTag+'</xml>' );
                            }
                            else {
                                sourseObj = x2js.xml_str2json( scope.sourse );
                                targetObj = x2js.xml_str2json( scope.target );
                            }
                        }
                        else {
                            sourseObj = x2js.xml_str2json( scope.sourse );
                            targetObj = x2js.xml_str2json( scope.target );
                        }
                        //console.log(sourseObj);
                        //console.log(targetObj);

                        scope.file = scope.target;
                        var diff = deepDiffMapper.map(sourseObj, targetObj);
                        console.log(diff);
                        scope.diffXML = {};
                        scope.diffXML = diff;
                        scope.Show = true;
                        
                        var FinishDate = new Date();
                        console.log('Finish = ' + FinishDate);
                        console.log('Finish = ' + (FinishDate.getTime() - VStartDate));
                    }
                    
                    
                    
                    
                    var deepDiffMapper = function() {
                        return {
                            VALUE_CREATED: 'created',
                            VALUE_UPDATED: 'updated',
                            VALUE_DELETED: 'deleted',
                            VALUE_UNCHANGED: 'unchanged',
                            map: function(obj1, obj2) {
                                console.log('obj1'+obj1);
                                console.log('obj2'+obj2);
                                if (this.isFunction(obj1) || this.isFunction(obj2)) {
                                    throw 'Invalid argument. Function given, object expected.';
                                }
                                if (this.isValue(obj1) && this.isValue(obj2)) {
                                //if (this.isValue(obj1) && this.isValue(obj2)) {
                                    var DiffType = this.compareValues(obj1, obj2);
                                    if (this.isArray(obj1)) {
                                        var ret = [];
                                        if ($.inArray( obj2, obj1 ) > -1) {
                                            ret.push(this.map(obj2, obj2));
                                        }
                                        for (var key in obj1) {
                                            if (obj1[key] != obj2) {
                                                ret.push(this.map(obj1[key], undefined));
                                            }
                                        }
                                        
                                        return ret;
                                    }
                                    else if (this.isArray(obj2)) {
                                        var ret = [];
                                        if ($.inArray( obj1, obj2)  > -1) {
                                            ret.push(this.map(obj1, obj1));
                                        }
                                        for (var key in obj2) {
                                            if (obj2[key] != obj1) {
                                                ret.push(this.map(undefined, obj2[key]));
                                            }
                                        }
                                        
                                        return ret;
                                    }
                                    else if (this.isObject(obj1)) {
                                        var diffnew = {};
                                        for (var key in obj1) {
                                            diffnew[key] = this.map(obj1[key], undefined);
                                        }
                                        return diffnew;
                                    }
                                    else if (this.isObject(obj2)) {
                                        var diffnew = {};
                                        for (var key in obj2) {
                                            diffnew[key] = this.map(undefined, obj2[key]);
                                        }
                                        return diffnew;
                                    }
                                    var Diffstyle =  {};
                                    if (DiffType == this.VALUE_CREATED) {
                                        Diffstyle['background-color'] = '#4EB1CB';
                                    }
                                    else if (DiffType == this.VALUE_UPDATED) {
                                        Diffstyle['background-color'] = '#86B9EA';
                                    }
                                    else if (DiffType == this.VALUE_DELETED) {
                                        Diffstyle['background-color'] = '#717ECD';
                                    }

                                    console.log('----*DiffType\n\n');
                                    console.log(DiffType);
                                    return {DiffType: DiffType, NewData: obj2, OldData : obj1, DiffAction: false, DiffViewValue: obj2, Diffstyle: Diffstyle};
                                    
                                   
                                }
                                else {
                                    var diff = {};
                                    if (this.isObject(obj1) || this.isObject(obj2)) {
                                    //if (this.isObject(obj1) && this.isObject(obj2)) {
                                        var value2 = undefined;
                                        //var value2 = '';
                                        //if (!this.isUndefined(obj1)) { 
                                            for (var key in obj1) {
                                                if (this.isFunction(obj1[key])) {
                                                    continue;
                                                }
                                                
                                                console.log('III KEY >>> \n\n' + key);
                                                //console.log(this.isUndefined(obj2));
                                               
                                                if (!this.isUndefined(obj2) && 'undefined' != typeof(obj2[key])) {
                                                    value2 = obj2[key];
                                                }
                                                else {
                                                    if (obj1[key] == 'true' || obj1[key] == 'false') {
                                                        value2 = 'false';
                                                    }
                                                    else {
                                                        value2 = '';
                                                    }
                                                }
                                                

                                                diff[key] = this.map(obj1[key], value2);
                                            }
                                        //}
                                        //if (!this.isUndefined(obj2)) {
                                            for (var key in obj2) {
                                                if (this.isFunction(obj2[key]) || ('undefined' != typeof(diff[key]))) {
                                                    continue;
                                                }
                                                
                                                if (obj2[key] == 'true' || obj2[key] == 'false') {
                                                    diff[key] = this.map('false', obj2[key]);
                                                }
                                                else {
                                                    diff[key] = this.map(undefined, obj2[key]);
                                                }
                                                //diff[key] = this.map(undefined, obj2[key]);
                                                //diff[key] = this.map('', obj2[key]);
                                            }
                                        //}
                                    }
                                    /*if (this.isObject(obj1) || this.isObject(obj2)) {
                                        for (var key in obj1) {
                                            if (this.isFunction(obj1[key])) {
                                                continue;
                                            }
                            
                                            var value2 = undefined;
                                            if ('undefined' != typeof(obj2[key])) {
                                                value2 = obj2[key];
                                            }
                            
                                            diff[key] = this.map(obj1[key], value2);
                                        }
                                        for (var key in obj2) {
                                            if (this.isFunction(obj2[key]) || ('undefined' != typeof(diff[key]))) {
                                                continue;
                                            }
                            
                                            diff[key] = this.map(undefined, obj2[key]);
                                        }
                                    }*/

                                    
                                    if (this.isArray(obj1) || this.isArray(obj2)) {
                                        diff = [];
                                        obj1 = this.isUndefined(obj1) ? [] : obj1;
                                        obj2 = this.isUndefined(obj2) ? [] : obj2;
                                        if (this.isValue(obj1) || this.isObject(obj1)) {
                                            var temp = obj1;
                                            obj1 = [];
                                            obj1.push(temp);
                                        }
                                        if (this.isValue(obj2) || this.isObject(obj2)) {
                                            var temp = obj2;
                                            obj2 = [];
                                            obj2.push(temp);
                                        }
                                    
                                    //var diff = {};
                                        if (this.isArray(obj2) && this.isArray(obj1)) {
                                            if (this.isValue(obj1[0])) {
                                                var endKey = 0;
                                                /*for (var key in obj2) {*/
                                                for (var key=0; key < obj2.length; key++) {
                                                    var value = obj2[key];
                                                    var Diffstyle =  {};
                                                    if ($.inArray(value, obj1) > -1) {
                                                        diff[key] = {DiffType: this.VALUE_UNCHANGED, NewData: value, OldData : value, DiffAction: false, DiffViewValue: value, Diffstyle: {}}
                                                    }
                                                    else {
                                                        Diffstyle['background-color'] = '#4EB1CB';
                                                        diff[key] = {DiffType: this.VALUE_CREATED, NewData: value, OldData : null, DiffAction: false, DiffViewValue: value, Diffstyle: Diffstyle}
                                                    }
                                                    endKey = key;
                                                }
                                                /*for (var key in obj1) {*/
                                                for (var key=0; key < obj1.length; key++) {
                                                    var value = obj1[key];
                                                    var Diffstyle =  {};
                                                    if ($.inArray(value, obj2) > -1) {
                                                    }
                                                    else {
                                                        endKey++;
                                                        Diffstyle['background-color'] = '#717ECD';
                                                        diff[endKey] = {DiffType: this.VALUE_DELETED, NewData: null, OldData : value, DiffAction: false, DiffViewValue: null, Diffstyle: Diffstyle}
                                                    }
                                                }
                                            }
                                            else if (this.isObject(obj2[0])) {
                                                //analitics key
                                                var KeyName = this.getKey(obj2);
                                                if (KeyName == null) {
                                                    // new logic merge
                                                    var firstObj = obj2[0];
                                                    var CheckMerge = true;
                                                    for (var key in firstObj) {
                                                        if (!this.isValue(firstObj[key])) {
                                                            CheckMerge = false;
                                                            break;
                                                        }
                                                    }
                                                    if (CheckMerge) {
                                                        var keyIndex= 0;
                                                        var obj2LIST = [];
                                                        var obj1LIST = [];
                                                        var obj2MAP = {};
                                                        var obj1MAP = {};
                                                        for (var key in obj2) {
                                                            obj2LIST.push(angular.toJson(obj2[key]));
                                                            obj2MAP[key] = angular.toJson(obj2[key]);
                                                        }
                                                        for (var key in obj1) {
                                                            obj1LIST.push(angular.toJson(obj1[key]));
                                                            obj1MAP[key] = angular.toJson(obj1[key]);
                                                        }
                                                        for (var key in obj2) {
                                                            if (this.isFunction(obj2[key])) {
                                                                continue;
                                                            }
                                                            if ($.inArray(obj2MAP[key], obj1LIST) > -1) {
                                                                diff[key] = this.map(obj2[key], obj2[key]);
                                                            }
                                                            else {
                                                                diff[key] = this.map(undefined, obj2[key]);
                                                            }
                                                            keyIndex = key;
                                                        }
                                                        
                                                        for (var key in obj1) {
                                                            if (this.isFunction(obj1[key])) {
                                                                continue;
                                                            }
                                                            
                                                            if ($.inArray(obj1MAP[key], obj2LIST) == -1) {
                                                                keyIndex++;
                                                                diff[keyIndex] = this.map(obj1[key], undefined);
                                                            }
                                                            
                                                        }
                                                        
                                                        
                                                    }
                                                    else {
                                                        for (var key in obj1) {
                                                            if (this.isFunction(obj1[key])) {
                                                                continue;
                                                            }
                                            
                                                            var value2 = undefined;
                                                            if ('undefined' != typeof(obj2[key])) {
                                                                value2 = obj2[key];
                                                            }
                                            
                                                            diff[key] = this.map(obj1[key], value2);
                                                        }
                                                        for (var key in obj2) {
                                                            if (this.isFunction(obj2[key]) || ('undefined' != typeof(diff[key]))) {
                                                                continue;
                                                            }
                                            
                                                            diff[key] = this.map(undefined, obj2[key]);
                                                        }
                                                    }
                                                }
                                                else {
                                                    //logic merge
                                                    var obj1Map = {};
                                                    var obj1KeyList = [];
                                                    var obj2Map = {};
                                                    var obj2KeyList = [];
                                                    for (var key in obj1) {
                                                        var objQ = obj1[key];
                                                        obj1Map[objQ[KeyName]] = objQ;
                                                        obj1KeyList.push(objQ[KeyName]);
                                                    }
                                                    for (var key in obj2) {
                                                        var objQ = obj2[key];
                                                        obj2Map[objQ[KeyName]] = objQ;
                                                        obj2KeyList.push(objQ[KeyName]);
                                                    }
                                                    var keyIndex = 0;
                                                    for (var key in obj2) {
                                                        if (this.isFunction(obj2[key])) {
                                                            continue;
                                                        }
                                                        var newObj = obj2[key];
                                                        var value = newObj[KeyName];
                                                        keyIndex = key;
                                                        if ($.inArray(value, obj1KeyList) > -1 ) {
                                                            var oldObj = obj1Map[value];
                                                            diff[key] = this.map(oldObj, newObj);
                                                        }
                                                        else {
                                                            diff[key] = this.map(undefined, newObj);
                                                        }
                                                    }
                                                    for (var key in obj1) {
                                                        if (this.isFunction(obj1[key])) {
                                                            continue;
                                                        }
                                                        var oldObj = obj1[key];
                                                        var value = oldObj[KeyName];
                                                        if ($.inArray(value, obj2KeyList) > -1 ) {
                                                        }
                                                        else {
                                                            keyIndex++;
                                                            diff[keyIndex] = this.map(oldObj, undefined);
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                        // else {
                                        //     for (var key in obj1) {
                                        //         if (this.isFunction(obj1[key])) {
                                        //             continue;
                                        //         }
                                
                                        //         var value2 = undefined;
                                        //         if ('undefined' != typeof(obj2[key])) {
                                        //             value2 = obj2[key];
                                        //         }
                                
                                        //         diff[key] = this.map(obj1[key], value2);
                                        //     }
                                        //     for (var key in obj2) {
                                        //         if (this.isFunction(obj2[key]) || ('undefined' != typeof(diff[key]))) {
                                        //             continue;
                                        //         }
                                
                                        //         diff[key] = this.map(undefined, obj2[key]);
                                        //     }
                                        // }
                                    }
                                    
                                }


                    
                                return diff;
                    
                            },
                            compareValues: function(value1, value2) {
                                if (value1 === value2) {
                                    return this.VALUE_UNCHANGED;
                                }
                                if ('undefined' == typeof(value1)) {
                                    return this.VALUE_CREATED;
                                }
                                if ('undefined' == typeof(value2)) {
                                    return this.VALUE_DELETED;
                                }
                    
                                return this.VALUE_UPDATED;
                            },
                            getKey: function(list) {
                                var firstObject = list[0];
                                var ListKeyName = [];
                                var MapKeyName = {};
                                var returnvalue = null;
                                for (var key in firstObject) {
                                    if (this.isValue(firstObject[key])) {
                                        ListKeyName.push(key);
                                        MapKeyName[key] = [];
                                    }
                                }
                                if (ListKeyName.length == 0) {
                                    return null;
                                }
                                for (var key in list) {
                                    var object = list[key];
                                    for (var key2 in MapKeyName) {
                                        var value = object[key2]
                                        if ($.inArray(value, MapKeyName[key2]) > -1) {
                                             delete MapKeyName[key2];
                                        }
                                        else {
                                            MapKeyName[key2].push(value);
                                        }
                                    }
                                    
                                }
                                var index = 0;
                                for (var key3 in MapKeyName) {
                                     index++;
                                     if (index == 1) {
                                        returnvalue = key3;
                                     }
                                }
                                if (index == 0) {
                                    returnvalue = null;
                                }
                                
                                return returnvalue;
                                
                            },
                            isFunction: function(obj) {
                                return {}.toString.apply(obj) === '[object Function]';
                            },
                            isArray: function(obj) {
                                return {}.toString.apply(obj) === '[object Array]';
                            },
                            isObject: function(obj) {
                                return {}.toString.apply(obj) === '[object Object]';
                            },
                            isValue: function(obj) {
                                return !this.isObject(obj) && !this.isArray(obj);
                            },
                            isUndefined: function(obj) {
                                return obj === undefined || obj === null;
                            }
                        }
                    }();
                }
            }
        }]);


        myApp.service('MergeService', function($q, dataManager) {
            var StartData;
            var FinishData = {};
            var START;
            var FINSH;
            var Iter;
            var mapLastDeployAttachment = {};
            var mapLastVersionAttachment = {};

            var ListSnapshots = [];

            function _startMerge() {
                console.log('START');
                Iter = 0;
                getItemInfo();
            }
            function getItemInfo() {
                if (Iter < StartData.length) {
                    var Item = StartData[Iter];
                    dataManager.getLastAndDeployAtachment(Item.LastComponentHistoryATID, Item.DeployedComponentHistoryATID == null ? '' : Item.DeployedComponentHistoryATID).then(
                        function(data) {
                            if (angular.isArray(data) && data.length >= 1) {
                                var LastAtachmentZip;
                                var DeployAtachmentZip;
                                
                                if (data[0].TypeAtt == 'Deploy') {
                                    if (data.length > 1) {
                                        LastAtachmentZip = data[1].base64;
                                    }
                                    else {
                                        LastAtachmentZip = data[0].base64;
                                    }
                                    if (Item.Deployed) {
                                        DeployAtachmentZip = data[0].base64;
                                    }
                                }
                                else {
                                    LastAtachmentZip = data[0].base64;
                                    if (Item.Deployed) {
                                        if (data.length > 1) {
                                            DeployAtachmentZip = data[1].base64;
                                        }
                                        else {
                                            DeployAtachmentZip = data[0].base64;
                                        }
                                    }
                                }
                                var zipLast = new JSZip(LastAtachmentZip, {base64:true});
                                var fileLast = zipLast.file(Item.Label).asBinary();
                                Item.LastCRC32 = zipLast.crc32(fileLast, 32);
                                Item.LastFile = fileLast;
                                if (Item.Deployed) {
                                    var zipDeploy = new JSZip(DeployAtachmentZip, {base64:true});
                                    var fileDeploy = zipDeploy.file(Item.Label).asBinary();
                                    Item.DeployCRC32 = zipDeploy.crc32(fileDeploy, 32);
                                    Item.DeployFile = fileDeploy;
                                }
                                getMetaItem();
                            }
                            else {
                                console.log('ERROR dont Atachment');
                            }
                        },
                        function (error) {
                        }
                     );
                }
                else {
                    console.log('FINSH');
                    FINSH = true;
                    angular.element(document.getElementById('angularControllerId')).scope().getStatusConflicts();
                }
                
            }
            
            function getMetaItem() {
                var Item = StartData[Iter];
                dataManager.getMetaItemAtachment(Item.AttachmentId).then(
                        function(data) {
                            if (data != null && data.base64 != null) {
                                var zip = new JSZip(data.base64, {base64:true});
                                var file = zip.file(Item.Label).asBinary();
                                
                                Item.CRC32 = zip.crc32(file, 32);
                                Item.MetaItemFile = file;
                                
                                if (file.indexOf('<?xml') > -1) {
                                    Item.IsXML = true;
                                }
                                else {
                                    Item.IsXML = false;
                                }
                                if (zip.file(Item.Label + '-meta.xml') != null) {
                                    var fileMeta = zip.file(Item.Label + '-meta.xml').asBinary();
                                    Item.MetaItemFileMeta = fileMeta;
                                }
                                AnalyticsMerge();
                            }
                            else {
                                console.log('ERROR dont Atachment for Meta Item');
                            }
                        },
                        function (error) {
                        }
                );
                
            }
            
            function getChildFileMap(metaType,xml,fileName)
            {
                var fullName = '';
                if(metaType != 'CustomLabel')
                {
                    fullName = fileName.slice(fileName.indexOf("/")+1,fileName.lastIndexOf('.'))+".";
                }
        
                var x2js = new X2JS();
                var jsnMap ={};
                var tempJSON = '';
                var srcjson = x2js.xml_str2json(xml);
                console.log(srcjson);
                if(srcjson != undefined && srcjson != null)
                {
                    var srcitems;
                    if(metaType == 'CustomLabel')
                    {
                        var srcMetaItem = srcjson.CustomLabels;
                        srcitems = srcMetaItem.labels;
                    }
                    else if(metaType == 'CustomField')
                    {
                        var srcMetaItem = srcjson.CustomObject;
                        srcitems = srcMetaItem.fields;
                    }
                    else if(metaType == 'ListView')
                    {
                        var srcMetaItem = srcjson.CustomObject;
                        srcitems = srcMetaItem.listViews;
                    }
                    else if(metaType == 'CompactLayout')
                    {
                        var srcMetaItem = srcjson.CustomObject;
                        srcitems = srcMetaItem.compactLayouts;
                    }
                    else if(metaType == 'WebLink')
                    {
                        var srcMetaItem = srcjson.CustomObject;
                        srcitems = srcMetaItem.webLinks;
                    }
                    else if(metaType == 'RecordType')
                    {
                        var srcMetaItem = srcjson.CustomObject;
                        srcitems = srcMetaItem.recordTypes;
                    }
                    else if(metaType == 'FieldSet')
                    {
                        var srcMetaItem = srcjson.CustomObject;
                        srcitems = srcMetaItem.fieldSets;
                    }
                    else if(metaType == 'ValidationRule')
                    {
                        var srcMetaItem = srcjson.CustomObject;
                        srcitems = srcMetaItem.validationRules;
                    }
                    else if(metaType == 'AssignmentRule')
                    {
                        var srcMetaItem = srcjson.AssignmentRules;
                        srcitems = srcMetaItem.assignmentRule;
                    }
                    else if(metaType == 'AutoResponseRule')
                    {
                        var srcMetaItem = srcjson.AutoResponseRules;
                        srcitems = srcMetaItem.autoResponseRule;
                    }
                    else if(metaType == 'WorkflowTask')
                    {
                        var srcMetaItem = srcjson.Workflow;
                        srcitems = srcMetaItem.tasks;
                    }
                    else if(metaType == 'WorkflowOutboundMessage')
                    {
                        var srcMetaItem = srcjson.Workflow;
                        srcitems = srcMetaItem.outboundMessages;
                    }
                    else if(metaType == 'WorkflowFieldUpdate')
                    {
                        var srcMetaItem = srcjson.Workflow;
                        srcitems = srcMetaItem.fieldUpdates;
                    }
                    else if(metaType == 'WorkflowAlert')
                    {
                        var srcMetaItem = srcjson.Workflow;
                        srcitems = srcMetaItem.alerts;
                    }
                    else if( metaType == 'WorkflowRule')
                    {
                        var srcMetaItem = srcjson.Workflow;
                        srcitems = srcMetaItem.rules;
                    }
                    else if(metaType == 'SharingCriteriaRule')
                    {
                        var srcMetaItem = srcjson.SharingRules;
                        srcitems = srcMetaItem.sharingCriteriaRules;
                    }
                    else if(metaType == 'SharingOwnerRule')
                    {
                        var srcMetaItem = srcjson.SharingRules;
                        srcitems = srcMetaItem.sharingOwnerRules;
                    }
                    else if(metaType == 'BusinessProcess')
                    {
                        var srcMetaItem = srcjson.CustomObject;
                        srcitems = srcMetaItem.businessProcesses;
                    }
                    else if(metaType == 'SharingReason')
                    {
                        var srcMetaItem = srcjson.CustomObject;
                        srcitems = srcMetaItem.sharingReasons;
                    }
                    else if(metaType == 'EscalationRule')
                    {
                        var srcMetaItem = srcjson.EscalationRules;
                        srcitems = srcMetaItem.escalationRule;
                    }
                    else if(metaType == 'MatchingRule')    
                    {
                        var srcMetaItem = srcjson.MatchingRules;
                        srcitems = srcMetaItem.matchingRules;
                    }
                    else if(metaType == 'ManagedTopic')
                    {
                        var srcMetaItem = srcjson.ManagedTopics;
                        srcitems = srcMetaItem.ManagedTopic;
                    }
                    if(srcitems != undefined)
                    {
                        if(srcitems.fullName == undefined)
                        {   
                            for(var i in srcitems)  
                            {
                                if(i < srcitems.length)
                                {
                                    var v = srcitems[i];
                                    jsnMap[v.fullName]= JSON.stringify(v);
                                }
                            }            
                        }
                        else
                        {
                            jsnMap[srcitems.fullName] = JSON.stringify(srcitems);
                        }
                    }
                }
                var tempXml;
                for(var name in jsnMap)
                {
                    var tempXml = '';
                    var tempJSON = jsnMap[name];
                    if(tempJSON != undefined)
                    {
                        //header
                        if(metaType == 'CustomLabel')
                        {
                            tempXml = '<?xml version="1.0" encoding="UTF-8"?><CustomLabels xmlns="http://soap.sforce.com/2006/04/metadata">';
                        }
                        else if(metaType == 'AssignmentRule' )
                        {
                            tempXml = '<?xml version="1.0" encoding="UTF-8"?><AssignmentRules xmlns="http://soap.sforce.com/2006/04/metadata">';
                        }
                        else if(metaType == 'AutoResponseRule')
                        {
                            tempXml = '<?xml version="1.0" encoding="UTF-8"?><AutoResponseRules xmlns="http://soap.sforce.com/2006/04/metadata">';
                        }
                        else if(metaType == 'WorkflowAlert' || metaType == 'WorkflowFieldUpdate'|| metaType == 'WorkflowOutboundMessage'|| metaType == 'WorkflowTask' || metaType == 'WorkflowRule')
                        {
                            tempXml = '<?xml version="1.0" encoding="UTF-8"?><Workflow xmlns="http://soap.sforce.com/2006/04/metadata">';
                        }
                        else if(metaType == 'SharingCriteriaRule' || metaType == 'SharingOwnerRule')
                        {
                            tempXml = '<?xml version="1.0" encoding="UTF-8"?><SharingRules xmlns="http://soap.sforce.com/2006/04/metadata">';
                        }
                        else if(metaType == 'EscalationRule')
                        {
                            tempXml = '<?xml version="1.0" encoding="UTF-8"?><EscalationRules xmlns="http://soap.sforce.com/2006/04/metadata">';
                        }
                        else if(metaType == 'MatchingRule')
                        {
                            tempXml = '<?xml version="1.0" encoding="UTF-8"?><MatchingRules xmlns="http://soap.sforce.com/2006/04/metadata">';
                        }
                        else if(metaType == 'ManagedTopic')
                        {
                            tempXml = '<?xml version="1.0" encoding="UTF-8"?><ManagedTopics xmlns="http://soap.sforce.com/2006/04/metadata">';
                        }
                        else
                        {
                            tempXml = '<?xml version="1.0" encoding="UTF-8"?><CustomObject xmlns="http://soap.sforce.com/2006/04/metadata">';
                        }
                        
                        //body
                        if(metaType == 'CustomLabel')
                        {
                            tempXml = tempXml +'<labels>'+x2js.json2xml_str($.parseJSON(tempJSON))+'</labels>';
                        }
                        else if(metaType == 'CustomField')
                        {
                            tempXml = tempXml +'<fields>'+x2js.json2xml_str($.parseJSON(tempJSON))+'</fields>';
                        }
                        else if(metaType == 'ListView')
                        {
                            tempXml = tempXml +'<listViews>'+x2js.json2xml_str($.parseJSON(tempJSON))+'</listViews>';
                        }
                        else if(metaType == 'CompactLayout')
                        {
                            tempXml = tempXml +'<compactLayouts>'+x2js.json2xml_str($.parseJSON(tempJSON))+'</compactLayouts>';
                        }
                        else if(metaType == 'WebLink')
                        {
                            tempXml = tempXml +'<webLinks>'+x2js.json2xml_str($.parseJSON(tempJSON))+'</webLinks>';
                        }
                        else if(metaType == 'RecordType')
                        {
                            tempXml = tempXml +'<recordTypes>'+x2js.json2xml_str($.parseJSON(tempJSON))+'</recordTypes>';
                        }
                        else if(metaType == 'FieldSet')
                        {
                            tempXml = tempXml +'<fieldSets>'+x2js.json2xml_str($.parseJSON(tempJSON))+'</fieldSets>';
                        }
                        else if(metaType == 'ValidationRule')
                        {
                            tempXml = tempXml +'<validationRules>'+x2js.json2xml_str($.parseJSON(tempJSON))+'</validationRules>';
                        }
                        else if(metaType == 'AssignmentRule')
                        {
                            tempXml = tempXml +'<assignmentRule>'+x2js.json2xml_str($.parseJSON(tempJSON))+'</assignmentRule>';
                        }
                        else if(metaType == 'AutoResponseRule')
                        {
                            tempXml = tempXml +'<autoResponseRule>'+x2js.json2xml_str($.parseJSON(tempJSON))+'</autoResponseRule>';
                        }
                        else if(metaType == 'WorkflowAlert')
                        {
                            tempXml = tempXml +'<alerts>'+x2js.json2xml_str($.parseJSON(tempJSON))+'</alerts>';
                        }
                        else if(metaType == 'WorkflowFieldUpdate')
                        {
                            tempXml = tempXml +'<fieldUpdates>'+x2js.json2xml_str($.parseJSON(tempJSON))+'</fieldUpdates>';
                        }
                        else if(metaType == 'WorkflowOutboundMessage')
                        {
                            tempXml = tempXml +'<outboundMessages>'+x2js.json2xml_str($.parseJSON(tempJSON))+'</outboundMessages>';
                        }
                        else if(metaType == 'WorkflowTask')
                        {
                            tempXml = tempXml +'<tasks>'+x2js.json2xml_str($.parseJSON(tempJSON))+'</tasks>';
                        }
                        else if(metaType == 'WorkflowRule')
                        {
                            tempXml = tempXml +'<rules>'+x2js.json2xml_str($.parseJSON(tempJSON))+'</rules>';
                        }
                        else if(metaType == 'SharingCriteriaRule')
                        {
                            tempXml = tempXml +'<sharingCriteriaRules>'+x2js.json2xml_str($.parseJSON(tempJSON))+'</sharingCriteriaRules>';
                        }
                        else if(metaType == 'SharingOwnerRule')
                        {
                            tempXml = tempXml +'<sharingOwnerRules>'+x2js.json2xml_str($.parseJSON(tempJSON))+'</sharingOwnerRules>';
                        }
                        else if(metaType == 'EscalationRule')
                        {
                            tempXml = tempXml +'<escalationRule>'+x2js.json2xml_str($.parseJSON(tempJSON))+'</escalationRule>';
                        }
                        else if(metaType == 'MatchingRule')
                        {
                            tempXml = tempXml +'<matchingRules>'+x2js.json2xml_str($.parseJSON(tempJSON))+'</matchingRules>';
                        }
                        else if(metaType == 'ManagedTopic')
                        {
                            tempXml = tempXml +'<managedTopic>'+x2js.json2xml_str($.parseJSON(tempJSON))+'</managedTopic>';
                        }
                        else if(metaType == 'BusinessProcess')
                        {
                            tempXml = tempXml +'<businessProcesses>'+x2js.json2xml_str($.parseJSON(tempJSON))+'</businessProcesses>';
                        }
                        else if(metaType == 'SharingReason')
                        {
                            tempXml = tempXml +'<sharingReasons>'+x2js.json2xml_str($.parseJSON(tempJSON))+'</sharingReasons>';
                        }
                        
                        
                        //footer
                        if(metaType == 'CustomLabel')
                        {
                            tempXml = tempXml +'</CustomLabels>';
                        }
                        else if(metaType == 'AssignmentRule' )
                        {
                            tempXml = tempXml +'</AssignmentRules>';
                        }
                        else if(metaType == 'AutoResponseRule')
                        {
                            tempXml = tempXml +'</AutoResponseRules>';
                        }
                        else if(metaType == 'WorkflowAlert' || metaType == 'WorkflowFieldUpdate'|| metaType == 'WorkflowOutboundMessage'|| metaType == 'WorkflowTask' || metaType == 'WorkflowRule')
                        {
                            tempXml = tempXml +'</Workflow>';
                        }
                        else if(metaType == 'SharingCriteriaRule' || metaType == 'SharingOwnerRule')
                        {
                            tempXml = tempXml +'</SharingRules>';
                        }
                        else if(metaType == 'EscalationRule')
                        {
                            tempXml = tempXml +'</EscalationRules>';
                        }
                        else if(metaType == 'MatchingRule')
                        {
                            tempXml = tempXml +'</MatchingRules>';
                        }
                        else if(metaType == 'ManagedTopic')
                        {
                            tempXml = tempXml +'</ManagedTopics>';
                        }
                        else
                        {
                            tempXml = tempXml +'</CustomObject>';
                        }
                        //fileMap[metaType+"#"+fullName+""+name]=   getCrcWithData(tempXml);
                        
                    }
                }
                return tempXml;
            }
            
            function AnalyticsMerge() {
                var Item = StartData[Iter];
                if (Item.IsXML) {
                    //Object.merge
                    console.log('III Item.Deployed >>>>\n\n'+Item.Deployed);
                    console.log('III Item.LastComponentHistoryCRC32 == JSON.parse(Item.CRC32) >>>>\n\n'+Item.LastComponentHistoryCRC32 == JSON.parse(Item.CRC32));
                    console.log('######### Merge Text ##########');
                    console.log('######### DeployFile ##########');
                    console.log(Item.DeployFile);
                    console.log('######### LastFile ##########');
                    console.log(Item.LastFile);
                    console.log('######### MetaItemFile ##########');
                    console.log(Item.MetaItemFile);
                    
                    Item.DeployFile = decodeURIComponent( escape( Item.DeployFile ) );
                    Item.LastFile = decodeURIComponent( escape( Item.LastFile ) );
                    Item.MetaItemFile = decodeURIComponent( escape( Item.MetaItemFile ) );
                    /*var encodeMetaItemFile = unescape( encodeURIComponent( Item.MetaItemFile ) );
                    //var encodeMetaItemFile = btoa(encode_utf8(Item.MetaItemFile));
                    console.log('######### encodeMetaItemFile ##########');
                    console.log(encodeMetaItemFile);*/

                    /*var encodeMetaItemFile1 = decodeURIComponent( escape( Item.MetaItemFile ) );
                    //var encodeMetaItemFile = btoa(encode_utf8(Item.MetaItemFile));
                    console.log('######### encodeMetaItemFile1 ##########');
                    console.log(encodeMetaItemFile1);*/

                    console.log('######### Item.LastComponentHistoryChangedBy == localUser ##########');
                    console.log(Item.LastComponentHistoryChangedBy == localUser);
                    console.log(Item.LastComponentHistoryChangedBy);
                    console.log(localUser);
                    console.log('######### Item.LastComponentHistoryCRC32 == JSON.parse(Item.CRC32) ##########');
                    console.log(Item.LastComponentHistoryCRC32 == JSON.parse(Item.CRC32));
                    console.log(Item.LastComponentHistoryCRC32);
                    console.log(JSON.parse(Item.CRC32));
                    console.log('######### Item.LastFile == Item.MetaItemFile ##########');
                    console.log(Item.LastFile == Item.MetaItemFile);
                    console.log(Item.LastFile);
                    console.log(Item.MetaItemFile);

                    Item.IsIdentical = false;
                    if (Item.Deployed == false || Item.DeployFile == null) {
                        /*if (Item.LastComponentHistoryCRC32 != null && Item.LastComponentHistoryCRC32 == JSON.parse(Item.CRC32)) {*/
                        if (Item.LastComponentHistoryCRC32 != null && Item.LastFile == Item.MetaItemFile) {
                            Item.IsIdentical = true;
                            Item.CONFLICT = false;
                            Item.mergeFile = Item.MetaItemFile;
                        }
                        else {
                            if (Item.LastComponentHistoryCRC32 != null && Item.LastComponentHistoryChangedBy == localUser) {
                                Item.IsIdentical = false;
                                Item.CONFLICT = false;
                                Item.mergeFile = Item.MetaItemFile;
                            }
                            else {
                                Item.CONFLICT = true;
                            }
                        }
                        FinishData[Item.ItemId] = Item;
                        Iter++;
                        return getItemInfo();
                    }
                    else {
                        if (Item.DeployedComponentHistoryCRC32 != null && Item.LastComponentHistoryCRC32 != null && Item.LastComponentHistoryCRC32 == Item.DeployedComponentHistoryCRC32) {
                            Item.CONFLICT = false;
                            Item.mergeFile = Item.MetaItemFile;

                            console.log(Item.CONFLICT);
                            
                            FinishData[Item.ItemId] = Item;
                            Iter++;
                            return getItemInfo();
                        }

                        if (Item.LastComponentHistoryCRC32 != null && Item.LastComponentHistoryChangedBy == localUser) {
                            Item.IsIdentical = false;
                            Item.CONFLICT = false;
                            Item.mergeFile = Item.MetaItemFile;

                            FinishData[Item.ItemId] = Item;
                            Iter++;
                            return getItemInfo();
                        }
                    }

                    ////////////////// conflict //////////////
                    Item.CONFLICT = true;
                    FinishData[Item.ItemId] = Item;
                    Iter++;
                    return getItemInfo();
                    //////////////////////////////////////////

                    var x2js = new X2JS();
                    var LastFile = x2js.xml_str2json(Item.LastFile);
                    
                    var DeployFile = x2js.xml_str2json(Item.DeployFile);
                    var MetaItemFile;
                    
                    var customXML = getChildFileMap(Item.ComponentType, Item.MetaItemFile, Item.APIName);
                    if (customXML === undefined || customXML === null) {
                        MetaItemFile = x2js.xml_str2json(Item.MetaItemFile);
                    }
                    else {
                        MetaItemFile = x2js.xml_str2json(customXML);
                        Item.IsCustomXML = true;
                        Item.CustomXMLFile = customXML;
                    }

                    

                    DiffMapper3Way.setCONFLICT(false);
                    //var merge = DiffMapper3Way.map(DeployFile, LastFile, MetaItemFile);
                    var merge = DiffMapper3Way.map(DeployFile, LastFile, MetaItemFile);
                    if (DiffMapper3Way.getCONFLICT()) {
                        Item.CONFLICT = true;
                    }
                    else {
                        Item.CONFLICT = false;
                        Item.merge = merge;
                        var strMergeFile = x2js.json2xml_str(merge);
                        /*if (strMergeFile.indexOf('<?xml') > -1) {
                            Item.mergeFile = x2js.json2xml_str(merge);
                        }
                        else {
                            Item.mergeFile = '<?xml version="1.0" encoding="UTF-8"?>' + x2js.json2xml_str(merge);  
                        }*/
                        if (strMergeFile.indexOf('<?xml') > -1) {
                            Item.mergeFile = formatXmlDeleteTitle(x2js.json2xml_str(merge));
                            console.log('II>>>>>Item.mergeFile\n\n'+Item.mergeFile);
                            //Item.mergeFile = File;
                        }
                        else {
                            //Item.mergeFile = '<?xml version="1.0" encoding="UTF-8"?>' + File;
                            Item.mergeFile = x2js.json2xml_str(merge);
                        }
                        
                        stringHttp = '<0>h</0><1>t</1><2>t</2><3>p</3><4>:</4><5>/</5><6>/</6><7>s</7><8>o</8><9>a</9><10>p</10><11>.</11><12>s</12><13>f</13><14>o</14><15>r</15><16>c</16><17>e</17><18>.</18><19>c</19><20>o</20><21>m</21><22>/</22><23>2</23><24>0</24><25>0</25><26>6</26><27>/</27><28>0</28><29>4</29><30>/</30><31>m</31><32>e</32><33>t</33><34>a</34><35>d</35><36>a</36><37>t</37><38>a</38>';
                        Item.mergeFile = Item.mergeFile.replace(stringHttp, "");

                        // Item.mergeFile = Item.mergeFile.replace(/<[0-9]*[0-9]*[0-9]>/g, "");
                        // Item.mergeFile = Item.mergeFile.replace(/<\/[0-9]*[0-9]*[0-9]>/g, "");

                        // //Item.mergeFile = formatXml(Item.mergeFile);
                        // Item.mergeFile = Item.mergeFile.replace(/><\//g, ">\n<\/");
                        // Item.mergeFile = Item.mergeFile.replace(/></g, ">\n<");

                        Item.mergeFile = formatXmlParse(Item.mergeFile, '');
                        Item.mergeFile = Item.mergeFile.replace(/><\//g, ">\n<\/");
                        Item.mergeFile = Item.mergeFile.replace(/></g, ">\n<");
                        Item.mergeFile = Item.mergeFile.replace(/    /g, "");

                        Item.mergeFile = formatXml(Item.mergeFile);
                        Item.mergeFile = formatXmldeleteEmptyTag('', Item.mergeFile);
                        Item.mergeFile = Item.mergeFile.replace(/\t/ig, '    ');

                        Item.mergeFile = '<?xml version="1.0" encoding="UTF-8"?>\n' + Item.mergeFile;
                    }
                    //console.log('II>>>>>Item.mergeFile\n\n'+Item.mergeFile);
                    
                    

                    console.log('II beauty >>>>>Item.mergeFile\n\n'+Item.mergeFile);

                    FinishData[Item.ItemId] = Item;
                    
                }
                else {
                    //merge text file
                    var diffO = new diff_match_patch();
                    
                    console.log('######### Merge Text ##########');
                    console.log('######### DeployFile ##########');
                    console.log(Item.DeployFile);
                    console.log('######### LastFile ##########');
                    console.log(Item.LastFile);
                    console.log('######### MetaItemFile ##########');
                    console.log(Item.MetaItemFile);

                    // if (Item.Deployed == false || Item.DeployFile == '') {
                    //     var patch2 = diffO.patch_make(Item.LastFile, Item.MetaItemFile);
                    // }
                    // else {
                    //     var patch2 = diffO.patch_make(Item.DeployFile, Item.MetaItemFile);
                    // }
                    // var apply2 = diffO.patch_apply(patch2, Item.LastFile);
                    // if (apply2[1].length > 0) {
                    //     for (var x = 0; x < apply2[1].length; x++) {
                    //         if (!apply2[1][x]) {
                    //             Item.CONFLICT = true;
                    //         }
                    //     }
                    // }

                    if (Item.Deployed == false || Item.DeployFile == '') {
                        if (Item.LastCRC32 != null && Item.LastCRC32 == JSON.parse(Item.CRC32)) {
                            Item.IsIdentical = true;
                            Item.CONFLICT = false;
                            Item.mergeFile = Item.MetaItemFile;
                        }
                        else {
                            if (Item.LastCRC32 != null && Item.LastComponentHistoryChangedBy == localUser) {
                                Item.IsIdentical = false;
                                Item.CONFLICT = false;
                                Item.mergeFile = Item.MetaItemFile;
                            }
                            else {
                                Item.CONFLICT = true;
                            }
                        }
                        
                        // var patch2 = diffO.patch_make(Item.LastFile, Item.MetaItemFile);
                        // var apply2 = diffO.patch_apply(patch2, Item.LastFile);
                        // if (apply2[1].length > 0) {
                        //     for (var x = 0; x < apply2[1].length; x++) {
                        //         if (!apply2[1][x]) {
                        //             Item.CONFLICT = true;
                        //         }
                        //     }
                        // }
                    }
                    else {
                        if (Item.LastComponentHistoryCRC32 != null && Item.LastFile == Item.DeployFile) {
                            Item.IsIdentical = true;
                            Item.CONFLICT = false;
                            Item.mergeFile = Item.MetaItemFile;
                        }
                        else{
                            if (Item.DeployFile == Item.MetaItemFile) {
                                Item.CONFLICT = false;
                                Item.mergeFile = Item.LastFile;
                            }
                            else {
                                if (Item.LastComponentHistoryChangedBy == localUser) {
                                    Item.IsIdentical = false;
                                    Item.CONFLICT = false;
                                    Item.mergeFile = Item.MetaItemFile;
                                }
                                else {
                                    var patch2 = diffO.patch_make(Item.DeployFile, Item.MetaItemFile);
                                    var apply2 = diffO.patch_apply(patch2, Item.LastFile);

                                    var patch3 = diffO.patch_make(Item.LastFile, Item.MetaItemFile);
                                    var apply3 = diffO.patch_apply(patch3, Item.DeployFile);

                                    console.log('apply2[0] = apply2[1]' + (apply2[0] == apply2[1]));

                                    if (apply2[0] == apply3[0]) {
                                        /*if (apply2[1].length > 0) {
                                            for (var x = 0; x < apply2[1].length; x++) {
                                                if (!apply2[1][x]) {
                                                    Item.CONFLICT = true;
                                                }
                                            }
                                        }*/
                                        Item.CONFLICT = false;
                                    }
                                    else {
                                        Item.CONFLICT = true;
                                        /*if (apply2[1].length > 0) {
                                            for (var x = 0; x < apply2[1].length; x++) {
                                                if (!apply2[1][x]) {
                                                    Item.CONFLICT = true;
                                                }
                                            }
                                        }*/
                                    }

                                    if (!Item.CONFLICT) {
                                        Item.mergeFile = apply2[0]
                                        Item.CONFLICT = false;
                                    }
                                }
                            }
                        }
                    }

                    /*if (!Item.CONFLICT) {
                        Item.mergeFile = apply2[0]
                        Item.CONFLICT = false;
                    }*/

                    console.log('II beauty >>>>>Item.mergeFile\n\n'+Item.mergeFile);
                    
                    FinishData[Item.ItemId] = Item;
                }
                Iter++;
                getItemInfo();

            }
            
            
                var DiffMapper3Way = function() {
                        var CONFLICT = false;
                        return {
                            
                            VALUE_CREATED: 'created',
                            VALUE_UPDATED: 'updated',
                            VALUE_DELETED: 'deleted',
                            VALUE_UNCHANGED: 'unchanged',
                            getCONFLICT: function() {
                                return CONFLICT;
                            },
                            setCONFLICT: function(param) {
                                CONFLICT = param;
                            },
                            map: function(obj1, obj2, obj3) {
                                // obj1 Main Object
                                // obj2 Last Branch Object
                                // obj3 New Object
                                if (this.isFunction(obj1) || this.isFunction(obj2) || this.isFunction(obj3)) {
                                    throw 'Invalid argument. Function given, object expected.';
                                }
                                var diff = {};
                                if (this.isValue(obj1) && this.isValue(obj2) && this.isValue(obj3)) {
                                    return this.compareValues(obj1, obj2, obj3);
                                }
                                else {
                                    /*console.log('FieldObj1-');
                                    console.log(obj1);
                                    //console.log(obj1[0]);
                                    console.log(this.isObject(obj1));
                                    console.log('FieldObj2-');
                                    console.log(obj2);
                                    console.log(obj2[0]);
                                    console.log(this.isObject(obj2));
                                    console.log('FieldObj3-');
                                    console.log(obj3);
                                    console.log(obj3[0]);
                                    console.log(this.isObject(obj3));*/
                                    if (this.isObject(obj1) || this.isObject(obj2) || this.isObject(obj3)) {
                                        var obj1Value = undefined;
                                        var obj2Value = undefined;
                                        var obj3Value = undefined;
                                        if (!this.isUndefined(obj1)) {
                                            for (var key in obj1) {
                                                if (this.isFunction(obj1[key])) {
                                                    continue;
                                                }
                                                if (!this.isUndefined(obj2) && 'undefined' != typeof(obj2[key])) {
                                                    obj2Value = obj2[key];
                                                }
                                                if (!this.isUndefined(obj3) && 'undefined' != typeof(obj3[key])) {
                                                    obj3Value = obj3[key];
                                                }
                                                diff[key] = this.map(obj1[key], obj2Value, obj3Value);
                                            }
                                        }
                                        if (!this.isUndefined(obj2)) {
                                            for (var key in obj2) {
                                                if (this.isFunction(obj2[key]) || 'undefined' != typeof(diff[key])) {
                                                    continue;
                                                }
                                                if (!this.isUndefined(obj3) && 'undefined' != typeof(obj3[key])) {
                                                    obj3Value = obj3[key];
                                                }
                                                diff[key] = this.map(undefined, obj2[key], obj3Value);
                                            }
                                        }
                                        if (!this.isUndefined(obj3)) {
                                            for (var key in obj3) {
                                                if (this.isFunction(obj3[key]) || 'undefined' != typeof(diff[key])) {
                                                    continue;
                                                }
                                                diff[key] = this.map(undefined, undefined, obj3[key]);
                                            }
                                        }
                                    }
                                    if (this.isArray(obj1) || this.isArray(obj2) || this.isArray(obj3)) {
                                        console.log('ValueObj1-');
                                        console.log(this.isValue(obj1));
                                        console.log(this.isObject(obj1));
                                        console.log('ValueObj2-');
                                        console.log(this.isValue(obj2));
                                        console.log(this.isObject(obj2));
                                        console.log('ValueObj3-');
                                        console.log(this.isValue(obj3));
                                        console.log(this.isObject(obj3));

                                        diff = [];
                                        obj1 = this.isUndefined(obj1) ? [] : obj1;
                                        obj2 = this.isUndefined(obj2) ? [] : obj2;
                                        obj3 = this.isUndefined(obj3) ? [] : obj3;
                                        if (this.isValue(obj1) || this.isObject(obj1)) {
                                            var temp = obj1;
                                            obj1 = [];
                                            obj1.push(temp);
                                        }
                                        if (this.isValue(obj2) || this.isObject(obj2)) {
                                            var temp = obj2;
                                            obj2 = [];
                                            obj2.push(temp);
                                        }
                                        if (this.isValue(obj3) || this.isObject(obj3)) {
                                            var temp = obj3;
                                            obj3 = [];
                                            obj3.push(temp);
                                        }
                                        if (this.isArray(obj1) && this.isArray(obj2) && this.isArray(obj3)) {
                                            if (this.isObject(obj1[0]) || this.isObject(obj2[0]) || this.isObject(obj3[0])) {
                                                var KeyName = null;

                                                console.log('obj1-');
                                                console.log(this.isObject(obj1[0]));
                                                console.log('obj2-');
                                                console.log(this.isObject(obj2[0]));
                                                console.log('obj3-');
                                                console.log(this.isObject(obj3[0]));
                                                if (obj1.length >= obj2.length && obj1.length >= obj3.length) {
                                                    KeyName = this.getKey(obj1);
                                                    console.log('keyName1-' + KeyName);
                                                }
                                                else if (obj2.length >= obj1.length && obj2.length >= obj3.length) {
                                                    KeyName = this.getKey(obj2);
                                                    console.log('keyName2-' + KeyName);
                                                }
                                                else if (obj3.length >= obj1.length && obj3.length >= obj2.length) {
                                                    KeyName = this.getKey(obj3);
                                                    console.log('keyName3-' + KeyName);
                                                }
                                                console.log('keyName' + KeyName);
                                                if (KeyName != null) {
                                                    var obj1Map = {};
                                                    var obj1KeyList = [];
                                                    var obj2Map = {};
                                                    var obj2KeyList = [];
                                                    var obj3Map = {};
                                                    var obj3KeyList = [];
                                                    for (var key in obj1) {
                                                        var objQ = obj1[key];
                                                        obj1Map[objQ[KeyName]] = objQ;
                                                        obj1KeyList.push(objQ[KeyName]);
                                                    }
                                                    for (var key in obj2) {
                                                        var objQ = obj2[key];
                                                        obj2Map[objQ[KeyName]] = objQ;
                                                        obj2KeyList.push(objQ[KeyName]);
                                                    }
                                                    for (var key in obj3) {
                                                        var objQ = obj3[key];
                                                        obj3Map[objQ[KeyName]] = objQ;
                                                        obj3KeyList.push(objQ[KeyName]);
                                                    }
                                                    console.log('ValueObj1-');
                                                    console.log(obj1Map);
                                                    console.log(obj1KeyList);
                                                    console.log('ValueObj2-');
                                                    console.log(obj2Map);
                                                    console.log(obj2KeyList);
                                                    console.log('ValueObj3-');
                                                    console.log(obj3Map);
                                                    console.log(obj3KeyList);
                                                    for (var key in obj3) {
                                                        if (this.isFunction(obj3[key])) {
                                                            continue;
                                                        }
                                                        var newObj = obj3[key];
                                                        var value = newObj[KeyName];
                                                        var oldObj1 = obj1Map[value];
                                                        var oldObj2 = obj2Map[value];
                                                        console.log(oldObj1);
                                                        console.log(oldObj2);
                                                        diff.push(this.map(oldObj1, oldObj2, newObj));
                                                    }
                                                    for (var key in obj2) {
                                                        if (this.isFunction(obj2[key])) {
                                                           continue;
                                                        }
                                                        var newObj = obj2[key];
                                                        var value = newObj[KeyName];
                                                        if ($.inArray(value, obj3KeyList) == -1 && $.inArray(value, obj1KeyList) > -1) {
                                                            var oldObj1 = obj1Map[value];
                                                            diff.push(this.map(oldObj1, newObj, undefined));
                                                        }
                                                        else if ($.inArray(value, obj3KeyList) == -1 && $.inArray(value, obj1KeyList) == -1) {
                                                            diff.push(this.map(undefined, newObj, undefined));
                                                        }
                                                    }
                                                    for (var key in obj1) {
                                                        if (this.isFunction(obj1[key])) {
                                                           continue;
                                                        }
                                                        var newObj = obj1[key];
                                                        var value = newObj[KeyName];
                                                        if ($.inArray(value, obj2KeyList) == -1 && $.inArray(value, obj3KeyList) == -1) {
                                                            diff.push(this.map(newObj, undefined, undefined));
                                                        }
                                                    }
                                                }
                                                else {
                                                    //console.log('1');
                                                    var firstObj;
                                                    if (this.isObject(obj1[0])) {
                                                        firstObj = obj1[0];
                                                    }
                                                    else if (this.isObject(obj2[0])) {
                                                        firstObj = obj2[0];
                                                    }
                                                    else if (this.isObject(obj3[0])) {
                                                        firstObj = obj3[0];
                                                    }
                                                    var CheckMerge = true;
                                                    for (var key in firstObj) {
                                                        if (!this.isValue(firstObj[key])) {
                                                            CheckMerge = false;
                                                            break;
                                                        }
                                                    }
                                                    if (CheckMerge) {
                                                        var obj3LIST = [];
                                                        var obj2LIST = [];
                                                        var obj1LIST = [];
                                                        var obj3MAP = {};
                                                        var obj2MAP = {};
                                                        var obj1MAP = {};
                                                        for (var key in obj3) {
                                                            obj3LIST.push(angular.toJson(obj3[key]));
                                                            obj3MAP[key] = angular.toJson(obj3[key]);
                                                        }
                                                        for (var key in obj2) {
                                                            obj2LIST.push(angular.toJson(obj2[key]));
                                                            obj2MAP[key] = angular.toJson(obj2[key]);
                                                        }
                                                        for (var key in obj1) {
                                                            obj1LIST.push(angular.toJson(obj1[key]));
                                                            obj1MAP[key] = angular.toJson(obj1[key]);
                                                        }
                                                        
                                                        for (var key in obj3) {
                                                            if (this.isFunction(obj3[key])) {
                                                                continue;
                                                            }
                                                            if ($.inArray(obj3MAP[key], obj1LIST) > -1 && $.inArray(obj3MAP[key], obj2LIST) > -1) {
                                                                diff.push(this.map(obj3[key], obj3[key], obj3[key]));
                                                            }
                                                            else if ($.inArray(obj3MAP[key], obj1LIST) == -1 && $.inArray(obj3MAP[key], obj2LIST) > -1) {
                                                                diff.push(this.map(undefined, obj3[key], obj3[key]));
                                                            }
                                                            else if ($.inArray(obj3MAP[key], obj1LIST) > -1 && $.inArray(obj3MAP[key], obj2LIST) == -1) {
                                                                diff.push(this.map(obj3[key], undefined , obj3[key]));
                                                            }
                                                            else if ($.inArray(obj3MAP[key], obj1LIST) == -1 && $.inArray(obj3MAP[key], obj2LIST) == -1) {
                                                                diff.push(this.map(undefined, undefined , obj3[key]));
                                                            }
                                                            
                                                        }
                                                        
                                                        for (var key in obj2) {
                                                            if (this.isFunction(obj2[key])) {
                                                                continue;
                                                            }
                                                            if ($.inArray(obj2MAP[key], obj3LIST) == -1 && $.inArray(obj2MAP[key], obj1LIST) > -1) {
                                                                diff.push(this.map(obj2[key], obj2[key], undefined));
                                                            }
                                                            else if ($.inArray(obj2MAP[key], obj3LIST) == -1 && $.inArray(obj2MAP[key], obj1LIST) == -1) {
                                                                diff.push(this.map(undefined, obj2[key], undefined));
                                                            }
                                                                 
                                                        }
                                                        
                                                        for (var key in obj1) {
                                                            if (this.isFunction(obj1[key])) {
                                                                continue;
                                                            }
                                                            if ($.inArray(obj1MAP[key], obj3LIST) == -1 && $.inArray(obj1MAP[key], obj2LIST) == -1) {
                                                                diff.push(this.map(obj1[key], undefined, undefined));
                                                            }
                                                        }
                                                    }
                                                    else {
                                                        if (obj1.length >= obj2.length && obj1.length >= obj3.length) {
                                                            for (var key in obj1) {
                                                                if (this.isFunction(obj1[key])) {
                                                                    continue;
                                                                }
                                                                diff.push(this.map(obj1[key], obj2[key], obj3[key]));
                                                            }
                                                        }
                                                        else if (obj2.length >= obj1.length && obj2.length >= obj3.length) {
                                                            for (var key in obj2) {
                                                                if (this.isFunction(obj2[key])) {
                                                                    continue;
                                                                }
                                                                diff.push(this.map(obj1[key], obj2[key], obj3[key]));
                                                            }
                                                        }
                                                        else {
                                                            for (var key in obj3) {
                                                                if (this.isFunction(obj3[key])) {
                                                                    continue;
                                                                }
                                                                diff.push(this.map(obj1[key], obj2[key], obj3[key]));
                                                            }
                                                        }
                                                    }
                                                    
                                                }
                                            }
                                            else {
                                                if (this.isValue(obj1[0]) || this.isValue(obj2[0]) || this.isValue(obj3[0])) {
                                                    console.log('Value1-');
                                                    console.log(this.isValue(obj1[0]));
                                                    console.log('Value2-');
                                                    console.log(this.isValue(obj2[0]));
                                                    console.log('Value3-');
                                                    console.log(this.isValue(obj3[0]));
                                                    
                                                    for (var key in obj3) {
                                                        if (this.isFunction(obj3[key])) {
                                                           continue;
                                                        }
                                                        var value = obj3[key];
                                                        if ($.inArray(value, obj1) > -1 && $.inArray(value, obj2) > -1) {
                                                            diff.push(this.map(value, value, value));
                                                        }
                                                        else if ($.inArray(value, obj1) == -1 && $.inArray(value, obj2) > -1) {
                                                            diff.push(this.map(undefined, value, value));
                                                        }
                                                        else if ($.inArray(value, obj1) > -1 && $.inArray(value, obj2) == -1) {
                                                            diff.push(this.map(value, undefined, value));
                                                        }
                                                        else if ($.inArray(value, obj1) == -1 && $.inArray(value, obj2) == -1) {
                                                            diff.push(this.map(undefined, undefined, value));
                                                        }
                                                    }
                                                    for (var key in obj2) {
                                                        if (this.isFunction(obj2[key])) {
                                                           continue;
                                                        }
                                                        var value = obj2[key];
                                                        if ($.inArray(value, obj3) == -1 && $.inArray(value, obj1) > -1) {
                                                            diff.push(this.map(value, value, undefined));
                                                        }
                                                        else if ($.inArray(value, obj3) == -1 && $.inArray(value, obj1) == -1) {
                                                            diff.push(this.map(undefined, value, undefined));
                                                        }
                                                    }
                                                    for (var key in obj1) {
                                                        if (this.isFunction(obj1[key])) {
                                                           continue;
                                                        }
                                                        var value = obj1[key];
                                                        if ($.inArray(value, obj3) == -1 && $.inArray(value, obj2) == -1) {
                                                            diff.push(this.map(value, undefined, undefined));
                                                        }
                                                    }
                                                }
                                                else {
                                                    if (obj1.length >= obj2.length && obj1.length >= obj3.length) {
                                                        for (var key in obj1) {
                                                            if (this.isFunction(obj1[key])) {
                                                                continue;
                                                            }
                                                            diff.push(this.map(obj1[key], obj2[key], obj3[key]));
                                                        }
                                                    }
                                                    else if (obj2.length >= obj1.length && obj2.length >= obj3.length) {
                                                        for (var key in obj2) {
                                                            if (this.isFunction(obj2[key])) {
                                                                continue;
                                                            }
                                                            diff.push(this.map(obj1[key], obj2[key], obj3[key]));
                                                        }
                                                    }
                                                    else {
                                                        for (var key in obj3) {
                                                            if (this.isFunction(obj3[key])) {
                                                                continue;
                                                            }
                                                            diff.push(this.map(obj1[key], obj2[key], obj3[key]));
                                                        }
                                                    }
                                                }
                                                
                                            }
                                            
                                        }
                                        // if (this.isArray(obj1) && this.isArray(obj2) && this.isArray(obj3)) {
                                        //     if (this.isValue(obj1[0]) || this.isValue(obj2[0]) || this.isValue(obj3[0])) {
                                        //      console.log('obj1-');
                                              //   console.log(this.isValue(obj1[0]));
                                              //   console.log('obj2-');
                                              //   console.log(this.isValue(obj2[0]));
                                              //   console.log('obj3-');
                                              //   console.log(this.isValue(obj3[0]));
                                                
                                        //         for (var key in obj3) {
                                        //             if (this.isFunction(obj3[key])) {
                                        //                continue;
                                        //             }
                                        //             var value = obj3[key];
                                        //             if ($.inArray(value, obj1) > -1 && $.inArray(value, obj2) > -1) {
                                        //                 diff.push(this.map(value, value, value));
                                        //             }
                                        //             else if ($.inArray(value, obj1) == -1 && $.inArray(value, obj2) > -1) {
                                        //                 diff.push(this.map(undefined, value, value));
                                        //             }
                                        //             else if ($.inArray(value, obj1) > -1 && $.inArray(value, obj2) == -1) {
                                        //                 diff.push(this.map(value, undefined, value));
                                        //             }
                                        //             else if ($.inArray(value, obj1) == -1 && $.inArray(value, obj2) == -1) {
                                        //                 diff.push(this.map(undefined, undefined, value));
                                        //             }
                                        //         }
                                        //         for (var key in obj2) {
                                        //             if (this.isFunction(obj2[key])) {
                                        //                continue;
                                        //             }
                                        //             var value = obj2[key];
                                        //             if ($.inArray(value, obj3) == -1 && $.inArray(value, obj1) > -1) {
                                        //                 diff.push(this.map(value, value, undefined));
                                        //             }
                                        //             else if ($.inArray(value, obj3) == -1 && $.inArray(value, obj1) == -1) {
                                        //                 diff.push(this.map(undefined, value, undefined));
                                        //             }
                                        //         }
                                        //         for (var key in obj1) {
                                        //             if (this.isFunction(obj1[key])) {
                                        //                continue;
                                        //             }
                                        //             var value = obj1[key];
                                        //             if ($.inArray(value, obj3) == -1 && $.inArray(value, obj2) == -1) {
                                        //                 diff.push(this.map(value, undefined, undefined));
                                        //             }
                                        //         }
                                        //     }
                                        //     else if (this.isObject(obj1[0]) || this.isObject(obj2[0]) || this.isObject(obj3[0])) {
                                        //         var KeyName = null;

                                        //         console.log('obj1-');
                                              //   console.log(this.isObject(obj1[0]));
                                              //   console.log('obj2-');
                                              //   console.log(this.isObject(obj2[0]));
                                              //   console.log('obj3-');
                                              //   console.log(this.isObject(obj3[0]));
                                        //         if (obj1.length >= obj2.length && obj1.length >= obj3.length) {
                                        //             KeyName = this.getKey(obj1);
                                        //             console.log('keyName1-' + KeyName);
                                        //         }
                                        //         else if (obj2.length >= obj1.length && obj2.length >= obj3.length) {
                                        //             KeyName = this.getKey(obj2);
                                        //             console.log('keyName2-' + KeyName);
                                        //         }
                                        //         else if (obj3.length >= obj1.length && obj3.length >= obj2.length) {
                                        //             KeyName = this.getKey(obj3);
                                        //             console.log('keyName3-' + KeyName);
                                        //         }
                                        //         console.log('keyName' + KeyName);
                                        //         if (KeyName != null) {
                                        //             var obj1Map = {};
                                        //             var obj1KeyList = [];
                                        //             var obj2Map = {};
                                        //             var obj2KeyList = [];
                                        //             var obj3Map = {};
                                        //             var obj3KeyList = [];
                                        //             for (var key in obj1) {
                                        //                 var objQ = obj1[key];
                                        //                 obj1Map[objQ[KeyName]] = objQ;
                                        //                 obj1KeyList.push(objQ[KeyName]);
                                        //             }
                                        //             for (var key in obj2) {
                                        //                 var objQ = obj2[key];
                                        //                 obj2Map[objQ[KeyName]] = objQ;
                                        //                 obj2KeyList.push(objQ[KeyName]);
                                        //             }
                                        //             for (var key in obj3) {
                                        //                 var objQ = obj3[key];
                                        //                 obj3Map[objQ[KeyName]] = objQ;
                                        //                 obj3KeyList.push(objQ[KeyName]);
                                        //             }
                                        //             for (var key in obj3) {
                                        //                 if (this.isFunction(obj3[key])) {
                                        //                     continue;
                                        //                 }
                                        //                 var newObj = obj3[key];
                                        //                 var value = newObj[KeyName];
                                        //                 var oldObj1 = obj1Map[value];
                                        //                 var oldObj2 = obj2Map[value];
                                        //                 diff.push(this.map(oldObj1, oldObj2, newObj));
                                        //             }
                                        //             for (var key in obj2) {
                                        //                 if (this.isFunction(obj2[key])) {
                                        //                    continue;
                                        //                 }
                                        //                 var newObj = obj2[key];
                                        //                 var value = newObj[KeyName];
                                        //                 if ($.inArray(value, obj3KeyList) == -1 && $.inArray(value, obj1KeyList) > -1) {
                                        //                     var oldObj1 = obj1Map[value];
                                        //                     diff.push(this.map(oldObj1, newObj, undefined));
                                        //                 }
                                        //                 else if ($.inArray(value, obj3KeyList) == -1 && $.inArray(value, obj1KeyList) == -1) {
                                        //                     diff.push(this.map(undefined, newObj, undefined));
                                        //                 }
                                        //             }
                                        //             for (var key in obj1) {
                                        //                 if (this.isFunction(obj1[key])) {
                                        //                    continue;
                                        //                 }
                                        //                 var newObj = obj1[key];
                                        //                 var value = newObj[KeyName];
                                        //                 if ($.inArray(value, obj2KeyList) == -1 && $.inArray(value, obj3KeyList) == -1) {
                                        //                     diff.push(this.map(newObj, undefined, undefined));
                                        //                 }
                                        //             }
                                        //         }
                                        //         else {
                                        //             //console.log('1');
                                        //             var firstObj;
                                        //             if (this.isObject(obj1[0])) {
                                        //                 firstObj = obj1[0];
                                        //             }
                                        //             else if (this.isObject(obj2[0])) {
                                        //                 firstObj = obj2[0];
                                        //             }
                                        //             else if (this.isObject(obj3[0])) {
                                        //                 firstObj = obj3[0];
                                        //             }
                                        //             var CheckMerge = true;
                                        //             for (var key in firstObj) {
                                        //                 if (!this.isValue(firstObj[key])) {
                                        //                     CheckMerge = false;
                                        //                     break;
                                        //                 }
                                        //             }
                                        //             if (CheckMerge) {
                                        //                 var obj3LIST = [];
                                        //                 var obj2LIST = [];
                                        //                 var obj1LIST = [];
                                        //                 var obj3MAP = {};
                                        //                 var obj2MAP = {};
                                        //                 var obj1MAP = {};
                                        //                 for (var key in obj3) {
                                        //                     obj3LIST.push(angular.toJson(obj3[key]));
                                        //                     obj3MAP[key] = angular.toJson(obj3[key]);
                                        //                 }
                                        //                 for (var key in obj2) {
                                        //                     obj2LIST.push(angular.toJson(obj2[key]));
                                        //                     obj2MAP[key] = angular.toJson(obj2[key]);
                                        //                 }
                                        //                 for (var key in obj1) {
                                        //                     obj1LIST.push(angular.toJson(obj1[key]));
                                        //                     obj1MAP[key] = angular.toJson(obj1[key]);
                                        //                 }
                                                        
                                        //                 for (var key in obj3) {
                                        //                     if (this.isFunction(obj3[key])) {
                                        //                         continue;
                                        //                     }
                                        //                     if ($.inArray(obj3MAP[key], obj1LIST) > -1 && $.inArray(obj3MAP[key], obj2LIST) > -1) {
                                        //                         diff.push(this.map(obj3[key], obj3[key], obj3[key]));
                                        //                     }
                                        //                     else if ($.inArray(obj3MAP[key], obj1LIST) == -1 && $.inArray(obj3MAP[key], obj2LIST) > -1) {
                                        //                         diff.push(this.map(undefined, obj3[key], obj3[key]));
                                        //                     }
                                        //                     else if ($.inArray(obj3MAP[key], obj1LIST) > -1 && $.inArray(obj3MAP[key], obj2LIST) == -1) {
                                        //                         diff.push(this.map(obj3[key], undefined , obj3[key]));
                                        //                     }
                                        //                     else if ($.inArray(obj3MAP[key], obj1LIST) == -1 && $.inArray(obj3MAP[key], obj2LIST) == -1) {
                                        //                         diff.push(this.map(undefined, undefined , obj3[key]));
                                        //                     }
                                                            
                                        //                 }
                                                        
                                        //                 for (var key in obj2) {
                                        //                     if (this.isFunction(obj2[key])) {
                                        //                         continue;
                                        //                     }
                                        //                     if ($.inArray(obj2MAP[key], obj3LIST) == -1 && $.inArray(obj2MAP[key], obj1LIST) > -1) {
                                        //                         diff.push(this.map(obj2[key], obj2[key], undefined));
                                        //                     }
                                        //                     else if ($.inArray(obj2MAP[key], obj3LIST) == -1 && $.inArray(obj2MAP[key], obj1LIST) == -1) {
                                        //                         diff.push(this.map(undefined, obj2[key], undefined));
                                        //                     }
                                                                 
                                        //                 }
                                                        
                                        //                 for (var key in obj1) {
                                        //                     if (this.isFunction(obj1[key])) {
                                        //                         continue;
                                        //                     }
                                        //                     if ($.inArray(obj1MAP[key], obj3LIST) == -1 && $.inArray(obj1MAP[key], obj2LIST) == -1) {
                                        //                         diff.push(this.map(obj1[key], undefined, undefined));
                                        //                     }
                                        //                 }
                                        //             }
                                        //             else {
                                        //                 if (obj1.length >= obj2.length && obj1.length >= obj3.length) {
                                        //                     for (var key in obj1) {
                                        //                         if (this.isFunction(obj1[key])) {
                                        //                             continue;
                                        //                         }
                                        //                         diff.push(this.map(obj1[key], obj2[key], obj3[key]));
                                        //                     }
                                        //                 }
                                        //                 else if (obj2.length >= obj1.length && obj2.length >= obj3.length) {
                                        //                     for (var key in obj2) {
                                        //                         if (this.isFunction(obj2[key])) {
                                        //                             continue;
                                        //                         }
                                        //                         diff.push(this.map(obj1[key], obj2[key], obj3[key]));
                                        //                     }
                                        //                 }
                                        //                 else {
                                        //                     for (var key in obj3) {
                                        //                         if (this.isFunction(obj3[key])) {
                                        //                             continue;
                                        //                         }
                                        //                         diff.push(this.map(obj1[key], obj2[key], obj3[key]));
                                        //                     }
                                        //                 }
                                        //             }
                                                    
                                        //         }
                                        //     }
                                        //     else {
                                        //         if (obj1.length >= obj2.length && obj1.length >= obj3.length) {
                                        //             for (var key in obj1) {
                                        //                 if (this.isFunction(obj1[key])) {
                                        //                     continue;
                                        //                 }
                                        //                 diff.push(this.map(obj1[key], obj2[key], obj3[key]));
                                        //             }
                                        //         }
                                        //         else if (obj2.length >= obj1.length && obj2.length >= obj3.length) {
                                        //             for (var key in obj2) {
                                        //                 if (this.isFunction(obj2[key])) {
                                        //                     continue;
                                        //                 }
                                        //                 diff.push(this.map(obj1[key], obj2[key], obj3[key]));
                                        //             }
                                        //         }
                                        //         else {
                                        //             for (var key in obj3) {
                                        //                 if (this.isFunction(obj3[key])) {
                                        //                     continue;
                                        //                 }
                                        //                 diff.push(this.map(obj1[key], obj2[key], obj3[key]));
                                        //             }
                                        //         }
                                                
                                                
                                        //     }
                                            
                                        // }
                                    }
                                    
                                    
                                    
                                }
                                return diff;
                    
                            },
                            compareValues: function(value1, value2, value3) {
                                var returnValue;
                                //GET DIFF1
                                var diff1;
                                if (value1 === value2) {
                                    diff1 = this.VALUE_UNCHANGED;
                                }
                                else if ('undefined' == typeof(value1)) {
                                    diff1 = this.VALUE_CREATED;
                                }
                                else if ('undefined' == typeof(value2)) {
                                    diff1 = this.VALUE_DELETED;
                                }
                                else {
                                    diff1 = this.VALUE_UPDATED;
                                }
                                
                                
                                //GET DIFF2
                                var diff2;
                                if (value1 === value3) {
                                    diff2 = this.VALUE_UNCHANGED;
                                }
                                else if ('undefined' == typeof(value1)) {
                                    diff2 = this.VALUE_CREATED;
                                }
                                else if ('undefined' == typeof(value3)) {
                                    diff2 = this.VALUE_DELETED;
                                }
                                else {
                                    diff2 = this.VALUE_UPDATED;
                                }
                                
                                //Analise DIFF
                                //VALUE_DELETED
                                if (diff1 == this.VALUE_DELETED && diff2 == this.VALUE_DELETED) {
                                    returnValue = null;
                                }
                                if (diff1 == this.VALUE_DELETED && diff2 == this.VALUE_UNCHANGED) {
                                    returnValue = null;
                                }
                                if (diff1 == this.VALUE_DELETED && diff2 == this.VALUE_UPDATED) {
                                    returnValue = null;
                                    console.log(value1);
                                    console.log(value2);
                                    console.log(value3);
                                    CONFLICT = true;
                                }
                                if (diff1 == this.VALUE_DELETED && diff2 == this.VALUE_CREATED) {
                                    returnValue = null;
                                    console.log(value1);
                                    console.log(value2);
                                    console.log(value3);
                                    CONFLICT = true;
                                }
                                
                                //VALUE_UNCHANGED
                                if (diff1 == this.VALUE_UNCHANGED && diff2 == this.VALUE_DELETED) {
                                    returnValue = null;
                                }
                                if (diff1 == this.VALUE_UNCHANGED && diff2 == this.VALUE_UNCHANGED) {
                                    returnValue = value3;
                                }
                                if (diff1 == this.VALUE_UNCHANGED && diff2 == this.VALUE_UPDATED) {
                                    returnValue = value3;
                                }
                                if (diff1 == this.VALUE_UNCHANGED && diff2 == this.VALUE_CREATED) {
                                    returnValue = value3;
                                }
                                
                                //VALUE_UPDATED
                                if (diff1 == this.VALUE_UPDATED && diff2 == this.VALUE_DELETED) {
                                    returnValue = value2;
                                    console.log(value1);
                                    console.log(value2);
                                    console.log(value3);
                                    CONFLICT = true;
                                }
                                if (diff1 == this.VALUE_UPDATED && diff2 == this.VALUE_UNCHANGED) {
                                    returnValue = value2;
                                }
                                if (diff1 == this.VALUE_UPDATED && diff2 == this.VALUE_UPDATED) {
                                    console.log('VALUE_UPDATED');
                                    console.log(value2);
                                    console.log(value3);
                                    if (value2 == value3) {
                                        returnValue = value3;
                                    }
                                    else {
                                        returnValue = value2;
                                        console.log(value1);
                                    console.log(value2);
                                    console.log(value3);
                                        CONFLICT = true;
                                    }
                                    console.log(CONFLICT);
                                }
                                if (diff1 == this.VALUE_UPDATED && diff2 == this.VALUE_CREATED) {
                                    returnValue = null;
                                    console.log(value1);
                                    console.log(value2);
                                    console.log(value3);
                                    CONFLICT = true;
                                }
                                
                                //VALUE_CREATED
                                if (diff1 == this.VALUE_CREATED && diff2 == this.VALUE_DELETED) {
                                    returnValue = null;
                                    console.log(value1);
                                    console.log(value2);
                                    console.log(value3);
                                    CONFLICT = true;
                                }
                                if (diff1 == this.VALUE_CREATED && diff2 == this.VALUE_UNCHANGED) {
                                    returnValue = value2;
                                    
                                }
                                if (diff1 == this.VALUE_CREATED && diff2 == this.VALUE_UPDATED) {
                                    returnValue = null;
                                    console.log(value1);
                                    console.log(value2);
                                    console.log(value3);
                                    CONFLICT = true;
                                }
                                if (diff1 == this.VALUE_CREATED && diff2 == this.VALUE_CREATED) {
                                    
                                    if (value2 == value3) {
                                        returnValue = value3;
                                    }
                                    else {
                                        returnValue = value2;
                                        console.log(value1);
                                    console.log(value2);
                                    console.log(value3);
                                        CONFLICT = true;
                                    }
                                }
                                
                                return returnValue;
                            },
                            getKey: function(list) {
                                var firstObject = list[0];
                                var ListKeyName = [];
                                var MapKeyName = {};
                                var returnvalue = null;
                                for (var key in firstObject) {
                                    if (this.isValue(firstObject[key])) {
                                        ListKeyName.push(key);
                                        MapKeyName[key] = [];
                                    }
                                }
                                if (ListKeyName.length == 0) {
                                    return null;
                                }
                                for (var key in list) {
                                    var object = list[key];
                                    for (var key2 in MapKeyName) {
                                        var value = object[key2]
                                        if ($.inArray(value, MapKeyName[key2]) > -1) {
                                             delete MapKeyName[key2];
                                        }
                                        else {
                                            MapKeyName[key2].push(value);
                                        }
                                    }
                                    
                                }
                                var index = 0;
                                for (var key3 in MapKeyName) {
                                     index++;
                                     if (index == 1) {
                                        returnvalue = key3;
                                     }
                                }
                                if (index == 0) {
                                    returnvalue = null;
                                }
                                
                                return returnvalue;
                                
                            },
                            isFunction: function(obj) {
                                return {}.toString.apply(obj) === '[object Function]';
                            },
                            isArray: function(obj) {
                                return {}.toString.apply(obj) === '[object Array]';
                            },
                            isObject: function(obj) {
                                return {}.toString.apply(obj) === '[object Object]';
                            },
                            isValue: function(obj) {
                                return !this.isObject(obj) && !this.isArray(obj);
                            },
                            isUndefined: function(obj) {
                                return obj === undefined || obj === null;
                            }
                        }
                    }();
            
            
            
            return {
                startMerge: function(data) {
                    StartData = data;
                    START = true;
                    FINSH = false;
                    _startMerge();
                },
                getStatus: function() {
                    var retobj = {};
                    var list = {};
                    for(var key in FinishData) {
                            if ({}.toString.apply(FinishData[key]) === '[object Function]') {
                                continue;
                            }
                        
                            list[key] = FinishData[key].CONFLICT;
                    }
                    
                    retobj.Finish = FINSH
                    retobj.items = list;
                    return retobj;
                },
                getMergeFile: function(ItemId) {
                    return FinishData[ItemId];
                },
                setMergeFile: function(ItemId, File) {
                    var Item = FinishData[ItemId];
                    
                    if (Item.IsXML) {
                        if (File.indexOf('<?xml') > -1) {
                            Item.mergeFile = formatXmlDeleteTitle(File);
                            console.log('II>>>>>Item.mergeFile\n\n'+Item.mergeFile);
                            //Item.mergeFile = File;
                        }
                        else {
                            //Item.mergeFile = '<?xml version="1.0" encoding="UTF-8"?>' + File;
                            Item.mergeFile = File;
                        }
                        //console.log('II>>>>>Item.mergeFile\n\n'+Item.mergeFile);
                        // Item.mergeFile = Item.mergeFile.replace(/<[0-9]*[0-9]*[0-9]>/g, "");
                        // Item.mergeFile = Item.mergeFile.replace(/<\/[0-9]*[0-9]*[0-9]>/g, "");

                        // Item.mergeFile = Item.mergeFile.replace(/><\//g, ">\n<\/");
                        // Item.mergeFile = Item.mergeFile.replace(/></g, ">\n<");

                        Item.mergeFile = formatXmlParse(Item.mergeFile, '');

                        if (openMainTag != '' && closeMainTag != '') {
                            Item.mergeFile = Item.mergeFile.replace('<xml>', openMainTag);
                            Item.mergeFile = Item.mergeFile.replace('</xml>', closeMainTag);
                        }
                        Item.mergeFile = Item.mergeFile.replace(/><\//g, ">\n<\/");
                        Item.mergeFile = Item.mergeFile.replace(/></g, ">\n<");
                        Item.mergeFile = Item.mergeFile.replace(/    /g, "");

                        Item.mergeFile = formatXml(Item.mergeFile);
                        Item.mergeFile = formatXmldeleteEmptyTag('', Item.mergeFile);
                        Item.mergeFile = Item.mergeFile.replace(/\t/ig, '    ');

                        Item.mergeFile = '<?xml version="1.0" encoding="UTF-8"?>\n' + Item.mergeFile;
                    }
                    else {
                        Item.mergeFile = File;
                    }
                    Item.CONFLICT = false;
                    Item.IsManualMerge = true;
                    console.log('II>>>>>Item.mergeFile\n\n'+Item.mergeFile);
                }
            }
        });

        myApp.service('dataManager', function($q) {
            return {
                getBranchItems : function(param, param2) {
                    var deferred = $q.defer();
                    Visualforce.remoting.Manager.invokeAction(
                        '{!$RemoteAction.FL_LocalWorkspaceController.getBranchItems}',
                        param, param2,
                        function(result, event) {
                            if (event.status) {
                                deferred.resolve(result);
                            }
                            else {
                                deferred.reject(event);
                            }
                        });
                    return deferred.promise;
                },
                FirstStepMerge : function(param, param2, param3) {
                    var deferred = $q.defer();
                    Visualforce.remoting.Manager.invokeAction(
                        '{!$RemoteAction.FL_LocalWorkspaceController.FirstStepMerge}',
                        param, param2, param3,
                        function(result, event) {
                            if (event.status) {
                                deferred.resolve(result);
                            }
                            else {
                                deferred.reject(event);
                            }
                        });
                    return deferred.promise;
                },
                getLastAndDeployAtachment : function(last, deploy) {
                    var deferred = $q.defer();
                    Visualforce.remoting.Manager.invokeAction(
                        '{!$RemoteAction.FL_LocalWorkspaceController.getLastAndDeployAtachment}',
                        last, deploy,
                        function(result, event) {
                            if (event.status) {
                                deferred.resolve(result);
                            }
                            else {
                                deferred.reject(event);
                            }
                        });
                    return deferred.promise;
                },
                getMetaItemAtachment : function(AtachmentId) {
                    var deferred = $q.defer();
                    Visualforce.remoting.Manager.invokeAction(
                        '{!$RemoteAction.FL_LocalWorkspaceController.getMetaItemAtachment}',
                        AtachmentId,
                        function(result, event) {
                            if (event.status) {
                                deferred.resolve(result);
                            }
                            else {
                                deferred.reject(event);
                            }
                        });
                    return deferred.promise;
                }
                
            }
        });

        myApp.$inject = ['$scope', '$filter'];

        var stringListBranch = '';

        myApp.controller("RetrieveChangesController", function($scope, ngDialog, $base64, $compile, dataManager, $filter, MergeService, $interval) {
            $scope.people = ['ApexClass','ApexPage'];
            $scope.enableFilterLogic = false;
            $scope.selectedCategory = 'all';
            $scope.changesCount = 0;
            $scope.disableUi = false;
            $scope.disableCommitButton = false;
            $scope.startMergeButton = false;    //**
            $scope.selectedMetadataType = '';
            $scope.metaTypeLi   =[];
            $scope.metadataTypeOptions = [];
            $scope.CommitStep = 1;
            
            //Options
            $scope.availableOptions = [];
            $scope.selectedOptions = [];

            $scope.commitChunkLi = [];
            $scope.commitChunkIndex = 0;
            
            //Pagination variables.
            $scope.componentList = [];
            $scope.orderByColumn = 'lastModifiedDate';
            $scope.isReverse = true;
            $scope.metaOffSet = 0;
            $scope.totalRecords = 0;
            $scope.staticLimit = 50;
            $scope.viewLimit = $scope.staticLimit;
            var tempObj = {};
            //tempObj['id'] = 'Id';
            tempObj['fullName'] = 'Component Name';
            tempObj['type'] = 'Component Type';
            tempObj['lastModifiedByName'] = 'Changed By';
            tempObj['lastModifiedDate'] = 'Changed On';
            tempObj['createdByName'] = 'Created By';
            tempObj['createdOn'] = 'Created On';
            //tempObj['changedOn'] = 'Changed On';
            $scope.fieldSet = tempObj;
            
            //For Retrieval
            $scope.selectedList = [];
            
            $scope.disableRetrieveChangesButton = false;
            $scope.disablePushButton = true;
            $scope.isAllChecked = false ;
            
            //Commit Status pagination variables
            $scope.safeToCommitLi = [];
            $scope.notToCommitLi  = [];
            $scope.conflictLi = [];             //**
            $scope.componentListRemote = [];    //**
            $scope.FirstStepItems = [];         //**
            //$scope.GoodMergeItems = [];         //**

            $scope.safeOrderByColumn = 'fullName';
            $scope.safeIsReverse = false;
            $scope.safeMetaOffSet = 0;
            $scope.safeTotalRecords = 0;
            $scope.safeViewLimit = $scope.staticLimit;

            $scope.notConflictOrderByColumn = 'fullName';       //**
            $scope.notConflictIsReverse = false;                //**
            $scope.notConflictMetaOffSet = 0;                   //**
            $scope.notConflictTotalRecords = 0;                 //**    
            $scope.notConflictViewLimit = $scope.staticLimit;   //**

            $scope.conflictOrderByColumn = 'fullName';          //**
            $scope.conflictIsReverse = false;                   //**
            $scope.conflictMetaOffSet = 0;                      //**
            $scope.conflictTotalRecords = 0;                    //**    
            $scope.conflictViewLimit = $scope.staticLimit;      //**
            
            $scope.notOrderByColumn = 'fullName';
            $scope.notIsReverse = false;
            $scope.notMetaOffSet = 0;
            $scope.notTotalRecords = 0;
            $scope.notViewLimit = $scope.staticLimit;
            
            var tempObj2 = {};
            tempObj2['fullName'] = 'Component Name';
            tempObj2['metaType'] = 'Component Type';
            tempObj2['changedBy'] = 'Changed By';
            //tempObj2['changedOn'] = 'Changed On';
            tempObj2['changedOnLocal'] = 'Changed On';
            $scope.commitFieldSet = tempObj2;
            
            var tempObj3 = {};
            tempObj3['fullName'] = 'Component Name';
            tempObj3['metaType'] = 'Component Type';
            tempObj3['changedBy'] = 'Changed By';
            //tempObj3['changedOn'] = 'Changed On';
            tempObj3['changedOnLocal'] = 'Changed On';
            tempObj3['reason'] = 'Reason';
            $scope.notToCommitFieldSet = tempObj3;
            
            $scope.filterList = [];
            $scope.compareList = [];
            $scope.compareList.push('equals');
            $scope.compareList.push('not equals');
            $scope.compareList.push('contains');
            $scope.compareList.push('starts with');
            $scope.compareList.push('does not contain');
            $scope.fieldList = {};
            $scope.fieldList['type'] = 'Component Type';
            $scope.fieldList['fullName'] = 'Component Name';
            $scope.fieldList['lastModifiedByName'] = 'Changed By';
            $scope.fieldList['createdByName'] = 'Created By';
            $scope.mainFilterList = [];

            var tempObj4 = {};                              //**
            tempObj4['fullName'] = 'Component Name';        //**
            tempObj4['metaType'] = 'Component Type';        //**
            tempObj4['changedBy'] = 'Changed By';           //**
            tempObj4['changedOn'] = 'Changed On';           //**
            tempObj4['contentLength'] = 'Content Length';   //**
            tempObj4['reason'] = 'Result';                  //**
            $scope.conflictFieldSet = tempObj4;             //**

            selfConn = createSelfConnection();
            selfConn.metadata.describe(apiVersion).then(function(result, err){
                if(err)
                {
                    console.log(err);
                }
                else if(result != undefined && result.metadataObjects != undefined && Array.isArray(result.metadataObjects))
                {
                    $scope.$apply(function() {
                        if(supportedTypes != undefined && supportedTypes != '')
                        {
                            var supportedMap = {};
                            var spLi = JSON.parse(supportedTypes);
                            for(var index in spLi)
                                if(index < spLi.length)
                                    supportedMap[spLi[index]] = spLi[index];
                            for(var index=0; index < result.metadataObjects.length; index++)
                            {
                                var metaType = result.metadataObjects[index];
                                if(metaType != undefined && metaType.xmlName != undefined )
                                {
                                    if(supportedMap[metaType.xmlName] != undefined)
                                        $scope.metaTypeLi.push(metaType.xmlName);
                                    if(metaType.childXmlNames != undefined && Array.isArray(metaType.childXmlNames))
                                    {
                                        for(var index2=0; index2 < metaType.childXmlNames.length; index2++)
                                        {
                                            var childType = metaType.childXmlNames[index2];
                                            if(childType != undefined && supportedMap[childType] != undefined)
                                            {
                                                $scope.metaTypeLi.push(childType);
                                            }
                                        }
                                    }
                                }
                            }
                        }
                        $scope.metaTypeLi.sort();
                        supportedTypesForCurrentOrg = $scope.metaTypeLi;
                        if($scope.metaTypeLi.length == 0)
                        {
                            $scope.disableRetrieveChangesButton = true;
                        }
                        if ('{!branchName}' == null || '{!branchName}' == undefined || '{!branchName}' == '') {
                            $scope.disableRetrieveChangesButton = true;
                            $scope.showErrorMessage('Please select the branch in the Settings tab. The components will be committed to that branch.');
                        }

                        $scope.selectedOptions = $scope.metaTypeLi;
                    });
                }
            });
            
            $scope.setFilterRow = function(filterIndex,fieldType,selectedItems){
                if(filterIndex < $scope.filterList.length)
                {
                    var filterRow = $scope.filterList[filterIndex];
                    //filterRow.field = fieldType;
                    //filterRow.operator = 'equals';
                    var tempStr = '';
                    angular.forEach(selectedItems, function(str) {
                        if(tempStr == '')
                            tempStr += str;
                        else
                            tempStr += ','+str;
                    });
                    $scope.$apply(function() {
                        filterRow.value = tempStr;
                    });
                }
            };
            
            $scope.createLookupLink = function(fieldName,filterIndex,fieldValue){
                var link = '{!customLookupPageName}?fieldName='+fieldName+'&filterIndex='+filterIndex+'&fieldValue='+fieldValue;
                console.log(link);
                window.open(link, 'MsgWindow', 'width=600,height=600,resizable=1,scrollbars=1');
            };

            $scope.addDefaultRowToSearch = function(){
                if($scope.filterList.length < 9)
                {
                    var filterRow = {};
                    filterRow.field = 'type';
                    filterRow.operator = 'equals';
                    filterRow.value = 'All';
                    $scope.filterList.push(filterRow);
                }
            }

            $scope.addRowToSearch = function(){
                if($scope.filterList.length < 9)
                {
                    var filterRow = {};
                    filterRow.field = '';
                    filterRow.operator = '';
                    filterRow.value = '';
                    $scope.filterList.push(filterRow);
                }
            }

            $scope.applySearch = function(){
                $scope.mainFilterList = [];
                for(var index=0; index < $scope.filterList.length; index++)
                {
                    var filterRow = $scope.filterList[index];
                    $scope.mainFilterList.push(JSON.parse(JSON.stringify(filterRow)));
                }
            }
            $scope.addRowToSearch();
            $scope.addRowToSearch();
            $scope.addRowToSearch();
            $scope.addRowToSearch();
            $scope.addRowToSearch();
            $scope.applySearch();

            $scope.filterForSearch = function(meta){
                if($scope.selectedMetadataType != '' && meta.type != $scope.selectedMetadataType)
                {
                    return false;
                }
                return true;
            }

            $scope.createListOnFinishOfQuery = function(){
                console.log('Query Completed.');
                console.log(filteredMetaItems);
                $scope.$apply(function() {
                    if(isMapEmpty(filteredMetaItems))
                    {
                        $scope.disableRetrieveChangesButton = false;
                        $scope.disableUi = false;
                        setDefaultMessageOnPage('No change found.');
                    }
                    else
                    {
                        var filterTypeList = [];
                        var tempTypLi = [];
                        for(key in filteredMetaItems)
                        {
                            var tempTypelist = filteredMetaItems[key];
                            for(var index=0; index < tempTypelist.length; index++)
                            {
                                    var meta = tempTypelist[index];
                                    meta.checked = false;
                                    meta.changedOn = convertGMTToLocalTime(meta.lastModifiedDate);//formatAMPM(new Date(meta.lastModifiedDate));
                                    meta.createdOn = convertGMTToLocalTime(meta.createdDate);//formatAMPM(new Date(meta.createdDate));
                                    filterTypeList.push(meta);
                            }
                            if(tempTypelist.length > 0)
                                tempTypLi.push(key);
                        }
                        if(tempTypLi.length > 0)
                        {
                            tempTypLi.sort();
                            for(var index= 0; index < tempTypLi.length; index++)
                                $scope.metadataTypeOptions.push(tempTypLi[index]);
                        }
                        $scope.componentList = filterTypeList;
                        $scope.totalRecords = filterTypeList.length;

                        $scope.finishRetrieveChanges();
                        console.log('createListOnFinishOfQuery');
                    }
                });
            }
            
            $scope.refreshOrderBy = function(orderVal) {
                $scope.metaOffSet = 0;
                $scope.viewLimit = $scope.metaOffSet + $scope.staticLimit;
                if(orderVal == $scope.orderByColumn)
                    $scope.isReverse = !$scope.isReverse;
                else
                {
                    $scope.isReverse = false;
                    $scope.orderByColumn = orderVal;
                }
                $scope.defaultNextPrevious();
            };
            
            $scope.showFirst = function() {
                $scope.metaOffSet = 0;
                $scope.viewLimit = $scope.staticLimit;
                $scope.defaultNextPrevious();      
            };
            
            $scope.listPrevious = function() {
                $scope.metaOffSet = $scope.metaOffSet - $scope.staticLimit;
                if ($scope.metaOffSet < 0)
                    $scope.metaOffSet = 0;
                $scope.viewLimit = $scope.metaOffSet + $scope.staticLimit;
                $scope.defaultNextPrevious();
            };
            
            $scope.listNext = function(tempTotal) {
                if (($scope.metaOffSet + $scope.staticLimit) < tempTotal)
                {
                    $scope.metaOffSet = $scope.metaOffSet + $scope.staticLimit;
                    $scope.viewLimit = $scope.metaOffSet + $scope.staticLimit;
                }
                $scope.defaultNextPrevious();
            };
            
            $scope.showLast = function(tempTotal) {
                $scope.metaOffSet = tempTotal - (tempTotal % $scope.staticLimit);
                if($scope.metaOffSet == tempTotal && $scope.metaOffSet != 0)
                {
                    $scope.metaOffSet = tempTotal - $scope.staticLimit;
                }
                $scope.viewLimit = $scope.metaOffSet + $scope.staticLimit;
                $scope.defaultNextPrevious();
            };
            
            $scope.defaultRetrieveChanges = function() {
                $scope.$apply(function() {
                    //defaultClear
                    $scope.disableUi = true;
                    $scope.componentList = [];
                    $scope.metadataTypeOptions = [];
                    $scope.selectedMetadataType = '';
                    $scope.selectedList = [];
                    $scope.orderByColumn = 'lastModifiedDate';
                    $scope.isReverse = true;
                    $scope.metaOffSet = 0;
                    $scope.totalRecords = 0;
                    $scope.viewLimit = $scope.staticLimit;
                    $scope.disableRetrieveChangesButton = true;
                    $scope.disablePushButton = true;
                    $scope.isAllChecked = false ;

                    console.log('defaultRetrieveChanges');
                    listComponents();
                });

            };
            
            $scope.finishRetrieveChanges = function() {
                $scope.disableRetrieveChangesButton = true;
                $scope.disablePushButton = false;
                $scope.disableUi = false;
                setDefaultMessageOnPage('');
            };
            
            $scope.checkItemAll = function(isAllChecked,compLi,offset) {
                 for(var index = offset ; index < (offset+$scope.staticLimit) && index < compLi.length  ; index++) {
                    if(isAllChecked)
                        compLi[index].checked = true;
                    else
                        compLi[index].checked = false;  
                 }
            };
            
            $scope.checkUnCheck = function(compLi,offset) {
                var flag = true;
                var index;
                for(var index = offset ; index < (offset+$scope.staticLimit) && index < compLi.length  ; index++) {
                    if( ! compLi[index].checked ) {
                        flag = false;
                        break;
                    }
                }
                $scope.isAllChecked = flag ;
                return flag;
            };
            
            $scope.defaultNextPrevious = function(){
                $scope.isAllChecked = false ;
            }
            
            $scope.isPrevious = function() {
                if($scope.metaOffSet < 1) 
                    return true;
                else {
                    return false;
                }
            };
            
            $scope.isNext = function(tempTotal){
                if(tempTotal > $scope.metaOffSet+$scope.staticLimit){
                    return false;
                }
                else {
                    return true;
                }
            };
            
            $scope.totalPageCount = function(tempTotal){
                var totalPage = parseInt(tempTotal % $scope.staticLimit > 0 ? (tempTotal / $scope.staticLimit)+1 : (tempTotal / $scope.staticLimit));
                return totalPage;
                
            };
            
            $scope.currentPageNo = function(tempTotal){
                var currentPage = 1;
                if($scope.metaOffSet <  $scope.staticLimit)
                    currentPage =  1;
                else
                {
                    currentPage = Math.ceil($scope.metaOffSet / $scope.staticLimit)+1;
                }
                return currentPage;
            };
            
            $scope.startRetrievalForAllSelectedForPush = function(){
                console.log('startRetrievalForAllSelectedForPush');
                setDefaultMessageOnPage('Please wait...');
                $scope.disablePushButton = true;
                $scope.disableUi = true;
                $scope.selectedList = [];
                filteredMetaItems = {};
                requestMetaTypeLi = [];
                requestIndex = 0;
                angular.forEach($scope.componentList, function(comp) {
                    if(comp.checked)
                    {
                        var tempLi = [];
                        if(filteredMetaItems[comp.type] != undefined)
                        {
                            tempLi = filteredMetaItems[comp.type];
                        }
                        tempLi.push(comp);
                        filteredMetaItems[comp.type] = tempLi;
                    }
                });
                var tempOrderLi = [];
                for(var key in filteredMetaItems)
                {
                    if(folderToTypeMap[key] == undefined)
                    {
                        requestMetaTypeLi.push(key);
                    }
                }
                if(requestMetaTypeLi.length > 0)
                {
                    createLog();
                }
                else
                {
                    $scope.disablePushButton = false;
                    $scope.showErrorMessage('Please select a component.');
                }
            };
          
            
            $scope.finishRetrieval = function(){
                //disablePushButton = false;
                $scope.componentList = [];
                $scope.safeToCommitLi = [];
                $scope.notToCommitLi  = [];
                console.log(logId);
                if(logId != undefined && logId != null && logId.length == 18)
                {
                    Visualforce.remoting.Manager.invokeAction(
                        '{!$RemoteAction.FL_LocalWorkspaceController.getCommitDetail}',
                        logId,
                        function(r, e){
                            if(e.status) 
                            {
                                console.log(r);
                                if(r.length > 0 )
                                {
                                    $scope.$apply(function() {
                                        console.log('$scope.safeToCommitLi.length--'+$scope.safeToCommitLi.length);
                                        for(var index=0; index< r.length; index++)
                                        {
                                            var comp = r[index];
                                            comp.changedOnLocal = convertGMTToLocalTime(comp.changedOn);
                                            if(comp.isSafe)
                                                $scope.safeToCommitLi.push(comp);
                                            else
                                            {
                                                $scope.notToCommitLi.push(comp);
                                            }
                                        }
                                        console.log('$scope.safeToCommitLi.length--'+$scope.safeToCommitLi.length);

                                        if($scope.safeToCommitLi.length == 0) {
                                            $scope.disableCommitButton = true;
                                        }
                                        else {
                                            mergeComponents();
                                        }


                                        $scope.CommitStep = 2;
                                        $scope.disableUi = false;
                                        
                                        setDefaultMessageOnPage('');
                                    });
                                }
                                else
                                {
                                    $scope.disablePushButton = false;
                                    $scope.showErrorMessage('No component found.');
                                }
                            }
                            else
                            {
                                $scope.disablePushButton = false;
                                $scope.showErrorMessage(e.message);
                            }
                    });
                }
            };
            
            $scope.startFinalCommit = function(){
                $scope.disableUi = true;
                $scope.commitChunkLi = [];
                $scope.commitChunkIndex = 0;

                if ($scope.conflictLi.length > 0) {
                    $scope.saveMergeFile();
                    console.log($scope.conflictLi);
                    angular.forEach($scope.conflictLi, function(merg) {
                        tempMerg = {};
                        tempMerg.changedBy = merg.changedBy;
                        tempMerg.changedOn = merg.changedOn;
                        tempMerg.compId = merg.compId;
                        tempMerg.fullName = merg.fullName;
                        tempMerg.isSave = merg.isSave;
                        tempMerg.metaType = merg.metaType;
                        tempMerg.status = merg.status;
                        tempMerg.reason = merg.reason;
                        tempMerg.contentLength = merg.contentLength;
                        $scope.safeToCommitLi.push(tempMerg);
                    });
                }

                var bodyCount = 0;
                var chunkLi = [];
                console.log($scope.safeToCommitLi);
                for(var safeIndex=0; safeIndex < $scope.safeToCommitLi.length; safeIndex++)
                {
                    var comp = $scope.safeToCommitLi[safeIndex];
                    if(comp.compId != undefined && comp.compId != null && comp.compId.length == 18 && comp.contentLength != undefined)
                    {
                        if(((bodyCount + comp.contentLength) > 1500000 || chunkLi.length % 800 == 0) && chunkLi.length > 0 )
                        {
                            console.log('chunkLi.length--'+chunkLi.length);
                            $scope.commitChunkLi.push(chunkLi);
                            bodyCount = 0;
                            chunkLi = [];
                        }
                        chunkLi.push(comp.compId);
                        bodyCount = bodyCount + comp.contentLength;
                    }
                }

                // angular.forEach($scope.safeToCommitLi, function(comp) {
                //     if(comp.compId != undefined && comp.compId != null && comp.compId.length == 18)
                //     {
                //         if(((bodyCount + comp.contentLength) > 2000000 || chunkLi.length % 1000 == 0) && chunkLi.length > 0 )
                //         {
                //             console.log(chunkLi.length);
                //             $scope.commitChunkLi.push(chunkLi);
                //             bodyCount = 0;
                //             chunkLi = [];
                //         }
                //         chunkLi.push(comp.compId);
                //         bodyCount = bodyCount + comp.contentLength;
                //     }
                // });

                if(chunkLi.length > 0)
                {
                    console.log('chunkLi.length--'+chunkLi.length);
                    $scope.commitChunkLi.push(chunkLi);
                }
                console.log($scope.commitChunkLi);
                $scope.commitInChunk();
            }
            
            $scope.commitInChunk = function(){
                if($scope.commitChunkIndex < $scope.commitChunkLi.length)
                {
                    var chunkIds = $scope.commitChunkLi[$scope.commitChunkIndex];
                    console.log(chunkIds);
                    console.log(chunkIds.length);
                    Visualforce.remoting.Manager.invokeAction(
                        '{!$RemoteAction.FL_LocalWorkspaceController.commitComponents}',
                        chunkIds,
                        syncId,
                        function(r, e){
                            if(e.status && r) 
                            {
                                console.log(r);
                                if(r == 'true')
                                {
                                    $scope.commitChunkIndex++;
                                    $scope.commitInChunk();
                                }
                                else
                                {
                                    $scope.showErrorMessage(r);
                                }
                            }
                            else
                            {
                                $scope.showErrorMessage(e.message);
                            }
                    });
                }
                else
                {
                    finishCommit();
                }
            }

            $scope.createSyncRecord = function() {
                $scope.disableCommitButton = true;
                setDefaultMessageOnPage('Please wait...');
                createSyncLog();
            }

            $scope.getStatusConflicts = function() {
                $scope.disableCommitButton = false;
                //var tempFirstStepItems = [];
                for (x = 0; x < $scope.FirstStepItems.length; x++) {
                    if ($scope.FirstStepItems[x].CONFLICT == true) {
                        $scope.disableCommitButton = true;

                        //tempFirstStepItems.push($scope.FirstStepItems[x])
                    }
                    else {

                        //$scope.GoodMergeItems.push($scope.FirstStepItems[x]); 
                    }
                }
                //$scope.FirstStepItems = tempFirstStepItems;
            }

            $scope.saveMergeFile = function(){
                $scope.$apply(function() {
                    $scope.mergeFiles = [];
                    //angular.forEach($scope.GoodMergeItems, function(merg) {
                    angular.forEach($scope.FirstStepItems, function(merg) {
                        tempMerg = [];

                        var fileZip = new JSZip();
                        fileZip.file(merg.Label,merg.mergeFile);
                        if (merg.MetaItemFileMeta != null) {
                            fileZip.file(merg.Label+"-meta.xml",merg.MetaItemFileMeta);
                        }
                        var mergeFileZip = fileZip.generate({type:"base64",compression:"DEFLATE"});
                        var mergeFileZip2 = fileZip.file(merg.Label).asBinary();
                        var mergeFileCRC32 = fileZip.crc32(mergeFileZip2,32);
                        console.log('---===1-' + mergeFileCRC32);

//var bundleData = getCrcWithData(zipFiles[tempFileName].asBinary());
//                        var merge2FileZip = fileZip.file(merg.Label).asBinary();
//                        var merge2FileCRC32 = fileZip.crc32(merg.merge2FileZip,32);
//                        console.log('---===2-' + merge2FileCRC32);

/*function getCrcWithData(zipData)
        {
            var r = new Object();
            r.crc32 = normalZip.crc32(zipData,32);
            r.data = zipData;
            return r;
        }*/
                                //var zipLast = new JSZip(LastAtachmentZip, {base64:true});
                                //var fileLast = zipLast.file(Item.Label).asBinary();
                                //Item.LastCRC32 = zipLast.crc32(fileLast, 32);

                        tempMerg.push(mergeFileZip);
                        tempMerg.push(merg.AttachmentId);
                        tempMerg.push(mergeFileCRC32);
                        //tempMerg.push(merge2FileCRC32);

                        $scope.mergeFiles.push(tempMerg);
                    });
                    updateMergeFile($scope.mergeFiles);
                });
            }
            
            //Safe to commit
            $scope.safeRefreshOrderBy = function(orderVal) {
                $scope.safeMetaOffSet = 0;
                $scope.safeViewLimit = $scope.safeMetaOffSet + $scope.staticLimit;
                if(orderVal == $scope.safeOrderByColumn) 
                    $scope.safeIsReverse = !$scope.safeIsReverse;
                else
                {
                    $scope.safeIsReverse = false;
                    $scope.safeOrderByColumn = orderVal;
                }
            };
            $scope.safeShowFirst = function() {
                $scope.safeMetaOffSet = 0;
                $scope.safeViewLimit = $scope.staticLimit;    
            };
            $scope.safeListPrevious = function() {
                $scope.safeMetaOffSet = $scope.safeMetaOffSet - $scope.staticLimit;
                if($scope.safeMetaOffSet < 0)
                    $scope.safeMetaOffSet = 0;
                $scope.safeViewLimit = $scope.safeMetaOffSet + $scope.staticLimit;
            };
            $scope.safeListNext = function(tempTotal) {
                if(($scope.safeMetaOffSet + $scope.staticLimit) < tempTotal)
                {
                    $scope.safeMetaOffSet = $scope.safeMetaOffSet + $scope.staticLimit;
                    $scope.safeViewLimit = $scope.safeMetaOffSet + $scope.staticLimit;
                }
            };
            $scope.safeShowLast = function(tempTotal) {
                $scope.safeMetaOffSet = tempTotal - (tempTotal % $scope.staticLimit);
                if($scope.safeMetaOffSet == tempTotal && $scope.safeMetaOffSet != 0)
                {
                    $scope.safeMetaOffSet = tempTotal - $scope.staticLimit;
                }
                $scope.safeViewLimit = $scope.safeMetaOffSet + $scope.staticLimit;
            };
            $scope.safeIsPrevious = function() {
                if($scope.safeMetaOffSet < 1) 
                    return true;
                else {
                    return false;
                }
            };
            $scope.safeIsNext = function(tempTotal){
                if(tempTotal > $scope.safeMetaOffSet+$scope.staticLimit){
                    return false;
                }
                else {
                    return true;
                }
            };
            $scope.safeTotalPageCount = function(tempTotal){
                var totalPage = parseInt(tempTotal % $scope.staticLimit > 0 ? (tempTotal / $scope.staticLimit)+1 : (tempTotal / $scope.staticLimit));
                return totalPage;
                
            };
            $scope.safeCurrentPageNo = function(tempTotal){
                var currentPage = 1;
                if($scope.safeMetaOffSet <  $scope.staticLimit)
                    currentPage =  1;
                else
                {
                    currentPage = Math.ceil($scope.safeMetaOffSet / $scope.staticLimit)+1;
                }
                return currentPage;
            };
            
            /******************************************************************************************/
            //not conflict to commit
            $scope.notConflictRefreshOrderBy = function(orderVal) {
                $scope.notConflictMetaOffSet = 0;
                $scope.notConflictViewLimit = $scope.notConflictMetaOffSet + $scope.staticLimit;
                if(orderVal == $scope.notConflictOrderByColumn)
                    $scope.notConflictIsReverse = !$scope.notConflictIsReverse;
                else
                {
                    $scope.notConflictIsReverse = false;
                    $scope.notConflictOrderByColumn = orderVal;
                }
            };
            $scope.notConflictShowFirst = function() {
                $scope.notConflictMetaOffSet = 0;
                $scope.notConflictViewLimit = $scope.staticLimit;    
            };
            $scope.notConflictListPrevious = function() {
                $scope.notConflictMetaOffSet = $scope.notConflictMetaOffSet - $scope.staticLimit;
                if($scope.notConflictMetaOffSet < 0)
                    $scope.notConflictMetaOffSet = 0;
                $scope.notConflictViewLimit = $scope.notConflictMetaOffSet + $scope.staticLimit;
            };
            $scope.notConflictListNext = function(tempTotal) {
                if(($scope.notConflictMetaOffSet + $scope.staticLimit) < tempTotal)
                {
                    $scope.notConflictMetaOffSet = $scope.notConflictMetaOffSet + $scope.staticLimit;
                    $scope.notConflictViewLimit = $scope.notConflictMetaOffSet + $scope.staticLimit;
                }
            };
            $scope.notConflictShowLast = function(tempTotal) {
                $scope.notConflictMetaOffSet = tempTotal - (tempTotal % $scope.staticLimit);
                if($scope.notConflictMetaOffSet == tempTotal && $scope.notConflictMetaOffSet != 0)
                {
                    $scope.notConflictMetaOffSet = tempTotal - $scope.staticLimit;
                }
                $scope.notConflictViewLimit = $scope.notConflictMetaOffSet + $scope.staticLimit;
            };
            $scope.notConflictIsPrevious = function() {
                if($scope.notConflictMetaOffSet < 1) 
                    return true;
                else {
                    return false;
                }
            };
            $scope.notConflictIsNext = function(tempTotal){
                if(tempTotal > $scope.notConflictMetaOffSet+$scope.staticLimit){
                    return false;
                }
                else {
                    return true;
                }
            };
            $scope.notConflictTotalPageCount = function(tempTotal){
                var totalPage = parseInt(tempTotal % $scope.staticLimit > 0 ? (tempTotal / $scope.staticLimit)+1 : (tempTotal / $scope.staticLimit));
                return totalPage;
                
            };
            $scope.notConflictCurrentPageNo = function(tempTotal){
                var currentPage = 1;
                if($scope.notConflictMetaOffSet <  $scope.staticLimit)
                    currentPage =  1;
                else
                {
                    currentPage = Math.ceil($scope.notConflictMetaOffSet / $scope.staticLimit)+1;
                }
                return currentPage;
            };

            //conflict to commit
            $scope.conflictRefreshOrderBy = function(orderVal) {
                $scope.conflictMetaOffSet = 0;
                $scope.conflictViewLimit = $scope.conflictMetaOffSet + $scope.staticLimit;
                if(orderVal == $scope.conflictOrderByColumn)
                    $scope.conflictIsReverse = !$scope.conflictIsReverse;
                else
                {
                    $scope.conflictIsReverse = false;
                    $scope.conflictOrderByColumn = orderVal;
                }
            };
            $scope.conflictShowFirst = function() {
                $scope.conflictMetaOffSet = 0;
                $scope.conflictViewLimit = $scope.staticLimit;    
            };
            $scope.conflictListPrevious = function() {
                $scope.conflictMetaOffSet = $scope.conflictMetaOffSet - $scope.staticLimit;
                if($scope.conflictMetaOffSet < 0)
                    $scope.conflictMetaOffSet = 0;
                $scope.conflictViewLimit = $scope.conflictMetaOffSet + $scope.staticLimit;
            };
            $scope.conflictListNext = function(tempTotal) {
                if(($scope.conflictMetaOffSet + $scope.staticLimit) < tempTotal)
                {
                    $scope.conflictMetaOffSet = $scope.conflictMetaOffSet + $scope.staticLimit;
                    $scope.conflictViewLimit = $scope.conflictMetaOffSet + $scope.staticLimit;
                }
            };
            $scope.conflictShowLast = function(tempTotal) {
                $scope.conflictMetaOffSet = tempTotal - (tempTotal % $scope.staticLimit);
                if($scope.conflictMetaOffSet == tempTotal && $scope.conflictMetaOffSet != 0)
                {
                    $scope.conflictMetaOffSet = tempTotal - $scope.staticLimit;
                }
                $scope.conflictViewLimit = $scope.conflictMetaOffSet + $scope.staticLimit;
            };
            $scope.conflictIsPrevious = function() {
                if($scope.conflictMetaOffSet < 1) 
                    return true;
                else {
                    return false;
                }
            };
            $scope.conflictIsNext = function(tempTotal){
                if(tempTotal > $scope.conflictMetaOffSet+$scope.staticLimit){
                    return false;
                }
                else {
                    return true;
                }
            };
            $scope.conflictTotalPageCount = function(tempTotal){
                var totalPage = parseInt(tempTotal % $scope.staticLimit > 0 ? (tempTotal / $scope.staticLimit)+1 : (tempTotal / $scope.staticLimit));
                return totalPage;
                
            };
            $scope.conflictCurrentPageNo = function(tempTotal){
                var currentPage = 1;
                if($scope.conflictMetaOffSet <  $scope.staticLimit)
                    currentPage =  1;
                else
                {
                    currentPage = Math.ceil($scope.conflictMetaOffSet / $scope.staticLimit)+1;
                }
                return currentPage;
            };
            
            //Not to commit
            $scope.notRefreshOrderBy = function(orderVal) {
                $scope.notMetaOffSet = 0;
                $scope.notViewLimit = $scope.notMetaOffSet + $scope.staticLimit;
                if(orderVal == $scope.notOrderByColumn)
                    $scope.notIsReverse = !$scope.notIsReverse;
                else
                {
                    $scope.notIsReverse = false;
                    $scope.notOrderByColumn = orderVal;
                }
            };
            $scope.notShowFirst = function() {
                $scope.notMetaOffSet = 0;
                $scope.notViewLimit = $scope.staticLimit;
            };
            $scope.notListPrevious = function() {
                $scope.notMetaOffSet = $scope.notMetaOffSet - $scope.staticLimit;
                if($scope.notMetaOffSet < 0)
                    $scope.notMetaOffSet = 0;
                $scope.notViewLimit = $scope.notMetaOffSet + $scope.staticLimit;
            };
            $scope.notListNext = function(tempTotal) {
                if(($scope.notMetaOffSet + $scope.staticLimit) < tempTotal)
                {
                    $scope.notMetaOffSet = $scope.notMetaOffSet + $scope.staticLimit;
                    $scope.notViewLimit = $scope.notMetaOffSet + $scope.staticLimit;
                }
            };
            $scope.notShowLast = function(tempTotal) {
                $scope.notMetaOffSet = tempTotal - (tempTotal % $scope.staticLimit);
                if($scope.notMetaOffSet == tempTotal && $scope.notMetaOffSet != 0)
                {
                    $scope.notMetaOffSet = tempTotal - $scope.staticLimit;
                }
                $scope.notViewLimit = $scope.notMetaOffSet + $scope.staticLimit;
            };
            $scope.notIsPrevious = function() {
                if($scope.notMetaOffSet < 1) 
                    return true;
                else {
                    return false;
                }
            };
            $scope.notIsNext = function(tempTotal){
                if(tempTotal > $scope.notMetaOffSet+$scope.staticLimit){
                    return false;
                }
                else {
                    return true;
                }
            };
            $scope.notTotalPageCount = function(tempTotal){
                var totalPage = parseInt(tempTotal % $scope.staticLimit > 0 ? (tempTotal / $scope.staticLimit)+1 : (tempTotal / $scope.staticLimit));
                return totalPage;
                
            };
            $scope.notCurrentPageNo = function(tempTotal){
                var currentPage = 1;
                if($scope.notMetaOffSet <  $scope.staticLimit)
                    currentPage =  1;
                else
                {
                    currentPage = Math.ceil($scope.notMetaOffSet / $scope.staticLimit)+1;
                }
                return currentPage;
            };
            $scope.enableCommitButtonAgain = function(){
                $scope.$apply(function() {
                    $scope.disableCommitButton = false;
                });
            };
            
            $scope.showErrorMessage = function(str){
                $scope.disableUi = false;
                if($('#msg') != undefined)
                {
                    $('#msg').remove();
                }
                var parentVal = $("[id$='msg']");
                if(parentVal != undefined)
                {
                    var childVal = '<span id="msg">'+
                                    '<span>'+
                                        '<div class="message errorM3" role="alert">'+
                                            '<table border="0" cellpadding="0" cellspacing="0" class="messageTable" style="padding:0px;margin:0px;">'+
                                                '<tbody>'+
                                                    '<tr valign="top">'+
                                                    '<td>'+
                                                        '<img alt="ERROR" class="msgIcon" src="/s.gif" title="ERROR">'+
                                                    '</td>'+
                                                    '<td class="messageCell">'+
                                                        '<div class="messageText">'+
                                                            '<span style="color:#cc0000">'+
                                                                '<h4>Error:</h4>'+
                                                            '</span>'+
                                                            str+'<br>'+
                                                        '</div>'+
                                                    '</td>'+
                                                    '</tr>'+
                                                    '<tr>'+
                                                        '<td></td>'+
                                                        '<td></td>'+
                                                    '</tr>'+
                                                '</tbody>'+
                                            '</table>'+
                                        '</div>'+
                                    '</span>'+
                                '</span>';
                    parentVal.before(childVal);
                }
            }

            $scope.reRenderMergeComponents = function() {
                $scope.$apply(function(){
                    $scope.conflictLi = allMapMerge;

                    listNameComponentForRemoteBranch = [];
                    angular.forEach($scope.conflictLi, function(comp) {
                        comp.reason = 'not in branch';
                        listNameComponentForRemoteBranch.push(comp.fullName);
                    });
                    if (listNameComponentForRemoteBranch.length > 0) {
                        jsonListNameComponent = JSON.stringify(listNameComponentForRemoteBranch);
                        getRemoteBranch(jsonListNameComponent);
                    }

                });
            };

            $scope.reRenderRemoteChanges = function() {
                $scope.$apply(function(){
                    $scope.componentListRemote = allCompsMapRemote;
                });
            };

            $scope.mergeSelectedList = function(listFromBranch) {
                $scope.$apply(function() {
                    listFromRemoteBranch = listFromBranch;
                    $scope.conflictLiTemp = [];
                    $scope.safeToCommitLiTemp = [];
                    for (var y=0; y < $scope.conflictLi.length; y++) {
                        var isFound = false;
                        for (var x=0; x < listFromBranch.length; x++) {
                            if ($scope.conflictLi[y].fullName == listFromBranch[x].compName && $scope.conflictLi[y].metaType == listFromBranch[x].compType) {
                                
                                $scope.conflictLi[y].reason = listFromBranch[x].reason;
                                $scope.conflictLi[y].remoteId = listFromBranch[x].compId;
                                $scope.startMergeButton = true;

                                
                                isFound = true;
                            }
                        }
                        if (isFound == false) {
                            $scope.safeToCommitLiTemp.push($scope.conflictLi[y]);
                        }
                        else {
                            $scope.conflictLiTemp.push($scope.conflictLi[y]);
                        }

                    }
                    $scope.conflictLi = $scope.conflictLiTemp;
                    $scope.safeToCommitLi = $scope.safeToCommitLiTemp;

                    setDefaultMessageOnPage('');
                    getParament();
                });
            }

            /******************* AUTO MERGE *************************/
            $scope.IsErrorNotBS = false;
            $scope.Start = false;
            $scope.PageSelectItems = false;
            $scope.SELECTAll = true;
            $scope.groupedItems = [];
            $scope.itemsPerPage = 20;
            $scope.pagedItems = [];

            $scope.DATA_Snapshot;

            function getParament() {
                stringListBranch = JSON.stringify(listFromRemoteBranch)
                stringIdBranch = logId;
                listSnapshots = JSON.parse(stringListBranch);

                $scope.Start = true;
                $scope.IsErrorNotBS = false;
                $scope.DATA_Branchs = stringIdBranch;
                $scope.DATA_Snapshot = listSnapshots;

                dataManager.getBranchItems(stringIdBranch, stringListBranch).then(
                    function(data) {
                        
                        $scope.Items = FortDATA(data)
                        console.log($scope.Items);
                        $scope.Start = false;
                        $scope.PageSelectItems = true;
                        $scope.search();
                        
                    },
                    function (error) {
                        $scope.errorMessage = error.message;
    
                    }
                );
            }

            $scope.search = function () {
                
                $scope.currentPage = 0;
                // now group by pages
                $scope.groupToPages();
            };
            
            // calculate page in place
            $scope.groupToPages = function () {
                $scope.pagedItems = [];
                
                for (var i = 0; i < $scope.Items.length; i++) {
                    if (i % $scope.itemsPerPage === 0) {
                        $scope.pagedItems[Math.floor(i / $scope.itemsPerPage)] = [ $scope.Items[i] ];
                    } else {
                        $scope.pagedItems[Math.floor(i / $scope.itemsPerPage)].push($scope.Items[i]);
                    }
                }

                $scope.Commit();
            };

            function FortDATA(param) {
                param = $('<div/>').html(param).text();
                return angular.fromJson(param);
            }

            $scope.Commit = function() {
                console.log('Commit');
                var selectList = [];
                var selectListName = [];
                var selectListId = [];
                for (var x=0; x < $scope.Items.length; x++) {
                    selectList.push($scope.Items[x]);
                    selectListName.push($scope.Items[x].Name);
                    selectListId.push($scope.Items[x].ItemId);
                }
                if (selectListName.length > 0) {
                    $scope.PageSelectItems = false;
                    dataManager.FirstStepMerge(stringIdBranch, selectListId, stringListBranch).then(
                        function(data) {
                            var D = FortDATA(data)
                            $scope.FirstStepItems = D;
                            if (angular.isArray($scope.FirstStepItems)) {
                                var mergeDATA = [];
                                for (var x = 0; x < $scope.FirstStepItems.length ; x++) {
                                    if (!$scope.FirstStepItems[x].IsLastVersion  && $scope.FirstStepItems[x].LastComponentHistoryATID != null) {
                                        $scope.FirstStepItems[x].AutoMergeStart = true;
                                        mergeDATA.push($scope.FirstStepItems[x]);
                                    }
                                    if ($scope.FirstStepItems[x].IsLastVersion  && $scope.FirstStepItems[x].LastComponentHistoryCRC32 == $scope.FirstStepItems[x].DeployedComponentHistoryCRC32) {
                                        $scope.FirstStepItems[x].AutoMergeStart = true;
                                        mergeDATA.push($scope.FirstStepItems[x]);
                                    }
                                }
                                if (mergeDATA.length > 0) {
                                    $scope.disableCommitButton = true;
                                    MergeService.startMerge(mergeDATA);
                                    $scope.monitorTheProcess();
                                    
                                }
                                
                            }
                        },
                        function (error) {
                            $scope.errorMessage = error.message;
        
                        }
                    );
                }
            }

            var stop;
            $scope.monitorTheProcess = function() {
                stop = $interval(function() {
                    var status = MergeService.getStatus();
                    console.log(status);
                    if (status != null && status.Finish) {
                        statusInfo(status.items);
                        $scope.stopFight();
                    } else {
                        if (status != null && status.items != null) {
                            statusInfo(status.items);
                        }
                    }
                }, 500);
                
            }
            function statusInfo(param) {
                for (var x = 0; x < $scope.FirstStepItems.length ; x++) {
                    var item = $scope.FirstStepItems[x];
                    if (param[item.ItemId] != null) {
                        item.AutoMergeFinish = true;
                        item.AutoMergeStatus = param[item.ItemId];
                    }
                }
            }
            
            $scope.stopFight = function() {
              if (angular.isDefined(stop)) {
                $interval.cancel(stop);
                stop = undefined;
              }
            };

            $scope.OpenPopUpInfo = function(item) {
                $scope.PopUp = {};
                $scope.PopUp.Info = item;
                ngDialog.open({
                    template:  'templatePopUpInfoId',
                    className: 'ngdialog-theme-default InfoPopUp',
                    scope: $scope
                });
            }

            $scope.OpenPopUpResult = function(item) {
                
            }

            $scope.getMergeInfo = function(param) {
                var MergeInfo = MergeService.getMergeFile(param.ItemId);
                console.log('MergeInfo.CONFLICT - '+MergeInfo.CONFLICT);
                console.log('MergeInfo.LastComponentHistoryId - '+MergeInfo.LastComponentHistoryId);
                console.log('MergeInfo.DeployedComponentHistoryId - '+MergeInfo.DeployedComponentHistoryId);
                console.log('MergeInfo.IsIdentical - '+MergeInfo.IsIdentical);

                console.log('MergeInfo.inBranch - '+MergeInfo.inBranch);
                console.log('MergeInfo.Deployed - '+MergeInfo.Deployed);
                console.log('MergeInfo.IsXML - '+MergeInfo.IsXML);
                console.log('MergeInfo.LastComponentHistoryATID - '+MergeInfo.LastComponentHistoryATID);
                console.log('MergeInfo.AttachmentId - '+MergeInfo.AttachmentId);

                /****/
                //MergeInfo.CONFLICT = true;
                /****/
                if (!MergeInfo.CONFLICT && MergeInfo.LastComponentHistoryId != null && (MergeInfo.DeployedComponentHistoryId!= null || MergeInfo.IsIdentical || MergeInfo.IsManualMerge)) {
                    $scope.PopUp = {};
                    var temp = MergeInfo.mergeFile;
                    $scope.PopUp.Info = temp;
                    ngDialog.open({
                        template:  'templatePopUpMergeFileId',
                        className: 'ngdialog-theme-default InfoPopUp',
                        scope: $scope
                    });
                }
                else if (MergeInfo.CONFLICT && MergeInfo.inBranch && MergeInfo.LastComponentHistoryATID != null && MergeInfo.AttachmentId != null && !MergeInfo.IsIdentical) {
                    $scope.PopUp = {};
                    $scope.PopUp.base = MergeInfo.LastFile;
                    if (MergeInfo.IsManualMerge) {
                        $scope.PopUp.newfile = MergeInfo.mergeFile;
                    }
                    else {
                        $scope.PopUp.newfile = MergeInfo.MetaItemFile;
                    }
                    $scope.PopUp.EtalonValue = '';
                    $scope.PopUp.ItemId = MergeInfo.ItemId;
                    $scope.PopUp.ManualMerge = function(xml) {
                        MergeService.setMergeFile(MergeInfo.ItemId, xml);
                        param.IsManualMerge = true;
                        $scope.getStatusConflicts();
                        ngDialog.closeAll();
                    }
                    $scope.PopUp.closeManualMerge = function() {
                        ngDialog.closeAll();
                    }

                    if (MergeInfo.IsXML) {
                      ngDialog.open({
                          template:  'templatePopUpMergeXML',
                          className: 'ngdialog-theme-default MergeXML',
                          scope: $scope
                      });
                    }
                    else {
                      ngDialog.open({
                          template:  'templatePopUpMergeText',
                          className: 'ngdialog-theme-default MergeText',
                          scope: $scope
                      });
                    }
                }
            };
//EncodingUtil.urlDecode(encoded,'UTF-8');
            var searchMatch = function (haystack, needle) {
                if (!needle) {
                    return true;
                }
                return haystack.toLowerCase().indexOf(needle.toLowerCase()) !== -1;
            };
        });

        function listMetadataItems(filterMiliSeconds,IsRetrieveStandard,isProcessSuccessful)
        {
            console.log('filterMiliSeconds----'+filterMiliSeconds);
            console.log('IsRetrieveStandard---'+IsRetrieveStandard);
            console.log('isProcessSuccessful--'+isProcessSuccessful);
            if(isProcessSuccessful)
            {
                intializeFilterLogic();
            
                filterValue = parseInt(filterMiliSeconds);
                retrieveStandardComponent = IsRetrieveStandard;

                angular.element(document.getElementById('angularControllerId')).scope().defaultRetrieveChanges();
            }
            hide();
        }

        function intializeFilterLogic()
        {
            angular.element(document.getElementById('angularControllerId')).scope().applySearch();
            visibleStateConditionStr = '';
            visibleStateMainFilterList = [];
            visibleStateEnableFilterLogic = [];
            visibleStateMainFilterList = angular.element(document.getElementById('angularControllerId')).scope().mainFilterList;
            visibleStateEnableFilterLogic = angular.element(document.getElementById('angularControllerId')).scope().enableFilterLogic;
            console.log('visibleStateEnableFilterLogic--'+visibleStateEnableFilterLogic);
            console.log(visibleStateMainFilterList);
            if(visibleStateEnableFilterLogic)
            {
                visibleStateConditionStr = angular.element(document.getElementById('angularControllerId')).scope().filterCondition;
            }
            else
            {
                for(var index=0; index < visibleStateMainFilterList.length; index++)
                {
                    var filterRow = visibleStateMainFilterList[index];
                    if(filterRow != undefined && filterRow.value != undefined && filterRow.value != '' && filterRow.operator != undefined && filterRow.operator != '')
                    {
                        if(visibleStateConditionStr == '')
                            visibleStateConditionStr += (index+1)+' ';
                        else
                            visibleStateConditionStr += 'AND '+(index+1)+' ';
                    }
                }
            }
            console.log(visibleStateConditionStr);
        }

        function handleSync(tempLogId,exceptionMessage)
        {
            if(tempLogId != undefined && tempLogId != null && tempLogId.length == 18)
            {
                syncId = tempLogId;
                angular.element(document.getElementById('angularControllerId')).scope().startFinalCommit();
            }
            else if(exceptionMessage != undefined && exceptionMessage != '')
            {
                angular.element(document.getElementById('angularControllerId')).scope().showErrorMessage(exceptionMessage);
                angular.element(document.getElementById('angularControllerId')).scope().enableCommitButtonAgain();
            }
        }
        
        //
        /*function createSyncRecord()
        {
            setDefaultMessageOnPage('Please wait...');
            createSyncLog();
        }*/
        
        //Retrieval
        //Function to create retrieval request
        function createRequestForRetrieval(tempLogId,exceptionMessage)
        {
            if(tempLogId != undefined && tempLogId != null && tempLogId.length == 18)
            {
                logId = tempLogId;
                processedFolderMap = {};
                AsyncIdMap = {};
                currentRequestLi = [];
                currentRequestIndex = 0;
                var requestDetailLi = [];
                var largeRequestLi = [];
                var totalCompCount = 0;
                for(var compIndex = 0; compIndex < requestMetaTypeLi.length; compIndex++)
                {
                    var metaType = requestMetaTypeLi[compIndex];
                    var items = filteredMetaItems[metaType];
                    totalCompCount+= items.length
                }
                var defaultRequestCompCount = 0;
                function createRequestFollAll(){
                    if(requestIndex < requestMetaTypeLi.length)
                    {
                        var metaType = requestMetaTypeLi[requestIndex];
                        var items = filteredMetaItems[metaType];
                        console.log(metaType+'(NO:- '+items.length+')');
                        if(totalCompCount > 50 && (metaType == 'StaticResource' || metaType == 'Document' || metaType == 'EmailTemplate' || metaType == 'Profile' || metaType == 'PermissionSet'))
                        {
                            var requestDetail = {};
                            requestDetail.MetaType = metaType;
                            requestDetail.Items = [];
                            requestDetail.ItemNames = [];
                            requestDetail.IsFirst = true;
                            var folderNames = {};
                            var requestCompCount = 0;
                            for(var index=0; index< items.length; index++)
                            {
                                if(requestCompCount >= firstLimit && requestDetail.ItemNames.length > 0)
                                {
                                    for(var folderName in folderNames)
                                    {
                                        requestDetail.ItemNames.push(folderName);
                                    }
                                    largeRequestLi.push(requestDetail);
                                    requestDetail = {};
                                    requestDetail.MetaType = metaType;
                                    requestDetail.Items = items;
                                    requestDetail.ItemNames = [];
                                    requestDetail.IsFirst = true;
                                    folderNames = {};
                                    requestCompCount = 0;
                                }
                                var temoFileName = items[index].fullName;
                                requestDetail.ItemNames.push(temoFileName);
                                requestDetail.Items.push(items[index]);
                                if(typeToFolderMap[metaType] != undefined && temoFileName.indexOf('/') > -1)
                                {
                                    var folderName = temoFileName.slice(0,temoFileName.indexOf('/'));
                                    folderNames[folderName] = folderName;
                                }
                                requestCompCount++;
                            }
                            for(var folderName in folderNames)
                            {
                                requestDetail.ItemNames.push(folderName);
                            }
                            if(requestDetail.ItemNames.length > 0)
                                largeRequestLi.push(requestDetail);
                        }
                        else
                        {
                            var requestDetail = {};
                            requestDetail.MetaType = metaType;
                            requestDetail.Items = [];
                            requestDetail.ItemNames = [];
                            requestDetail.IsFirst = true;
                            var folderNames = {};
                            for(var index=0; index< items.length; index++)
                            {
                                if(defaultRequestCompCount >= firstLimit && defaultRequestCompCount > 0)
                                {
                                    for(var folderName in folderNames)
                                    {
                                        requestDetail.ItemNames.push(folderName);
                                    }
                                    requestDetailLi.push(requestDetail);
                                    currentRequestLi.push(requestDetailLi);
                                    requestDetailLi = [];
                                    requestDetail = {};
                                    requestDetail.MetaType = metaType;
                                    requestDetail.Items = [];
                                    requestDetail.ItemNames = [];
                                    requestDetail.IsFirst = true;
                                    folderNames = {};
                                    defaultRequestCompCount = 0;
                                }
                                var temoFileName = items[index].fullName;
                                requestDetail.ItemNames.push(temoFileName);
                                requestDetail.Items.push(items[index]);
                                if(typeToFolderMap[metaType] != undefined && temoFileName.indexOf('/') > -1)
                                {
                                    var folderName = temoFileName.slice(0,temoFileName.indexOf('/'));
                                    folderNames[folderName] = folderName;
                                }
                                defaultRequestCompCount++;
                            }
                            for(var folderName in folderNames)
                            {
                                requestDetail.ItemNames.push(folderName);
                            }
                            if(requestDetail.ItemNames.length > 0)
                                requestDetailLi.push(requestDetail);
                        }
                        requestIndex++;
                        createRequestFollAll();
                    }
                    else
                    {
                        if(requestDetailLi.length > 0)
                        {
                            currentRequestLi.push(requestDetailLi);
                        }
                        for(var largeIndex=0; largeIndex < largeRequestLi.length; largeIndex++)
                        {
                            requestDetailLi = [];
                            requestDetailLi.push(largeRequestLi[largeIndex]);
                            currentRequestLi.push(requestDetailLi);
                        }
                        console.log('Total '+currentRequestLi.length+' request detail created.');
                        processRequestForRetrieval();
                    }
                }
                createRequestFollAll();
            }
            else if(exceptionMessage != undefined && exceptionMessage != '')
            {
                angular.element(document.getElementById('angularControllerId')).scope().showErrorMessage(exceptionMessage);
            }
        }
        
        function processRequestForRetrieval()
        {
            if(currentRequestIndex < currentRequestLi.length)
            {
                var typesExistInRequest = {};
                var requestDetailLi = currentRequestLi[currentRequestIndex];
                var req = getRetrieveRequest();
                for(var index=0; index <requestDetailLi.length; index++)
                {
                    var requestDetail = requestDetailLi[index];
                    var metaItemsInRequest = [];
                    var oneType = {};
                    oneType.name = requestDetail.MetaType;
                    oneType.members = requestDetail.ItemNames;
                    req.unpackaged.types.push(oneType);
                    typesExistInRequest[requestDetail.MetaType] = requestDetail.MetaType;
                    setDefaultMessageOnPage('Retrieving metadata...');
                }
                if(typesExistInRequest['Profile'] != undefined || typesExistInRequest['PermissionSet'] != undefined)
                {
                    for(var key in permissionMap)
                    {
                        var tempType = {};
                        tempType.name = key;
                        tempType.members = permissionMap[key];
                        req.unpackaged.types.push(tempType);
                    }
                }
                if(typesExistInRequest['CustomObjectTranslation'] != undefined)
                {
                    for(var index = 0; index < customObjectTranslationsInfoSet.length; index++)
                    {
                        var tempType = {};
                        tempType.name = customObjectTranslationsInfoSet[index];
                        tempType.members = ['*'];
                        req.unpackaged.types.push(tempType);
                    }
                }
                if(typesExistInRequest['Translations'] != undefined)
                {
                    for(var index = 0; index < translationsInfoSet.length; index++)
                    {
                        var tempType = {};
                        tempType.name = translationsInfoSet[index];
                        tempType.members = ['*'];
                        req.unpackaged.types.push(tempType);
                    }
                }
                console.log(req);
                selfConn.metadata.retrieve(req,function(err, result){
                    if(err)
                    {
                        console.log('Error while creating retrieval request.');
                        console.log(err);
                        console.log(req);
                        showErrorMessage(JSON.stringify(err));
                    }
                    else
                    {
                        if(result != undefined && result.id != undefined)
                        {
                            AsyncIdMap[result.id] = requestDetailLi;
                        }
                    }
                    currentRequestIndex++;
                    processRequestForRetrieval();
                });
            }
            else
            {
                AsyncIdsLi = [];
                AsyncIdsIndex = 0;
                for(var AsyncId in AsyncIdMap)
                {
                    AsyncIdsLi.push(AsyncId);
                }
                console.log('Total requests created--'+AsyncIdsLi.length);
                if(AsyncIdsLi.length > 0)
                {
                    currentRequestLi = [];
                    console.log(AsyncIdMap);
                    setTimeout(checkRetrievalStatus, 10000);
                }
                else
                {
                    console.log('No request created.');
                }
            }
        }
        
        function checkRetrievalStatus()
        {
            console.log('checkRetrievalStatus()');
            if(AsyncIdsIndex < AsyncIdsLi.length)
            {
                var currentAsyncId = AsyncIdsLi[AsyncIdsIndex];
                var currentAsyncDetailLi = AsyncIdMap[currentAsyncId];
                setDefaultMessageOnPage('Checking retrieval status...');
                console.log('Checking request for retrieval('+(AsyncIdsIndex+1)+'/'+AsyncIdsLi.length+')');
                selfConn.metadata.checkRetrieveStatus(currentAsyncId,function(err,result){
                    if(err) 
                    {
                        console.log('Error in checkRetrieveStatus.');
                        console.log(err);
                        breakRetrievalRequest(currentAsyncId);
                    }
                    else
                    {
                        if(result != undefined && result.id != undefined && AsyncIdMap[result.id] != undefined)
                        {
                            if(result.done == 'true')
                            {
                                if(result.success != 'true')
                                {
                                    console.log('Error in retrieval(result.success).');
                                    console.log(result.errorMessage);
                                    //showErrorMessage(result.errorMessage);
                                    breakRetrievalRequest(currentAsyncId);
                                }
                                else
                                {
                                    var zipStr = result.zipFile;
                                    console.log('Zip file length-'+(zipStr.length/(1024*1024))+' MB');
                                    if(zipStr.length < 2800000)
                                    {
                                        var tempZip = new JSZip(zipStr,{base64:true});
                                        var zipFiles = tempZip.files;
                                        //console.log(zipFiles);
                                        
                                        var tempCRCWrap = {};
                                        tempCRCWrap.fullNames = [];
                                        tempCRCWrap.metaTypes = [];
                                        tempCRCWrap.dataMap = {};
                                        var commitDetailWrap = {};
                                        commitDetailWrap.fullNames = [];
                                        commitDetailWrap.metaTypes = [];
                                        commitDetailWrap.dataMap = {};
                                        var tempFullNamesMap = {};
                                        var tempmetaTypesMap = {};
                                        
                                        for(var tempRequestIndex=0; tempRequestIndex < currentAsyncDetailLi.length; tempRequestIndex++)
                                        {
                                            var currentAsyncDetail = currentAsyncDetailLi[tempRequestIndex];
                                            var currentMetaType = currentAsyncDetail.MetaType;
                                            for(var metaIndex=0; metaIndex < currentAsyncDetail.Items.length; metaIndex++)
                                            {
                                                var meta = currentAsyncDetail.Items[metaIndex];
                                                var compDetail = new Object();
                                                compDetail.fullName = meta.fullName;
                                                compDetail.fileName = meta.fileName;
                                                compDetail.metaType = currentMetaType;
                                                compDetail.crcCode = 0;
                                                compDetail.lastModifiedDate = meta.lastModifiedDate;
                                                compDetail.lastModifiedByName = meta.lastModifiedByName;
                                                compDetail.base64Content;
                                                var fileName = meta.fileName;
                                                var key = currentMetaType+'#'+fileName;
                                                if(mmap[currentMetaType] != undefined)
                                                {
                                                    key = currentMetaType+'#'+meta.fullName;
                                                }
                                                if(bundleTypes[currentMetaType] != undefined)
                                                {
                                                    var fileZip = new JSZip();
                                                    for(var tempFileName in zipFiles)
                                                    {
                                                        if(tempFileName != undefined && tempFileName.indexOf(fileName+'/') == 0)
                                                        {
                                                            var bundleData = getCrcWithData(zipFiles[tempFileName].asBinary());
                                                            fileZip.file(tempFileName,bundleData.data,{binary:true});
                                                            compDetail.crcCode += bundleData.crc32;
                                                        }
                                                    }
                                                    if(compDetail.crcCode != 0)
                                                    {
                                                        compDetail.base64Content = fileZip.generate({type:"base64",compression:"DEFLATE"});
                                                    }
                                                }
                                                else if(zipFiles[fileName] != undefined)
                                                {
                                                    if(currentMetaType == 'Profile' || currentMetaType == 'PermissionSet')
                                                    {
                                                        var fileData = getCrcWithData(zipFiles[fileName].asText());
                                                        compDetail.crcCode = fileData.crc32;
                                                        var fileZip = new JSZip();
                                                        fileZip.file(fileName,fileData.data,{binary:true});
                                                        compDetail.base64Content = fileZip.generate({type:"base64",compression:"DEFLATE"});
                                                    }
                                                    else if(mmap[currentMetaType] == undefined)
                                                    {
                                                        var fileData = getCrcWithData(zipFiles[fileName].asBinary());
                                                        compDetail.crcCode = fileData.crc32;
                                                        var fileZip = new JSZip();
                                                        fileZip.file(fileName,fileData.data,{binary:true});
                                                        var metaXmlData = zipFiles[fileName+"-meta.xml"];
                                                        if(metaXmlData != undefined)
                                                        {
                                                            var tempXMLData = getCrcWithData(metaXmlData.asBinary());
                                                            compDetail.crcCode = compDetail.crcCode+' '+tempXMLData.crc32;
                                                            fileZip.file(fileName+"-meta.xml",tempXMLData.data,{binary:true});
                                                        }
                                                        compDetail.base64Content = fileZip.generate({type:"base64",compression:"DEFLATE"});
                                                    }
                                                    else
                                                    {
                                                        var fileData = zipFiles[fileName].asText();
                                                        var childDataMap = getChildFileMap(currentMetaType,zipFiles[fileName].asText(),fileName);
                                                        if(childDataMap[key] != undefined)
                                                        {
                                                            var childCompData = childDataMap[key];
                                                            var fileZip = new JSZip();
                                                            fileZip.file(fileName,childCompData.data,{binary:true});
                                                            compDetail.crcCode = childCompData.crc32;
                                                            compDetail.base64Content = fileZip.generate({type:"base64",compression:"DEFLATE"});
                                                        }
                                                    }
                                                }
                                                if(compDetail.crcCode != 0)
                                                {
                                                    
                                                    tempFullNamesMap[compDetail.fullName] = compDetail.fullName;
                                                    tempmetaTypesMap[compDetail.metaType] = compDetail.metaType;
                                                    commitDetailWrap.dataMap[compDetail.metaType+'#'+compDetail.fullName] = compDetail;
                                                    var crcDetail = {};
                                                    crcDetail.crcCode = compDetail.crcCode;
                                                    crcDetail.metaType = compDetail.metaType;
                                                    crcDetail.fullName = compDetail.fullName;
                                                    tempCRCWrap.dataMap[compDetail.metaType+'#'+compDetail.fullName] = crcDetail;
                                                }
                                            }
                                            if(typeToFolderMap[currentMetaType] != undefined && filteredMetaItems[typeToFolderMap[currentMetaType]] != undefined)
                                            {
                                                 var folderMetadataItems = filteredMetaItems[typeToFolderMap[currentMetaType]];
                                                 for(var metaIndex=0; metaIndex < folderMetadataItems.length; metaIndex++)
                                                 {
                                                     var meta = folderMetadataItems[metaIndex];
                                                     var compDetail = new Object();
                                                     compDetail.fullName = meta.fullName;
                                                     compDetail.fileName = meta.fileName;
                                                     compDetail.metaType = typeToFolderMap[currentMetaType];
                                                     compDetail.crcCode = 0;
                                                     compDetail.lastModifiedDate = meta.lastModifiedDate;
                                                     compDetail.lastModifiedByName = meta.lastModifiedByName;
                                                     compDetail.base64Content;
                                                     var fileName = meta.fileName;
                                                     var key = currentMetaType+'#'+meta.fileName;
                                                     if(processedFolderMap[key] == undefined)
                                                     {
                                                         if(zipFiles[fileName] != undefined)
                                                         {
                                                            var fileData = getCrcWithData(zipFiles[fileName].asBinary());
                                                            compDetail.crcCode = fileData.crc32;
                                                            var fileZip = new JSZip();
                                                            fileZip.file(fileName,fileData.data,{binary:true});
                                                            compDetail.base64Content = fileZip.generate({type:"base64",compression:"DEFLATE"});
                                                         }
                                                         if(compDetail.crcCode != 0)
                                                         {
                                                             tempFullNamesMap[compDetail.fullName] = compDetail.fullName;
                                                             tempmetaTypesMap[compDetail.metaType] = compDetail.metaType;
                                                             commitDetailWrap.dataMap[compDetail.metaType+'#'+compDetail.fullName] = compDetail;
                                                             var crcDetail = {};
                                                             crcDetail.crcCode = compDetail.crcCode;
                                                             crcDetail.metaType = compDetail.metaType;
                                                             crcDetail.fullName = compDetail.fullName;
                                                             tempCRCWrap.dataMap[compDetail.metaType+'#'+compDetail.fullName] = crcDetail;
                                                             processedFolderMap[key] = key;
                                                         }
                                                     }
                                                 }
                                            }
                                        }
                                        if(!isMapEmpty(commitDetailWrap.dataMap))
                                        {
                                            for(var uniqueName in tempFullNamesMap)
                                            {
                                                commitDetailWrap.fullNames.push(uniqueName);
                                                tempCRCWrap.fullNames.push(uniqueName);
                                            }
                                            for(var uniqueName in tempmetaTypesMap)
                                            {
                                                commitDetailWrap.metaTypes.push(uniqueName);
                                                tempCRCWrap.metaTypes.push(uniqueName);
                                            }
                                            //console.log(tempCRCWrap);
                                            var jsonStr = JSON.stringify(tempCRCWrap);
                                            console.log('JSON string length-'+(jsonStr.length/(1024*1024))+' MB');
                                            function checkQuickCrc(){
                                                Visualforce.remoting.Manager.invokeAction(
                                                '{!$RemoteAction.FL_LocalWorkspaceController.checkCrcCodeFromFlosum}',jsonStr,
                                                function(r, e){
                                                    if(e.status) 
                                                    {
                                                        if(r.notToCommit != undefined && r.safeToCommit != undefined && (r.notToCommit.length > 0 || r.safeToCommit.length > 0 ))
                                                        {
                                                            for(var index=0; index < r.notToCommit.length; index++)
                                                            {
                                                                var detail = r.notToCommit[index];
                                                                if(detail != undefined && detail.compType != undefined && detail.compName != undefined)
                                                                {
                                                                    var keyComp = detail.compType+'#'+detail.compName;
                                                                    if(commitDetailWrap.dataMap[keyComp] != undefined)
                                                                    {
                                                                        commitDetailWrap.dataMap[keyComp].reason = detail.reason;
                                                                        commitDetailWrap.dataMap[keyComp].version = detail.version;
                                                                        delete commitDetailWrap.dataMap[keyComp].base64Content;
                                                                    }
                                                                }
                                                            }
                                                            console.log(commitDetailWrap);
                                                            var base64JsonStr = JSON.stringify(commitDetailWrap);
                                                            createTempRecordsForCommit(base64JsonStr);
                                                        }
                                                        else
                                                        {
                                                            cotinueCheckRetrievalStatus();
                                                        }
                                                    }
                                                    else
                                                    {
                                                        angular.element(document.getElementById('angularControllerId')).scope().showErrorMessage(e.message);
                                                    }
                                                });
                                            }
                                            checkQuickCrc();
                                        }
                                        else
                                        {
                                            console.log('No item found.');
                                            cotinueCheckRetrievalStatus();
                                        }
                                    }
                                    else
                                    {
                                        breakRetrievalRequest(currentAsyncId);
                                    }
                                }
                            }
                            else
                            {
                                console.log('Creating file on server.');
                                RemainingAsyncIdLi.push(currentAsyncId);
                                cotinueCheckRetrievalStatus();
                            }
                        }
                    }
                });
            }
            else
            {
                AsyncIdsLi = [];
                AsyncIdsIndex = 0;
                if(RemainingAsyncIdLi.length > 0)
                {
                    for(var index=0; index < RemainingAsyncIdLi.length; index++ )
                    {
                        AsyncIdsLi.push(RemainingAsyncIdLi[index]);
                    }
                    RemainingAsyncIdLi = [];
                }
                if(AsyncIdsLi.length > 0)
                {
                    AsyncIdsIndex = -1;
                    var remainingTime = 10;
                    var timeCounter = function(){
                          if(remainingTime > 0)
                          {
                              setDefaultMessageOnPage("Retrieval status check is scheduled after "+remainingTime+" seconds.");
                              remainingTime--;
                              setTimeout(timeCounter, 1000);
                          }
                          else
                          {
                              cotinueCheckRetrievalStatus();
                          }
                    }
                    timeCounter();
                }
                else if(currentRequestLi.length > 0)
                {
                    currentRequestIndex = 0;
                    AsyncIdMap = {};
                    setTimeout(processRequestForRetrieval, 005);
                }
                else
                {
                    nextTypeForRetrieval();
                }
            }
        }
        
        function isMapEmpty(tempMap)
        {
            for(key in tempMap)
            {
                return false;
            }
            return true;
        }
        
        function nextTypeForRetrieval()
        {
            console.log('nextTypeForRetrieval()');
            requestIndex++;
            //createRequestForRetrieval(logId,'');
            angular.element(document.getElementById('angularControllerId')).scope().finishRetrieval();
        }
        
        function breakRetrievalRequest(currentAsyncId)
        {
            //console.log('breakRetrievalRequest');
            if(AsyncIdMap[currentAsyncId] != undefined)
            {
                var currentAsyncDetailLi = AsyncIdMap[currentAsyncId];
                //console.log('Pre Request');
                //console.log(currentAsyncDetailLi);
                //console.log('-------------------');
                if(currentAsyncDetailLi.length > 1)
                {
                    for(var index=0; index< currentAsyncDetailLi.length; index++)
                    {
                        var currentAsyncDetail = currentAsyncDetailLi[index];
                        var requestDetailLi = [];
                        requestDetailLi.push(currentAsyncDetail);
                        //console.log(requestDetailLi);
                        currentRequestLi.push(requestDetailLi);
                    }
                }
                else if(currentAsyncDetailLi.length == 1)
                {
                    var currentAsyncDetail = currentAsyncDetailLi[0];
                    var currentMetaType = currentAsyncDetail.MetaType;
                    var items = currentAsyncDetail.Items;
                    if(items.length > 1)
                    {
                        var oneTypeMetaItems = [];
                        var localLimit = Math.floor(items.length *.50);
                        for(var index=0; index< items.length; index++)
                        {
                            if(index != 0 && index % localLimit == 0)
                            {
                                var requestDetail = {};
                                requestDetail.MetaType = currentMetaType;
                                requestDetail.Items = oneTypeMetaItems;
                                requestDetail.ItemNames = [];
                                requestDetail.IsFirst = false;
                                var folderNameMap = {};
                                for(var tempIndex in oneTypeMetaItems)
                                {
                                    if(tempIndex < oneTypeMetaItems.length)
                                    {
                                        var temoFileName = oneTypeMetaItems[tempIndex].fullName;
                                        requestDetail.ItemNames.push(temoFileName);
                                        if(typeToFolderMap[currentMetaType] != undefined && temoFileName.indexOf('/') > -1)
                                        {
                                            var folderName = temoFileName.slice(0,temoFileName.indexOf('/'));
                                            folderNameMap[folderName] = folderName;
                                        }
                                    }
                                }
                                for(var folderName in folderNameMap)
                                {
                                    requestDetail.ItemNames.push(folderName);
                                }
                                var requestDetailLi = [];
                                requestDetailLi.push(requestDetail);
                                //console.log(requestDetailLi);
                                currentRequestLi.push(requestDetailLi);
                                oneTypeMetaItems = [];
                            }
                            oneTypeMetaItems.push(items[index]);
                        }
                        if(oneTypeMetaItems.length > 0)
                        {
                            var requestDetail = {};
                            requestDetail.MetaType = currentMetaType;
                            requestDetail.Items = oneTypeMetaItems;
                            requestDetail.ItemNames = [];
                            requestDetail.IsFirst = true;
                            var folderNameMap = {};
                            for(var tempIndex in oneTypeMetaItems)
                            {
                                if(tempIndex < oneTypeMetaItems.length)
                                {
                                    var temoFileName = oneTypeMetaItems[tempIndex].fullName;
                                    requestDetail.ItemNames.push(temoFileName);
                                    if(typeToFolderMap[currentMetaType] != undefined && temoFileName.indexOf('/') > -1)
                                    {
                                        var folderName = temoFileName.slice(0,temoFileName.indexOf('/'));
                                        folderNameMap[folderName] = folderName;
                                    }
                                }
                            }
                            for(var folderName in folderNameMap)
                            {
                                requestDetail.ItemNames.push(folderName);
                            }
                            var requestDetailLi = [];
                            requestDetailLi.push(requestDetail);
                            //console.log(requestDetailLi);
                            currentRequestLi.push(requestDetailLi);
                        }
                    }
                }
            }
            //console.log('---after break----');
            cotinueCheckRetrievalStatus();
        }
        
        function checkExceptionOnComplete(tempLogId,exceptionMessage)
        {
            console.log('tempLogId-----------'+tempLogId);
            console.log('exceptionMessage----'+exceptionMessage);
            if(tempLogId != undefined && tempLogId != null && tempLogId.length == 18)
            {
                cotinueCheckRetrievalStatus();
            }
            else
            {
                angular.element(document.getElementById('angularControllerId')).scope().showErrorMessage(exceptionMessage);
            }
        }
        
        function cotinueCheckRetrievalStatus()
        {
            AsyncIdsIndex++;
            setTimeout(checkRetrievalStatus, 0005);
        }
        
        function getRetrieveRequest()
        {
            var retrieveRequest = new Object();
            retrieveRequest.apiVersion = apiVersion;
            retrieveRequest.singlePackage = true;
            retrieveRequest.unpackaged = {};
            retrieveRequest.unpackaged.types = [];
            return retrieveRequest;
        }
         
        //Create Connection
        function createSelfConnection()
        {
            var conn = new flosumsf.Connection({ accessToken: '{!$Api.Session_Id}' });
            conn.metadata.pollTimeout = 12000000;
            conn.metadata.pollInterval = 4000;
            return conn;
        }
        
        //Qyery Components
        function listComponents()
        {   
            remainingTypesMap = {};
            filteredMetaItems = {};
            var selectedTypes = [];
            var filterLogic = angular.element(document.getElementById('angularControllerId')).scope().enableFilterLogic;
            var localFilterList = [];
            var tempFilterList = angular.element(document.getElementById('angularControllerId')).scope().filterList;
            for(var index=0; index < tempFilterList.length; index++)
            {
                var filterRow = tempFilterList[index];
                if(filterRow != undefined && filterRow.field == 'type' && filterRow.value != undefined && filterRow.value != '' && filterRow.operator != undefined && filterRow.operator != '')
                {
                    localFilterList.push(filterRow);
                }
            }
            var angMetaTypeLi = angular.element(document.getElementById('angularControllerId')).scope().metaTypeLi;
            for(var index=0; index < angMetaTypeLi.length; index++)
            {
                var metaType = angMetaTypeLi[index];
                if(metaType != undefined && metaType != '' )
                {
                    if(filterLogic)
                    {
                        selectedTypes.push(metaType);
                    }
                    else
                    {
                        var finalResult = true;
                        for(var index2=0; index2 < localFilterList.length; index2++)
                        {
                            var filterRow = localFilterList[index2];
                            var filterVal = filterRow.value.toLowerCase();
                            if(filterVal == 'all' && filterRow.operator == 'equals')
                            {}
                            else
                            {
                                finalResult = checkValidCondition(metaType.toLowerCase(),filterVal,filterRow.operator,'type');
                                if(!finalResult)
                                    break;
                            }
                        }
                        if(finalResult)
                            selectedTypes.push(metaType);
                    }
                }
            }
            //selectedTypes =  angular.element(document.getElementById('angularControllerId')).scope().selectedOptions;
            console.log(selectedTypes);
            //var selectedTypes = ['ApexClass','ApexPage','CustomObject','ApexComponent','Layout','CustomObjectTranslation'];
            if(selectedTypes != undefined && selectedTypes.length > 0) 
            {
                setDefaultMessageOnPage('Retrieving Changes...');
                var metaLi = selectedTypes;
                if(metaLi.length > 0)
                {
                    var queryIndex = 0;
                    var queryMetadataTypesOneByOne = function(){
                        if(queryIndex < metaLi.length)
                        {
                            var metaType = metaLi[queryIndex];
                            if(differentRetrievalMap[metaType] != undefined)
                            {
                                remainingTypesMap[metaType] = metaType;
                                queryIndex++;
                                queryMetadataTypesOneByOne();
                            }
                            else
                            {
                                console.log('Query---'+metaType);
                                setDefaultMessageOnPage('Retrieving Changes for '+metaType+'...');
                                var queryLi = [];
                                var query = new Object();
                                query.folder = '';
                                query.type = metaType;
                                queryLi.push(query);
                                //setMessageOnPage("Finding out components changed for "+metaTypesLi[queryIndex]+".");
                                selfConn.metadata.list(queryLi, ''+apiVersion, function(err, result){
                                    if(err)
                                    {
                                        console.log(err);
                                    }
                                    else
                                    {
                                        var metaItemLi = [];
                                        var uniqueMetaItemMap = {};
                                        if(Array.isArray(result))
                                        {
                                            for(var index in result)
                                            {
                                                if(index < result.length)
                                                {
                                                    var meta = result[index];
                                                    if(meta != undefined && meta.lastModifiedDate != undefined)
                                                    {
                                                        var metaLastModifiedDate = new Date(meta.lastModifiedDate).getTime();
                                                        if(manageableStateToRetrieve[meta.manageableState] != undefined && (filterValue == 0 || metaLastModifiedDate > filterValue || (metaLastModifiedDate == 0 && retrieveStandardComponent)))
                                                        {
                                                            
                                                            if(meta.fileName != null && meta.fileName != undefined ) 
                                                            {
                                                                if(meta.type == 'ManagedTopics')
                                                                {
                                                                    if(meta.fileName.indexOf('ManagedTopics/') == 0)
                                                                        meta.fileName = meta.fileName.replace('ManagedTopics/','managedTopics/');
                                                                    meta.fileName = decodeURI(meta.fileName);
                                                                }
                                                                else if(meta.type == 'Workflow' && meta.fileName.indexOf('Workflow/') == 0)
                                                                {
                                                                    meta.fileName = meta.fileName.replace('Workflow/','workflows/');
                                                                }
                                                                else if(meta.type == 'MatchingRules' && meta.fileName.indexOf('MatchingRules/') == 0)
                                                                {
                                                                    meta.fileName = meta.fileName.replace('MatchingRules/','matchingRules/');
                                                                }
                                                                else if(meta.type == 'SynonymDictionary' && meta.fullname == '_Default')
                                                                {
                                                                    meta.fileName = 'synonymDictionaries/_Default.synonymDictionary';
                                                                }                                
                                                            }
                                                            if(!uniqueMetaItemMap[meta.fullname] != undefined&& getVisibileState(meta))
                                                            {
                                                                metaItemLi.push(meta);
                                                                uniqueMetaItemMap[meta.fullname] = meta.fullname;
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                        else
                                        {
                                            var meta = result;
                                            if(meta != undefined && meta.lastModifiedDate != undefined)
                                            {
                                                var metaLastModifiedDate = new Date(meta.lastModifiedDate).getTime();
                                                if(manageableStateToRetrieve[meta.manageableState] != undefined && (filterValue == 0 || metaLastModifiedDate > filterValue || (metaLastModifiedDate == 0 && retrieveStandardComponent)))
                                                {
                                                    if(getVisibileState(meta))
                                                        metaItemLi.push(meta);
                                                }
                                            }
                                        }
                                        if(metaItemLi.length > 0)
                                            filteredMetaItems[metaType] = metaItemLi;
                                    }
                                    queryIndex++;
                                    queryMetadataTypesOneByOne();
                                });
                            }
                        }
                        else
                        {
                            listPermissionItems();
                        }
                    }
                    queryMetadataTypesOneByOne();
                }
            }
            else
            {
                angular.element(document.getElementById('angularControllerId')).scope().disableRetrieveChangesButton = false;
                angular.element(document.getElementById('angularControllerId')).scope().showErrorMessage('Please select a component type.');
            }
        }
        
        function listPermissionItems()
        {
            if(filteredMetaItems['Profile'] != undefined || filteredMetaItems['PermissionSet'] != undefined)
            {
                var queryLi = [];
                var query = new Object();
                query.folder = '';
                query.type = 'CustomObject';
                queryLi.push(query);
                selfConn.metadata.list(queryLi, ''+apiVersion, function(err, result){
                    if(err)
                    {
                        console.log(err);
                    }
                    else
                    {
                        var tempLi = [];
                        if(Array.isArray(result))
                        {
                            for(var index in result)
                            {
                                if(index < result.length)
                                {
                                    var meta = result[index];
                                    if(meta != undefined && meta.fullName != undefined)
                                    {
                                        tempLi.push(meta.fullName);
                                    }
                                }
                            }
                        }
                        else
                        {
                            var meta = result;
                            if(meta != undefined && meta.fullName != undefined)
                            {
                                tempLi.push(meta.fullName);
                            }
                        }
                        if(tempLi.length > 0)
                            permissionMap['CustomObject'] = tempLi;
                    }
                    flowQuery();
               });
            }
            else
            {
                flowQuery();
            }
        }
        
        function flowQuery()
        {
            if(remainingTypesMap['Flow'] != undefined)
            {
                console.log('Query---Flow');
                setDefaultMessageOnPage('Retrieving Changes for Flow...');
                var queryLi = [];
                var query = new Object();
                query.folder = '';
                query.type = 'Flow';
                queryLi.push(query);
                selfConn.metadata.list(queryLi, ''+apiVersion, function(err, result){
                    if(err)
                    {
                        console.log(err);
                    }
                    else
                    {
                        var tempLi = [];
                        if(Array.isArray(result))
                        {
                            for(var index in result)
                            {
                                if(index < result.length)
                                {
                                    var meta = result[index];
                                    if(meta != undefined && meta.lastModifiedDate != undefined)
                                    {
                                        var metaLastModifiedDate = new Date(meta.lastModifiedDate).getTime();
                                        if(manageableStateToRetrieve[meta.manageableState] != undefined && (filterValue == 0 || metaLastModifiedDate > filterValue || (metaLastModifiedDate == 0 && retrieveStandardComponent)))
                                        {
                                            tempLi.push(meta);
                                        }
                                    }
                                }
                            }
                        }
                        else
                        {
                            var meta = result;
                            if(meta != undefined && meta.lastModifiedDate != undefined)
                            {
                                var metaLastModifiedDate = new Date(meta.lastModifiedDate).getTime();
                                if(manageableStateToRetrieve[meta.manageableState] != undefined && (filterValue == 0 || metaLastModifiedDate > filterValue || (metaLastModifiedDate == 0 && retrieveStandardComponent)))
                                {

                                    tempLi.push(meta);
                                }
                            }
                        }
                        if(tempLi.length > 0)
                        {
                            var metaItemLi = [];
                            var toolingIndex = 0;
                            function queryByToolingOneByOne(){
                                if(toolingIndex < tempLi.length)
                                {
                                    var meta = tempLi[toolingIndex];
                                    selfConn.tooling.sobject('Flow').find({'Id':meta.id}).execute(function(err, records) {
                                        if(err) 
                                        {
                                            return console.error(err); 
                                        }
                                        else
                                        {
                                            if(records.length > 0 && records[0].FullName != undefined)
                                            {
                                                meta.fullName = records[0].FullName;
                                                meta.fileName = 'flows/'+meta.fullName+'.flow';
                                                if(getVisibileState(meta))
                                                    metaItemLi.push(meta);
                                            }
                                        }
                                        toolingIndex++;
                                        queryByToolingOneByOne();
                                    });
                                }
                                else
                                {
                                    if(metaItemLi.length > 0)
                                    {
                                        filteredMetaItems['Flow'] = metaItemLi;
                                    }
                                    customFieldQuery();
                                }
                            }
                            queryByToolingOneByOne();
                        }
                        else
                        {
                            customFieldQuery();
                        }
                    }
                });
            }
            else
            {
                customFieldQuery();
            }
        }
        
        function customFieldQuery()
        {
            if(remainingTypesMap['CustomField'] != undefined || remainingTypesMap['SharingOwnerRule'] != undefined || remainingTypesMap['SharingCriteriaRule'] != undefined)
            {
                var logStr = '';
                for(var key in remainingTypesMap)
                {
                    if(key == 'CustomField' || key == 'SharingOwnerRule' || key == 'SharingCriteriaRule')
                    {
                        logStr = logStr == '' ? key : logStr+','+key;
                    }
                }
                console.log('Query---'+logStr);
                setDefaultMessageOnPage('Retrieving Changes for '+logStr+'...');
                var queryLi = [];
                var query = new Object();
                query.folder = '';
                query.type = 'CustomObject';
                queryLi.push(query);
                selfConn.metadata.list(queryLi, ''+apiVersion, function(err, result){
                    if(err)
                    {
                        return console.log(err);
                    }
                    else
                    {
                        if(result != undefined && result.length > 0)
                        {
                            var childTypeMetaMap = {};
                            var filterDuplicateSharingItems = {};
                            var queryChildIndex = 0;
                            function queryChildsOneByOne(){
                                if(queryChildIndex < result.length)
                                {
                                    var folder = result[queryChildIndex].fullName;
                                    var query2Li = [];
                                    for(var key in remainingTypesMap)
                                    {
                                        if(key == 'CustomField' || key == 'SharingOwnerRule' || key == 'SharingCriteriaRule')
                                        {
                                            var query2 = new Object();
                                            query2.folder = folder;
                                            query2.type = key;
                                            query2Li.push(query2);
                                        }
                                    }
                                    selfConn.metadata.list(query2Li, ''+apiVersion, function(err, result2){
                                        if(err)
                                        {
                                            return console.log(err);
                                        }
                                        else
                                        {
                                            if(Array.isArray(result2))
                                            {
                                                for(var index in result2)
                                                {
                                                    if(index < result2.length)
                                                    {
                                                        var meta = result2[index];
                                                        if(meta != undefined && meta.lastModifiedDate != undefined && meta.fullName != undefined)
                                                        {
                                                            var metaLastModifiedDate = new Date(meta.lastModifiedDate).getTime();
                                                            if(manageableStateToRetrieve[meta.manageableState] != undefined && (filterValue == 0 || metaLastModifiedDate > filterValue || (metaLastModifiedDate == 0 && retrieveStandardComponent)))
                                                            {
                                                                if(meta.type == 'CustomField')
                                                                {
                                                                    if((!meta.fullName.endsWith('__c')) && (!meta.fullName.indexOf(folder +'.') == 0))
                                                                    {
                                                                        meta.fileName = 'objects/'+ folder +'.object';
                                                                        meta.fullName = folder +'.'+ meta.fullName;
                                                                    }
                                                                }
                                                                if(getVisibileState(meta))
                                                                {
                                                                    var childLi = [];
                                                                    if(childTypeMetaMap[meta.type] != undefined)
                                                                    {
                                                                        childLi = childTypeMetaMap[meta.type];
                                                                    }
                                                                    if(filterDuplicateSharingItems[meta.type+'#'+meta.fullName] == undefined)
                                                                    {
                                                                        childLi.push(meta);
                                                                        childTypeMetaMap[meta.type] = childLi;
                                                                        filterDuplicateSharingItems[meta.type+'#'+meta.fullName] = meta.type+'#'+meta.fullName;
                                                                    }
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                            else
                                            {
                                                var meta = result2;
                                                if(meta != undefined && meta.lastModifiedDate != undefined)
                                                {
                                                    var metaLastModifiedDate = new Date(meta.lastModifiedDate).getTime();
                                                    if(manageableStateToRetrieve[meta.manageableState] != undefined && (filterValue == 0 || metaLastModifiedDate > filterValue || (metaLastModifiedDate == 0 && retrieveStandardComponent)))
                                                    {
                                                        if(meta.type == 'CustomField')
                                                        {
                                                            if(!meta.fullName.endsWith('__c') && !meta.fullName.indexOf(folder +'.') == 0)
                                                            {
                                                                meta.fileName = 'objects/'+ folder +'.object';
                                                                meta.fullName = folder +'.'+ meta.fullName;
                                                            }
                                                        }
                                                        if(getVisibileState(meta))
                                                        {
                                                            var childLi = [];
                                                            if(childTypeMetaMap[meta.type] != undefined)
                                                            {
                                                                childLi = childTypeMetaMap[meta.type];
                                                            }
                                                            if(filterDuplicateSharingItems[meta.type+'#'+meta.fullName] == undefined)
                                                            {
                                                                childLi.push(meta);
                                                                childTypeMetaMap[meta.type] = childLi;
                                                                filterDuplicateSharingItems[meta.type+'#'+meta.fullName] = meta.type+'#'+meta.fullName;
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                            queryChildIndex++;
                                            queryChildsOneByOne();
                                        }
                                    });
                                }
                                else
                                {
                                    for(var key in childTypeMetaMap)
                                    {
                                        filteredMetaItems[key] = childTypeMetaMap[key];
                                    }
                                    folderQuery();
                                }
                            }
                            queryChildsOneByOne();
                        }
                    }
                });
            }
            else
            {
                folderQuery();
            }
        }
        
        function folderQuery()
        {
            if(remainingTypesMap['Document'] != undefined || remainingTypesMap['Dashboard'] != undefined || remainingTypesMap['Report'] != undefined || remainingTypesMap['EmailTemplate'] != undefined)
            {
                var folderQueryLi = [];
                var folder = '';
                for(var key in remainingTypesMap)
                {
                    if(key == 'Document' || key == 'Dashboard' || key == 'Report' || key == 'EmailTemplate')
                    {
                        setDefaultMessageOnPage('Retrieving Changes for '+key+'...');
                        var query2 = new Object();
                        query2.folder = folder;
                        query2.type = typeToFolderMap[key];
                        folderQueryLi.push(query2);
                        console.log('Query---'+key);
                    }
                }
                var folderQueryIndex = 0;
                var queryFolderOneByOne = function(){
                    if(folderQueryIndex < folderQueryLi.length)
                    {
                        var queryLi = [];
                        var query = folderQueryLi[folderQueryIndex];
                        queryLi.push(query);
                        selfConn.metadata.list(queryLi, ''+apiVersion, function(err, result){
                            if(err)
                            {
                                console.log(err);
                            }
                            else
                            {
                                var tempLi = [];
                                if(Array.isArray(result))
                                {
                                    for(var index in result)
                                    {
                                        if(index < result.length)
                                        {
                                            var meta = result[index];
                                            if(meta != undefined && meta.lastModifiedDate != undefined)
                                            {
                                                /*var metaLastModifiedDate = new Date(meta.lastModifiedDate).getTime();
                                                if(manageableStateToRetrieve[meta.manageableState] != undefined && (filterValue == 0 || metaLastModifiedDate > filterValue || (metaLastModifiedDate == 0 && retrieveStandardComponent)))
                                                {*/
                                                    meta.fileName = meta.fileName+'-meta.xml';
                                                    tempLi.push(meta);
                                                //}
                                            }
                                        }
                                    }
                                }
                                else
                                {
                                    var meta = result;
                                    if(meta != undefined && meta.lastModifiedDate != undefined)
                                    {
                                        /*var metaLastModifiedDate = new Date(meta.lastModifiedDate).getTime();
                                        if(manageableStateToRetrieve[meta.manageableState] != undefined && (filterValue == 0 || metaLastModifiedDate > filterValue || (metaLastModifiedDate == 0 && retrieveStandardComponent)))
                                        {*/
                                            meta.fileName = meta.fileName+'-meta.xml';
                                            tempLi.push(meta);
                                        //}
                                    }
                                }
                                if(tempLi.length > 0)
                                {
                                    var folderTempLi = [];
                                    for(var metaindex = 0; metaindex < tempLi.length; metaindex++)
                                    {
                                        var meta = tempLi[metaindex];
                                        var metaLastModifiedDate = new Date(meta.lastModifiedDate).getTime();
                                        if(manageableStateToRetrieve[meta.manageableState] != undefined && (filterValue == 0 || metaLastModifiedDate > filterValue || (metaLastModifiedDate == 0 && retrieveStandardComponent)))
                                        {
                                            if(getVisibileState(meta))
                                                folderTempLi.push(meta);
                                        }
                                    }
                                    if(folderTempLi.length > 0)
                                        filteredMetaItems[query.type]= folderTempLi;
                                }
                                
                                var queryChildIndex = 0;
                                var folderItems = [];
                                var queryChildOfFolderOneByOne = function(){
                                    if(queryChildIndex < tempLi.length)
                                    {
                                        var childQueryLi =  [];
                                        for(var childIndex = 0; childIndex < 3 && queryChildIndex < tempLi.length; childIndex++)
                                        {
                                            var query2 = new Object();
                                            query2.folder = tempLi[queryChildIndex].fullName;
                                            query2.type = folderToTypeMap[query.type];
                                            childQueryLi.push(query2);
                                            queryChildIndex++;
                                        }
                                        selfConn.metadata.list(childQueryLi, ''+apiVersion, function(err, result){
                                            if(err)
                                            {
                                                console.log(err);
                                            }
                                            else
                                            {
                                                if(Array.isArray(result))
                                                {
                                                    for(var index in result)
                                                    {
                                                        if(index < result.length)
                                                        {
                                                            var meta = result[index];
                                                            if(meta != undefined && meta.lastModifiedDate != undefined)
                                                            {
                                                                var metaLastModifiedDate = new Date(meta.lastModifiedDate).getTime();
                                                                if(manageableStateToRetrieve[meta.manageableState] != undefined && (filterValue == 0 || metaLastModifiedDate > filterValue || (metaLastModifiedDate == 0 && retrieveStandardComponent)))
                                                                {
                                                                    if(getVisibileState(meta))
                                                                        folderItems.push(meta);
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                                else
                                                {
                                                    var meta = result;
                                                    if(meta != undefined && meta.lastModifiedDate != undefined)
                                                    {
                                                        var metaLastModifiedDate = new Date(meta.lastModifiedDate).getTime();
                                                        if(manageableStateToRetrieve[meta.manageableState] != undefined && (filterValue == 0 || metaLastModifiedDate > filterValue || (metaLastModifiedDate == 0 && retrieveStandardComponent)))
                                                        {
                                                            if(getVisibileState(meta))
                                                                folderItems.push(meta);
                                                        }
                                                    }
                                                }
                                                queryChildOfFolderOneByOne();    
                                            }
                                        });
                                    }
                                    else
                                    {
                                        if(folderItems.length > 0)
                                        {
                                            filteredMetaItems[folderToTypeMap[query.type]]= folderItems;
                                        }
                                                
                                        folderQueryIndex++;
                                        queryFolderOneByOne();
                                    }
                                }
                                queryChildOfFolderOneByOne();
                            }
                        });
                    }
                    else
                    {
                        //Done
                        angular.element(document.getElementById('angularControllerId')).scope().createListOnFinishOfQuery();
                    }
                }
                queryFolderOneByOne();  
            }
            else
            {
                //Done
                angular.element(document.getElementById('angularControllerId')).scope().createListOnFinishOfQuery();
            }
        }
        
        function getChildFileMap(metaType,xml,fileName)
        {
            var childFileMap = {};
            var fullName = '';
            if(metaType != 'CustomLabel')
            {
                fullName = fileName.slice(fileName.indexOf("/")+1,fileName.lastIndexOf('.'))+".";
            }
    
            var x2js = new X2JS();
            var jsnMap ={};
            var tempJSON = '';
            var srcjson = x2js.xml_str2json(xml);
            if(srcjson != undefined && srcjson != null)
            {
                var srcitems;
                if(metaType == 'CustomLabel')
                {
                    var srcMetaItem = srcjson.CustomLabels;
                    srcitems = srcMetaItem.labels;
                }
                else if(metaType == 'CustomField')
                {
                    var srcMetaItem = srcjson.CustomObject;
                    srcitems = srcMetaItem.fields;
                }
                else if(metaType == 'ListView')
                {
                    var srcMetaItem = srcjson.CustomObject;
                    srcitems = srcMetaItem.listViews;
                }
                else if(metaType == 'CompactLayout')
                {
                    var srcMetaItem = srcjson.CustomObject;
                    srcitems = srcMetaItem.compactLayouts;
                }
                else if(metaType == 'WebLink')
                {
                    var srcMetaItem = srcjson.CustomObject;
                    srcitems = srcMetaItem.webLinks;
                }
                else if(metaType == 'RecordType')
                {
                    var srcMetaItem = srcjson.CustomObject;
                    srcitems = srcMetaItem.recordTypes;
                }
                else if(metaType == 'FieldSet')
                {
                    var srcMetaItem = srcjson.CustomObject;
                    srcitems = srcMetaItem.fieldSets;
                }
                else if(metaType == 'ValidationRule')
                {
                    var srcMetaItem = srcjson.CustomObject;
                    srcitems = srcMetaItem.validationRules;
                }
                else if(metaType == 'AssignmentRule')
                {
                    var srcMetaItem = srcjson.AssignmentRules;
                    srcitems = srcMetaItem.assignmentRule;
                }
                else if(metaType == 'AutoResponseRule')
                {
                    var srcMetaItem = srcjson.AutoResponseRules;
                    srcitems = srcMetaItem.autoResponseRule;
                }
                else if(metaType == 'WorkflowTask')
                {
                    var srcMetaItem = srcjson.Workflow;
                    srcitems = srcMetaItem.tasks;
                }
                else if(metaType == 'WorkflowOutboundMessage')
                {
                    var srcMetaItem = srcjson.Workflow;
                    srcitems = srcMetaItem.outboundMessages;
                }
                else if(metaType == 'WorkflowFieldUpdate')
                {
                    var srcMetaItem = srcjson.Workflow;
                    srcitems = srcMetaItem.fieldUpdates;
                }
                else if(metaType == 'WorkflowAlert')
                {
                    var srcMetaItem = srcjson.Workflow;
                    srcitems = srcMetaItem.alerts;
                }
                else if( metaType == 'WorkflowRule')
                {
                    var srcMetaItem = srcjson.Workflow;
                    srcitems = srcMetaItem.rules;
                }
                else if(metaType == 'SharingCriteriaRule')
                {
                    var srcMetaItem = srcjson.SharingRules;
                    srcitems = srcMetaItem.sharingCriteriaRules;
                }
                else if(metaType == 'SharingOwnerRule')
                {
                    var srcMetaItem = srcjson.SharingRules;
                    srcitems = srcMetaItem.sharingOwnerRules;
                }
                else if(metaType == 'BusinessProcess')
                {
                    var srcMetaItem = srcjson.CustomObject;
                    srcitems = srcMetaItem.businessProcesses;
                }
                else if(metaType == 'SharingReason')
                {
                    var srcMetaItem = srcjson.CustomObject;
                    srcitems = srcMetaItem.sharingReasons;
                }
                else if(metaType == 'EscalationRule')
                {
                    var srcMetaItem = srcjson.EscalationRules;
                    srcitems = srcMetaItem.escalationRule;
                }
                else if(metaType == 'MatchingRule')    
                {
                    var srcMetaItem = srcjson.MatchingRules;
                    srcitems = srcMetaItem.matchingRules;
                }
                else if(metaType == 'ManagedTopic')
                {
                    var srcMetaItem = srcjson.ManagedTopics;
                    srcitems = srcMetaItem.ManagedTopic;
                }
                if(srcitems != undefined)
                {
                    if(srcitems.fullName == undefined)
                    {   
                        for(var i in srcitems)  
                        {
                            if(i < srcitems.length)
                            {
                                var v = srcitems[i];
                                jsnMap[v.fullName]= JSON.stringify(v);
                            }
                        }            
                    }
                    else
                    {
                        jsnMap[srcitems.fullName] = JSON.stringify(srcitems);
                    }
                }
            }
            for(var name in jsnMap)
            {
                var tempXml = '';
                var tempJSON = jsnMap[name];
                if(tempJSON != undefined)
                {
                    //header
                    if(metaType == 'CustomLabel')
                    {
                        tempXml = '<?xml version="1.0" encoding="UTF-8"?><CustomLabels xmlns="http://soap.sforce.com/2006/04/metadata">';
                    }
                    else if(metaType == 'AssignmentRule' )
                    {
                        tempXml = '<?xml version="1.0" encoding="UTF-8"?><AssignmentRules xmlns="http://soap.sforce.com/2006/04/metadata">';
                    }
                    else if(metaType == 'AutoResponseRule')
                    {
                        tempXml = '<?xml version="1.0" encoding="UTF-8"?><AutoResponseRules xmlns="http://soap.sforce.com/2006/04/metadata">';
                    }
                    else if(metaType == 'WorkflowAlert' || metaType == 'WorkflowFieldUpdate'|| metaType == 'WorkflowOutboundMessage'|| metaType == 'WorkflowTask' || metaType == 'WorkflowRule')
                    {
                        tempXml = '<?xml version="1.0" encoding="UTF-8"?><Workflow xmlns="http://soap.sforce.com/2006/04/metadata">';
                    }
                    else if(metaType == 'SharingCriteriaRule' || metaType == 'SharingOwnerRule')
                    {
                        tempXml = '<?xml version="1.0" encoding="UTF-8"?><SharingRules xmlns="http://soap.sforce.com/2006/04/metadata">';
                    }
                    else if(metaType == 'EscalationRule')
                    {
                        tempXml = '<?xml version="1.0" encoding="UTF-8"?><EscalationRules xmlns="http://soap.sforce.com/2006/04/metadata">';
                    }
                    else if(metaType == 'MatchingRule')
                    {
                        tempXml = '<?xml version="1.0" encoding="UTF-8"?><MatchingRules xmlns="http://soap.sforce.com/2006/04/metadata">';
                    }
                    else if(metaType == 'ManagedTopic')
                    {
                        tempXml = '<?xml version="1.0" encoding="UTF-8"?><ManagedTopics xmlns="http://soap.sforce.com/2006/04/metadata">';
                    }
                    else
                    {
                        tempXml = '<?xml version="1.0" encoding="UTF-8"?><CustomObject xmlns="http://soap.sforce.com/2006/04/metadata">';
                    }
                    
                    //body
                    if(metaType == 'CustomLabel')
                    {
                        tempXml = tempXml +'<labels>'+x2js.json2xml_str($.parseJSON(tempJSON))+'</labels>';
                    }
                    else if(metaType == 'CustomField')
                    {
                        tempXml = tempXml +'<fields>'+x2js.json2xml_str($.parseJSON(tempJSON))+'</fields>';
                    }
                    else if(metaType == 'ListView')
                    {
                        tempXml = tempXml +'<listViews>'+x2js.json2xml_str($.parseJSON(tempJSON))+'</listViews>';
                    }
                    else if(metaType == 'CompactLayout')
                    {
                        tempXml = tempXml +'<compactLayouts>'+x2js.json2xml_str($.parseJSON(tempJSON))+'</compactLayouts>';
                    }
                    else if(metaType == 'WebLink')
                    {
                        tempXml = tempXml +'<webLinks>'+x2js.json2xml_str($.parseJSON(tempJSON))+'</webLinks>';
                    }
                    else if(metaType == 'RecordType')
                    {
                        tempXml = tempXml +'<recordTypes>'+x2js.json2xml_str($.parseJSON(tempJSON))+'</recordTypes>';
                    }
                    else if(metaType == 'FieldSet')
                    {
                        tempXml = tempXml +'<fieldSets>'+x2js.json2xml_str($.parseJSON(tempJSON))+'</fieldSets>';
                    }
                    else if(metaType == 'ValidationRule')
                    {
                        tempXml = tempXml +'<validationRules>'+x2js.json2xml_str($.parseJSON(tempJSON))+'</validationRules>';
                    }
                    else if(metaType == 'AssignmentRule')
                    {
                        tempXml = tempXml +'<assignmentRule>'+x2js.json2xml_str($.parseJSON(tempJSON))+'</assignmentRule>';
                    }
                    else if(metaType == 'AutoResponseRule')
                    {
                        tempXml = tempXml +'<autoResponseRule>'+x2js.json2xml_str($.parseJSON(tempJSON))+'</autoResponseRule>';
                    }
                    else if(metaType == 'WorkflowAlert')
                    {
                        tempXml = tempXml +'<alerts>'+x2js.json2xml_str($.parseJSON(tempJSON))+'</alerts>';
                    }
                    else if(metaType == 'WorkflowFieldUpdate')
                    {
                        tempXml = tempXml +'<fieldUpdates>'+x2js.json2xml_str($.parseJSON(tempJSON))+'</fieldUpdates>';
                    }
                    else if(metaType == 'WorkflowOutboundMessage')
                    {
                        tempXml = tempXml +'<outboundMessages>'+x2js.json2xml_str($.parseJSON(tempJSON))+'</outboundMessages>';
                    }
                    else if(metaType == 'WorkflowTask')
                    {
                        tempXml = tempXml +'<tasks>'+x2js.json2xml_str($.parseJSON(tempJSON))+'</tasks>';
                    }
                    else if(metaType == 'WorkflowRule')
                    {
                        tempXml = tempXml +'<rules>'+x2js.json2xml_str($.parseJSON(tempJSON))+'</rules>';
                    }
                    else if(metaType == 'SharingCriteriaRule')
                    {
                        tempXml = tempXml +'<sharingCriteriaRules>'+x2js.json2xml_str($.parseJSON(tempJSON))+'</sharingCriteriaRules>';
                    }
                    else if(metaType == 'SharingOwnerRule')
                    {
                        tempXml = tempXml +'<sharingOwnerRules>'+x2js.json2xml_str($.parseJSON(tempJSON))+'</sharingOwnerRules>';
                    }
                    else if(metaType == 'EscalationRule')
                    {
                        tempXml = tempXml +'<escalationRule>'+x2js.json2xml_str($.parseJSON(tempJSON))+'</escalationRule>';
                    }
                    else if(metaType == 'MatchingRule')
                    {
                        tempXml = tempXml +'<matchingRules>'+x2js.json2xml_str($.parseJSON(tempJSON))+'</matchingRules>';
                    }
                    else if(metaType == 'ManagedTopic')
                    {
                        tempXml = tempXml +'<managedTopic>'+x2js.json2xml_str($.parseJSON(tempJSON))+'</managedTopic>';
                    }
                    else if(metaType == 'BusinessProcess')
                    {
                        tempXml = tempXml +'<businessProcesses>'+x2js.json2xml_str($.parseJSON(tempJSON))+'</businessProcesses>';
                    }
                    else if(metaType == 'SharingReason')
                    {
                        tempXml = tempXml +'<sharingReasons>'+x2js.json2xml_str($.parseJSON(tempJSON))+'</sharingReasons>';
                    }
                    
                    
                    //footer
                    if(metaType == 'CustomLabel')
                    {
                        tempXml = tempXml +'</CustomLabels>';
                    }
                    else if(metaType == 'AssignmentRule' )
                    {
                        tempXml = tempXml +'</AssignmentRules>';
                    }
                    else if(metaType == 'AutoResponseRule')
                    {
                        tempXml = tempXml +'</AutoResponseRules>';
                    }
                    else if(metaType == 'WorkflowAlert' || metaType == 'WorkflowFieldUpdate'|| metaType == 'WorkflowOutboundMessage'|| metaType == 'WorkflowTask' || metaType == 'WorkflowRule')
                    {
                        tempXml = tempXml +'</Workflow>';
                    }
                    else if(metaType == 'SharingCriteriaRule' || metaType == 'SharingOwnerRule')
                    {
                        tempXml = tempXml +'</SharingRules>';
                    }
                    else if(metaType == 'EscalationRule')
                    {
                        tempXml = tempXml +'</EscalationRules>';
                    }
                    else if(metaType == 'MatchingRule')
                    {
                        tempXml = tempXml +'</MatchingRules>';
                    }
                    else if(metaType == 'ManagedTopic')
                    {
                        tempXml = tempXml +'</ManagedTopics>';
                    }
                    else
                    {
                        tempXml = tempXml +'</CustomObject>';
                    }
                    tempXml = unescape(encodeURIComponent(tempXml));
                    childFileMap[metaType+"#"+fullName+""+name]= getCrcWithData(tempXml);
                }
            }
            return childFileMap;
        }
        
        function getCrcWithData(zipData)
        {
            var r = new Object();
            r.crc32 = normalZip.crc32(zipData,32);
            r.data = zipData;
            return r;
        }
        
        function setDefaultMessageOnPage(str)
        {
            if($('#msg') != undefined)
            {
                $('#msg').remove();
            }
            var parentVal = $("[id$='msg']");
            if(parentVal != undefined && str!='')
            {
                var childVal = '<span id="msg"><span ><div class="message warningM4" role="alert"><table border="0" cellpadding="0" cellspacing="0" class="messageTable" style="padding:0px;margin:0px;"><tbody><tr valign="top"><td><img alt="warning" class="" src="/s.gif" title="warning"></td><td class="messageCell"><div id="j_id0:meta:j_id15:j_id16:j_id18" class="messageText"><span>'+str+'</span></span></span>';
                parentVal.before(childVal);
            }
        }

        function getVisibileState(meta)
        {
            if(visibleStateConditionStr != undefined && visibleStateConditionStr != null && visibleStateConditionStr != '' && visibleStateMainFilterList != undefined && visibleStateMainFilterList != null && visibleStateMainFilterList.length > 0)
            {
                var tempConditionStr = visibleStateConditionStr.toLowerCase();
                tempConditionStr = tempConditionStr.replace(/and/g,'&&');
                tempConditionStr = tempConditionStr.replace(/or/g,'||');
                try
                {
                    for(var index=0; index < visibleStateMainFilterList.length; index++)
                    {
                        var filterRow = visibleStateMainFilterList[index];
                        if(filterRow != undefined && filterRow.value != undefined && filterRow.value != '' && filterRow.operator != undefined && filterRow.operator != '')
                        {
                            var fieldValue = meta[filterRow.field];
                            var filterVal = filterRow.value;
                            var filterOperator = filterRow.operator;
                            
                            if(fieldValue != undefined && filterVal != undefined)
                            {
                                fieldValue = fieldValue.toLowerCase();
                                filterVal = filterVal.toLowerCase();
                                /*console.log(filterRow);
                                console.log('fieldValue-------'+fieldValue);
                                console.log('filterOperator---'+filterOperator);
                                console.log('filterVal--------'+filterVal);*/
                                var findStr = ''+(index+1);
                                if(tempConditionStr.indexOf(findStr) > -1)
                                {
                                    var dynamicFilterRegex = new RegExp(findStr, 'g');
                                    tempConditionStr = tempConditionStr.replace(dynamicFilterRegex, ''+checkValidCondition(fieldValue,filterVal,filterOperator,filterRow.field));
                                }
                            }
                        }
                    }
                    var returnVal = eval(tempConditionStr);
                    return returnVal;
                }
                catch(err)
                {
                    console.log(err);
                }
                return false;
            }
            return true;
        }
    
        function checkValidCondition(fieldValue,filterVal,filterOperator,fieldName)
        {
            if(filterOperator == 'equals')
            {
                if(fieldName == 'type' || fieldName == 'lastModifiedByName' || fieldName == 'createdByName')
                {
                    var typeLi = filterVal.split(',');
                    for(var index = 0; index < typeLi.length; index++)
                    {
                        if(fieldValue == typeLi[index])
                            return true;
                    }
                }
                else
                {
                    if(fieldValue == filterVal)
                    {
                        return true;
                    }
                }
            }
            else if(filterOperator == 'not equals')
            {
                if(fieldName == 'type' || fieldName == 'lastModifiedByName' || fieldName == 'createdByName')
                {
                    var finalResult = true;
                    var typeLi = filterVal.split(',');
                    for(var index = 0; index < typeLi.length; index++)
                    {
                        if(fieldValue == typeLi[index])
                        {
                            finalResult = false;
                            break;
                        }
                    }
                    return finalResult;
                }
                else
                {
                    if(fieldValue != filterVal)
                    {
                        return true;
                    }
                }
            }
            else if(filterOperator == 'contains' && fieldValue != undefined && fieldValue != null)
            {
                if(fieldName == 'type')
                {
                    var typeLi = filterVal.split(',');
                    for(var index = 0; index < typeLi.length; index++)
                    {
                        if(fieldValue.indexOf(typeLi[index]) > -1)
                            return true;
                    }
                }
                else
                {
                    if(fieldValue.indexOf(filterVal) > -1)
                    {
                        return true;
                    }
                }
            }
            else if(filterOperator == 'starts with' && fieldValue != undefined && fieldValue != null)
            {
                if(fieldName == 'type')
                {
                    var typeLi = filterVal.split(',');
                    for(var index = 0; index < typeLi.length; index++)
                    {
                        if(fieldValue.indexOf(typeLi[index]) == 0)
                            return true;
                    }
                }
                else
                {
                    if((fieldValue.indexOf(filterVal) == 0))
                    {
                        return true;
                    }
                }
            }
            else if(filterOperator == 'does not contain' && fieldValue != undefined && fieldValue != null)
            {
                if(fieldName == 'type')
                {
                    var finalResult = true;
                    var typeLi = filterVal.split(',');
                    for(var index = 0; index < typeLi.length; index++)
                    {
                        if(fieldValue.indexOf(typeLi[index])  > -1)
                        {
                            finalResult = false;
                            break;
                        }
                    }
                    return finalResult;
                }
                else
                {
                    if(fieldValue.indexOf(filterVal) < 0)
                    {
                        return true;
                    }
                }
            }
            return false;
        }
        
        function formatAMPM(date){      
            var hours = date.getUTCHours();
            var minutes = date.getUTCMinutes();
            var Seconds = date.getUTCSeconds();
            var year = date.getUTCFullYear();
            var month = date.getUTCMonth()+1;
            var day = date.getUTCDate();
            day = day< 10 ? '0'+day : day;
            month = month < 10 ? '0'+month : month;

            minutes = minutes < 10 ? '0'+minutes : minutes;
            Seconds = Seconds < 10 ? '0'+Seconds : Seconds;
            hours = hours < 10 ? '0'+hours : hours;
            var strTime = year+'-'+month+'-'+day+' '+hours + ':' + minutes +':'+Seconds+' GMT';
            return strTime;
        }
        /***************************************************************************/
        var allMapMerge
        var jsonListNameComponent;
        var listFromRemoteBranch = [];

        function mergeComponents() {    
            allMapMerge = [];
            Visualforce.remoting.Manager.invokeAction(
                '{!$RemoteAction.FL_LocalWorkspaceController.mergeComponents}',
                logId,
                function(result, event) {
                    //console.log('event.status -' + event.status);
                    if(event.status) {
                        //console.log('result.length -' + result.length);
                        if(result.length > 0) {
                            for(var i = 0; i < result.length ; i++) {
                                var meta = result[i];
                                if(meta != undefined ) {
                                    allMapMerge.push(meta);
                                }
                            }
                            //console.log('allMapMerge -' + allMapMerge);

                            angular.element(document.getElementById('angularControllerId')).scope().reRenderMergeComponents();
                            //angular.element(document.getElementById('angularControllerId')).scope().enableUpdateOrg();
                            //getRemoteRepository();
                        }

                    }
                    else
                    {
                       console.log(event.message);
                       //Also show message on page
                       angular.element(document.getElementById('angularControllerId')).scope().showErrorMessage(event.message);
                       //showErrorMessage(event.message);
                    }
                }
            );
        }

        function getRemoteRepository() {
            //repeatComps() call itself till all the records are retrieved, here records are retrieved
            //in chunks of 4000 */ 
            setDefaultMessageOnPage('Downloading Changes from Remote Repository...');
            allCompsMapRemote = [];
            filteredMetaItems = {};
            requestMetaTypeLi = [];
            /*angular.element(document.getElementById('angularControllerId')).scope().disableDownload();*/
            //repeatComps();
            filterId = '';
            getComponentsRemoteRepository();
            //angular.element(document.getElementById('angularControllerId')).scope().GetComponentsRemoteRepository();
        }

        function getComponentsRemoteRepository() {    
            Visualforce.remoting.Manager.invokeAction(
                '{!$RemoteAction.FL_LocalWorkspaceController.getComponentsRemoteRepository}',
                syncId,
                filterId,
                function(result, event) {
                    if(event.status) {
                        if(result.length > 0) {
                            for(var i = 0; i < result.length ; i++) {
                                var meta = result[i];
                                if(meta != undefined && meta.compType != undefined) {
                                    var metaType = meta.compType;
                                    meta.fileName = meta.fileName;
                                    meta.fullName = meta.compName;
                                    meta.type = metaType;
                                    
                                    allCompsMapRemote.push(meta);
                                    var compList = [];
                                    if(filteredMetaItems[metaType] != undefined) {
                                        compList = filteredMetaItems[metaType];
                                    }
                                    compList.push(meta);
                                    filteredMetaItems[metaType] = compList;
                                }
                            }
                            var last = result.length -1;
                            filterId = result[last].compId+'';
                            repeatComps();
                        }
                        else {
                            for (var property in filteredMetaItems) {
                                requestMetaTypeLi.push(property);
                            }
                            setDefaultMessageOnPage('');    
                            //if(requestMetaTypeLi.length == 0) {
                                //showErrorMessage('No changes found in Remote Repository after last download.');
                                angular.element(document.getElementById('angularControllerId')).scope().showErrorMessage('No changes found in Remote Repository after last download.');
                            //}
                            angular.element(document.getElementById('angularControllerId')).scope().reRenderRemoteChanges();
                            /*angular.element(document.getElementById('angularControllerId')).scope().enableUpdateOrg();*/
                        }
                    }
                    else {
                        console.log(event.message);
                        //Also show message on page
                        //showErrorMessage(event.message);
                        angular.element(document.getElementById('angularControllerId')).scope().showErrorMessage(event.message);
                    }
                }
            );
        }

        function getRemoteBranch(tempList) {
            Visualforce.remoting.Manager.invokeAction(
            '{!$RemoteAction.FL_LocalWorkspaceController.getRemoteBranch}',
            jsonListNameComponent,
            function(r, e){
                if (e.status) {
                    if (r.length > 0) {
                        angular.element(document.getElementById('angularControllerId')).scope().mergeSelectedList(r);
                    }
                }
                else
                {
                    angular.element(document.getElementById('angularControllerId')).scope().showErrorMessage(e.message);
                }
            });
        }

        function updateMergeFile(tempList) {
            var param = tempList;
            Visualforce.remoting.Manager.invokeAction(
            '{!$RemoteAction.FL_LocalWorkspaceController.updateMergeFile}',
            param,
            function(r, e){
                if (e.status == false) {
                    angular.element(document.getElementById('angularControllerId')).scope().showErrorMessage(e.message);
                }
            });
        }

        function deleteMainTag(xmlFile) {
            var tempXml = xmlFile;
            
            if (tempXml.lastIndexOf('</') != -1) {
                var position = tempXml.lastIndexOf('</');
                var position2 = tempXml.lastIndexOf('>');
                closeMainTag = tempXml.substr(position+2, position2 - position - 2);

                openMainTag = '<' + closeMainTag;
                closeMainTag = '</' + closeMainTag + '>';
                //console.log('closeMainTag = ' + closeMainTag);

                //openMainTag = '<' + closeMainTag.substr(2, closeMainTag.length - 3);
                //console.log('openMainTag = ' + openMainTag);

                var tempXml2 = '';
                if (tempXml.indexOf(openMainTag) != -1) {
                    position = tempXml.indexOf(openMainTag);
                    tempXml2 = tempXml.substr(position);

                    position = tempXml2.indexOf('>');
                    openMainTag = tempXml2.substr(0, position + 1);

                    position = tempXml.indexOf(openMainTag);
                    position2 = tempXml.lastIndexOf(closeMainTag);

                    beforOpenMainTag = tempXml.substr(0, position);
                    betweenMainTag = tempXml.substr(position + openMainTag.length, position2 - position - openMainTag.length);
                    //console.log('beforOpenMainTag = ' + beforOpenMainTag);
                    //console.log('openMainTag = ' + openMainTag);
                    //console.log('betweenMainTag = ' + betweenMainTag);
                }
            }
        }

        function formatXmlDeleteTitle(xml) {
            var result = xml;
            if (result.indexOf('>') != -1) {
                result = result.substr(result.indexOf('>')+1);
            }
            if (result.indexOf('<') != -1) {
                result = result.substr(result.indexOf('<'));
            }
            //console.log('II>>>>>result\n\n'+result);

            return result;
        }

        function formatXmlParse(xml, newXml) {
            var tempXml = xml;
            var resultXml = newXml;
            if (tempXml.indexOf('<0>') != -1) {
                var position = tempXml.indexOf('<0>');
                var startStr = tempXml.substr(0, position);

                //console.log('position = ' + position);
                //console.log('startStr = ' + startStr);

                var startMainTag = -1;
                var endMainTag = -1;
                if (startStr.lastIndexOf('<') != -1) {
                    startMainTag = startStr.lastIndexOf('<');
                }
                if (startStr.lastIndexOf('>') != -1) {
                    endMainTag = startStr.lastIndexOf('>');
                }
                
                var mainTag = '';
                var mainTagClose = '';
                //console.log('startMainTag = ' + startMainTag);
                //console.log('endMainTag = ' + endMainTag);
                if (startMainTag != -1 && endMainTag != -1) {
                    mainTag = startStr.substr(startMainTag, endMainTag - startMainTag + 1);
                    mainTagClose = '</' + mainTag.substr(1);
                }

                //console.log('mainTag = ' + mainTag);
                //console.log('mainTagClose = ' + mainTagClose);

                var bodyMainTag = '';
                // if (tempXml.lastIndexOf(mainTag) != -1 && tempXml.lastIndexOf(mainTagClose) != -1) {
                //     startMainTag = tempXml.lastIndexOf(mainTag);
                //     endMainTag = tempXml.lastIndexOf(mainTagClose);
                //     console.log('startMainTag = ' + startMainTag);
                //     console.log('endMainTag = ' + endMainTag);
                //     console.log(endMainTag - startMainTag + mainTagClose.length);
                //     bodyMainTag = tempXml.substr(startMainTag, endMainTag - startMainTag + mainTagClose.length);
                // }
                if (tempXml.indexOf(mainTag) != -1 && tempXml.indexOf(mainTagClose) != -1) {
                    startMainTag = tempXml.indexOf(mainTag);
                    endMainTag = tempXml.indexOf(mainTagClose);
                    //console.log('startMainTag = ' + startMainTag);
                    //console.log('endMainTag = ' + endMainTag);
                    //console.log(endMainTag - startMainTag + mainTagClose.length);
                    bodyMainTag = tempXml.substr(startMainTag, endMainTag - startMainTag + mainTagClose.length);
                }

                //console.log('bodyMainTag = ' + bodyMainTag);
                bodyMainTag = parseBodyArr(mainTag, mainTagClose, bodyMainTag);
                //console.log('bodyMainTag = ' + bodyMainTag);
                
                //console.log('startMainTag = ' + startMainTag);
                //console.log('endMainTag = ' + endMainTag);
                //console.log('tempXml.length = ' + tempXml.length);

                resultXml += tempXml.substr(0, startMainTag) + bodyMainTag;
                tempXml = tempXml.substr(endMainTag + mainTagClose.length);

                //console.log('mainTag = ' + mainTag);
                //console.log('mainTagClose = ' + mainTagClose);
                //console.log('resultXml = ' + resultXml);
                //console.log('tempXml = ' + tempXml);

                resultXml = formatXmlParse(tempXml, resultXml);
            }
            else {
                resultXml += tempXml;
            }

            return resultXml;
        }

        function parseBodyArr(mainTag, mainTagClose, bodyMainTag) {
            //console.log('bodyMainTag.length - mainTag.length - mainTag.length = ' + (bodyMainTag.length - mainTag.length - mainTag.length));
            var tempBody = bodyMainTag.substr(mainTag.length, bodyMainTag.length - mainTag.length - mainTag.length - 1);
            var result = '';
            //console.log('tempBody = ' + tempBody);

            var startLastTag = -1;
            var endLastTag = -1;
            var lastTag = '';
            if (tempBody.lastIndexOf('</') != -1) {
                startLastTag = tempBody.lastIndexOf('</');
            }
            if (tempBody.lastIndexOf('>') != -1) {
                endLastTag = tempBody.lastIndexOf('>');
            }
            if (startLastTag != -1 && endLastTag != -1) {
                lastTag = tempBody.substr(startLastTag + 2, endLastTag - startLastTag - 2);
            }
            //console.log('lastTag = ' + lastTag);

            for (var i = 0; i <= Number(lastTag); i++) {
                if (tempBody.indexOf('<' + i.toString() + '>') != -1) {
                    var startIndexTag = -1;
                    var endIndexTag = -1;
                    var strIndexBody = '';
                    //var strIndexTag = '';
                    var indexTag = '';
                    if (tempBody.indexOf('<' + i.toString() + '>') != -1) {
                        startIndexTag = tempBody.indexOf('<' + i.toString() + '>');
                    }
                    if (tempBody.indexOf('</' + i.toString() + '>') != -1) {
                        endIndexTag = tempBody.indexOf('</' + i.toString() + '>');
                    }

                    //console.log('startIndexTag = ' + startIndexTag);
                    //console.log('endIndexTag = ' + endIndexTag);

                    //var strStartTag = '<' + i.toString() + '>';
                    //var strEndTag = '<' + i.toString() + '>';
                    if (startIndexTag != -1 && endIndexTag != -1) {
                        strIndexBody = tempBody.substr(startIndexTag + (i.toString().length + 2), endIndexTag - startIndexTag - (i.toString().length + 2));
                        //tempBody = tempBody.substr(endIndexTag + (i.toString().length +3));
                        //indexTag = tempBody.substr(startIndexTag + 2, endIndexTag - startIndexTag - 1);
                    }
                    //console.log(i.toString() + ' - strIndexBody = ' + strIndexBody);
                    //console.log('tempBody = ' + tempBody);

                    //////////////*************
                    var newBody = '';
                    if (strIndexBody.indexOf('<0>') != -1) {
                        //newBody = strIndexBody.substr(strIndexBody.indexOf('<' + i.toString() + '>'), strIndexBody.indexOf('<0>'));
                        newBody = strIndexBody.substr(0, strIndexBody.indexOf('<0>'));
                        //console.log('newBody = ' + newBody);

                        var newStartMainTag = -1;
                        var newEndMainTag = -1;
                        if (newBody.lastIndexOf('<') != -1) {
                            newStartMainTag = newBody.lastIndexOf('<');
                        }
                        if (newBody.lastIndexOf('>') != -1) {
                            newEndMainTag = newBody.lastIndexOf('>');
                        }
                        
                        var newMainTag = '';
                        var newMainTagClose = '';
                        //console.log('newStartMainTag = ' + newStartMainTag);
                        //console.log('newEndMainTag = ' + newEndMainTag);
                        if (newStartMainTag != -1 && newEndMainTag != -1) {
                            newMainTag = newBody.substr(newStartMainTag, newEndMainTag - newStartMainTag + 1);
                            newMainTagClose = '</' + newMainTag.substr(1);
                        }

                        if (i == 0) {
                            var tempBody1 = tempBody.substr(0, tempBody.indexOf(newMainTag));
                            var tempBody2 = tempBody.substr(tempBody.indexOf(newMainTag), tempBody.indexOf(newMainTagClose) - tempBody.indexOf(newMainTag) + newMainTagClose.length);
                            var tempBody3 = tempBody.substr(tempBody.indexOf(newMainTagClose) + newMainTagClose.length);
                            //console.log('tempBody1 = ' + tempBody1);
                            //console.log('tempBody2 = ' + tempBody2);
                            //console.log('tempBody3 = ' + tempBody3);

                            tempBody2 = formatXmlParse(tempBody2, '');
                            //console.log('tempBody2 = ' + tempBody2);

                            tempBody = tempBody1 + tempBody2 + tempBody3;
                        }
                        else {
                            var tempBody00 = tempBody.substr(0, tempBody.indexOf('<' + i.toString() + '>') + ('<' + i.toString() + '>').length);
                            var tempBodyLast = tempBody.substr(tempBody.indexOf('<' + i.toString() + '>') + ('<' + i.toString() + '>').length);
                            var tempBody11 = tempBodyLast.substr(0, tempBodyLast.indexOf(newMainTag));
                            var tempBody22 = tempBodyLast.substr(tempBodyLast.indexOf(newMainTag), tempBodyLast.indexOf(newMainTagClose) - tempBodyLast.indexOf(newMainTag) + newMainTagClose.length);
                            var tempBody33 = tempBodyLast.substr(tempBodyLast.indexOf(newMainTagClose) + newMainTagClose.length);
                            //console.log('tempBody11 = ' + tempBody11);
                            //console.log('tempBody22 = ' + tempBody22);
                            //console.log('tempBody33 = ' + tempBody33);

                            tempBody22 = formatXmlParse(tempBody22, '');
                            //console.log('tempBody22 = ' + tempBody22);

                            tempBody = tempBody00 + tempBody11 + tempBody22 + tempBody33;
                        }

                        
                        
                        //strIndexBody = formatXmlParse(strIndexBody, '');
                        var newStartIndexTag = -1;
                        var newEndIndexTag = -1;
                        strIndexBody = '';
                        //var strIndexTag = '';
                        var indexTag = '';
                        if (tempBody.indexOf('<' + i.toString() + '>') != -1) {
                            newStartIndexTag = tempBody.indexOf('<' + i.toString() + '>');
                        }
                        if (tempBody.indexOf('</' + i.toString() + '>') != -1) {
                            newEndIndexTag = tempBody.indexOf('</' + i.toString() + '>');
                        }

                        //console.log('newStartIndexTag = ' + newStartIndexTag);
                        //console.log('newEndIndexTag = ' + newEndIndexTag);

                        //var strStartTag = '<' + i.toString() + '>';
                        //var strEndTag = '<' + i.toString() + '>';
                        if (newStartIndexTag != -1 && newEndIndexTag != -1) {
                            strIndexBody = tempBody.substr(newStartIndexTag + (i.toString().length + 2), newEndIndexTag - newStartIndexTag - (i.toString().length + 2));
                            //tempBody = tempBody.substr(newEndIndexTag + (i.toString().length +3));
                            //indexTag = tempBody.substr(newStartIndexTag + 2, newEndIndexTag - newStartIndexTag - 1);
                        }
                        //console.log('strIndexBody = ' + strIndexBody);
                        //console.log('tempBody = ' + tempBody);

                        strIndexBody = formatXmlParse(strIndexBody, '');
                    }
                    //////////////*************

                    /**************************************************/
                    //var strIndexBody = '<fullName>Needs Analysis</fullName><default>false</default>';
                    var notEmptyTags = 0
                    var arrIndexBody = strIndexBody.split('</') ;
                    if (arrIndexBody.length > 1) {
                        for (k = 0; k < arrIndexBody.length; k++) {
                            lastChar = arrIndexBody[k].substr(arrIndexBody[k].length - 1);
                            if (lastChar != '>') {
                                notEmptyTags = 1;
                            }
                        }
                    }
                    else {
                        notEmptyTags = 1;
                    }
                    //console.log('notEmptyTags = ' + notEmptyTags);
                    /**************************************************/

                    if (notEmptyTags == 1) {
                        if (strIndexBody.indexOf('<0>') != -1) {
                            strIndexBody = formatXmlParse(strIndexBody, '');
                        }
                        result += mainTag + strIndexBody + mainTagClose;
                    }
                }
            }
            //console.log('result = ' + result);

            //tempBody = tempBody.replace(/<[0-9]*[0-9]*[0-9]>/g, mainTag);
            //tempBody = tempBody.replace(/<\/[0-9]*[0-9]*[0-9]>/g, mainTagClose);
            //return tempBody;

            return result;
        }

        function formatXml(xml) {
            var reg = /(>)(<)(\/*)/g;
            var wsexp = / *(.*) +\n/g;
            var contexp = /(<.+>)(.+\n)/g;
            xml = xml.replace(reg, '$1\n$2$3').replace(wsexp, '$1\n').replace(contexp, '$1\n$2');
            var pad = 0;
            var formatted = '';
            var lines = xml.split('\n');
            var indent = 0;
            var lastType = 'other';
            // 4 types of tags - single, closing, opening, other (text, doctype, comment) - 4*4 = 16 transitions 
            var transitions = {
                'single->single'    : 0,
                'single->closing'   : -1,
                'single->opening'   : 0,
                'single->other'     : 0,
                'closing->single'   : 0,
                'closing->closing'  : -1,
                'closing->opening'  : 0,
                'closing->other'    : 0,
                'opening->single'   : 1,
                'opening->closing'  : 0, 
                'opening->opening'  : 1,
                'opening->other'    : 1,
                'other->single'     : 0,
                'other->closing'    : -1,
                'other->opening'    : 0,
                'other->other'      : 0
            };

            for (var i=0; i < lines.length; i++) {
                var ln = lines[i];
                var single = Boolean(ln.match(/<.+\/>/)); // is this line a single tag? ex. <br />
                var closing = Boolean(ln.match(/<\/.+>/)); // is this a closing tag? ex. </a>
                var opening = Boolean(ln.match(/<[^!].*>/)); // is this even a tag (that's not <!something>)
                var type = single ? 'single' : closing ? 'closing' : opening ? 'opening' : 'other';
                var fromTo = lastType + '->' + type;
                lastType = type;
                var padding = '';

                indent += transitions[fromTo];
                for (var j = 0; j < indent; j++) {
                    padding += '\t';
                }

                formatted += padding + ln + '\n';
            }

            var str = formatted;
            var lastPosition=0;
            var positions = [];
            for(var i=0; i<str.length; i++) {
                if (str[i] == '<' && str[i+1]=='/') {
                    //console.log('1-'+i);
                    lastPosition = i-1;
                    var temp = {};
                    temp.b = i-1;
            
                    for(i; i>0; i--) {
                        if(str[i] == '>') {
                            temp.a = i+1;
                            positions.push(temp);
                            i = lastPosition+1;
                            //console.log(positions);
                            break;
                        }
                    }
                }
            }

            var result = '';
            for (var k=0; k<positions.length; k++) {
                if (k==0) {
                    result = str.substr(0, positions[k].a);
                    //console.log(result);
                }
                var strAB = str.substr(positions[k].a, positions[k].b - positions[k].a + 1);
                if (k == positions.length-1) {
                    var strBz = str.substr(positions[k].b + 1);
                    //console.log('\''+strBz+'\'');
                }
                else {
                    var strBz = str.substr(positions[k].b + 1, positions[k+1].a - positions[k].b-1);
                    //console.log('\''+strBz+'\'');
                }
                // var tempStr = strAB.match(/[\wа-яё]+/gi);
            
                if (strAB.match(/[\wа-яё]+/gi) != null) {
                    strAB = strAB.replace(/\t/ig, '');
                    strAB = strAB.replace(/\n/ig, '');
                }
              
                result += strAB;
                result += strBz;
                //console.log('\''+strAB+'\'');
                //console.log(result);
            }

            if (result != '') {
                formatted = result;
            }

            return formatted;
        };

        function formatXmldeleteEmptyTag(resStr, xml) {
            var tempXml = xml;
            var resultXml = resStr;
            if (tempXml.indexOf('</') != -1) {
                var position = tempXml.indexOf('</');
                var tempStrForCloseTag = tempXml.substr(position);
                var closeTag = '';
                var openTag = '';
                if (tempStrForCloseTag.indexOf('>') != -1) {
                    position = tempStrForCloseTag.indexOf('>');
                    closeTag = tempStrForCloseTag.substr(0, position + 1);
                    openTag = '<' + closeTag.substr(2, closeTag.length - 2);
                }
                
                var bodyTags = '';
                var position1 = -1;
                var position2 = -1;
                
                if (tempXml.indexOf(openTag) != -1 && tempXml.indexOf(closeTag) != -1) {
                    position1 = tempXml.indexOf(openTag);
                    position2 = tempXml.indexOf(closeTag);
                    if (position2 > position1) {
                        bodyTags = tempXml.substr(position1 + openTag.length, position2 - position1 - closeTag.length + 1);
                    }
                }
                
                var strStart = '';
                var strEnd = '';
                
                if (tempXml.indexOf(openTag) < 0 || position2 < position1) {
                    position2 = tempXml.indexOf(closeTag);
                    strStart = tempXml.substr(0, position2 + closeTag.length);
                    strEnd = tempXml.substr(position2 + closeTag.length);
                }
                
                if (bodyTags != '') {
                    if (bodyTags.match(/[\wа-яё]+/gi) != null) {
                        strStart = tempXml.substr(0, position2 + closeTag.length);
                        strEnd = tempXml.substr(position2 + closeTag.length);
                    }
                    else {
                        var strStart = tempXml.substr(0, position1);
                        var lastTagPosition = strStart.lastIndexOf('>');
                        strStart = strStart.substr(0, lastTagPosition);
                        var strEnd = tempXml.substr(position2 + closeTag.length);
                    }
                }
                
                resultXml += strStart;
                
                resultXml = formatXmldeleteEmptyTag(resultXml, strEnd);
            }
            else {
                resultXml += tempXml;
            }

            return resultXml;
        };

        /***************************************************************************/
    </script>

    <style>
        .MergeXML.ngdialog.ngdialog-theme-default .ngdialog-content {
            width: 95%;
            min-width: 850px;
        }
        .MergeText.ngdialog.ngdialog-theme-default .ngdialog-content {
            width: 95%;
            min-width: 850px;
        }

        .ngdialog.ngdialog-theme-default .ngdialog-content {
            min-width: 850px;
        }
        
        li {
            list-style-type: none;
        }
        .flex {
            display: -webkit-box;
             display: -webkit-flex;
             display: -ms-flexbox;
             display: flex;
        }
        
        tr {
            display: table-row;
            vertical-align: inherit;
            border-color: inherit;
        }
        .sf-inner-container pre {
            display: block; 
            padding: 0px; 
            margin: 0px;
            font-size: 12px;
            line-height: normal;
            color: #333;
            word-break: break-all;
            word-wrap: break-word;
            background-color: ;
            border-radius: 0px;
            border: ivory;
            height: 18px;
            background-color: white;
        }
        .iconnDiff {
            cursor: pointer;
            border: 1px solid #9C9C9C;
            /*padding: 2px;*/
            padding: 0px;
            border-radius: 3px;
            background-color: #DEDEDE;
        }
        .EmpyBlock {
            height: 18px;
        }
        .sf-inner-container .removeClass {
            background-color: #717ECD;
            min-width: 850px;
        }
        .sf-inner-container .addClass{
            background-color: #4EB1CB;
            min-width: 850px;
        }
        .sf-inner-container .editClass{
            background-color: #F9F2AD;
            min-width: 850px;
        }
        .sf-inner-container td, .sf-inner-container th {
            border: 0.1px solid #9C9C9C;
            padding: 3px;
            vertical-align: top;
        }
        
        .spinner {
          width: 50px;
          height: 40px;
          text-align: center;
          font-size: 10px;
          border: 0.1px solid #36a0fe;
          border-radius: 6px;
          width: 100%;
        }

        .spinner > div {
          background-color: #5E7AF7;
          height: 100%;
          width: 6px;
          display: inline-block;
           margin-left: 1px;
          -webkit-animation: sk-stretchdelay 1.2s infinite ease-in-out;
          animation: sk-stretchdelay 1.2s infinite ease-in-out;
        }
        
        .spinner .rect2 {
          -webkit-animation-delay: -1.1s;
          animation-delay: -1.1s;
        }
        
        .spinner .rect3 {
          -webkit-animation-delay: -1.0s;
          animation-delay: -1.0s;
        }
        
        .spinner .rect4 {
          -webkit-animation-delay: -0.9s;
          animation-delay: -0.9s;
        }
        
        .spinner .rect5 {
          -webkit-animation-delay: -0.8s;
          animation-delay: -0.8s;
        }
        
        .XMLinfo {
            border: 0.1px solid #D0D4D8;
            font-size: 14px;
            border-radius: 3px;
            min-width: 850px;
            width: 50%;
            margin-left: 20px;
            margin-top: -3px;
        }
        
        .XMLlabel {
                margin-right: 20px;
        }

        .borderTD {
            border-top: 1px solid #000000;
            border-bottom: 1px solid #000000;
            border-left: 1px solid #000000;
            border-right: 1px solid #000000;
        }
        
        @-webkit-keyframes sk-stretchdelay {
          0%, 40%, 100% { -webkit-transform: scaleY(0.4) }  
          20% { -webkit-transform: scaleY(1.0) }
        }
        
        @keyframes sk-stretchdelay {
          0%, 40%, 100% { 
            transform: scaleY(0.4);
            -webkit-transform: scaleY(0.4);
          }  20% { 
            transform: scaleY(1.0);
            -webkit-transform: scaleY(1.0);
          }
        }
    </style>
</apex:page>